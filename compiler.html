<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-12-14 Thu 12:25 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Compiler</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="assets/hebi.css" /><link rel="stylesheet" type="text/css" href="assets/test.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Compiler</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org48bdee1">1. Tmp</a>
<ul>
<li><a href="#org13b70f9">1.1. CYK parser</a></li>
<li><a href="#org39d2e35">1.2. Earley's algorithm</a></li>
</ul>
</li>
<li><a href="#org8a64783">2. Chomsky Hierarchy</a>
<ul>
<li><a href="#org2c61208">2.1. Attribute grammar</a></li>
<li><a href="#orgc4c1ddb">2.2. Affix grammar</a></li>
<li><a href="#org07d5382">2.3. two-level grammar</a></li>
<li><a href="#org7bb2c9d">2.4. Van Wijngaarden grammar</a></li>
<li><a href="#org2269b64">2.5. Generalized LR parser</a></li>
<li><a href="#org3561fdd">2.6. About C Grammar</a></li>
</ul>
</li>
<li><a href="#org465b2a5">3. Parser</a>
<ul>
<li><a href="#orgec22bcb">3.1. AST</a></li>
<li><a href="#org811f2f7">3.2. <span class="todo TODO">TODO</span> Write/Fix the grammar</a>
<ul>
<li><a href="#org0bbe0ad">3.2.1. <span class="todo TODO">TODO</span> Ambiguity</a></li>
<li><a href="#org1cdaaba">3.2.2. Left Recursion</a></li>
<li><a href="#org6a50ab3">3.2.3. Left Factoring</a></li>
</ul>
</li>
<li><a href="#orgb29a3d9">3.3. Top Down Parsing</a>
<ul>
<li><a href="#org2a1eb40">3.3.1. <span class="todo TODO">TODO</span> LL(1)</a></li>
<li><a href="#org9888422">3.3.2. Recursive Decent Parser v.s. LR Parser generator</a></li>
</ul>
</li>
<li><a href="#org8da52da">3.4. Bottom Up Parsing</a>
<ul>
<li><a href="#org824c2e3">3.4.1. shift-reduce parsing</a>
<ul>
<li><a href="#orgfad3cc0">3.4.1.1. The dangling else problem</a></li>
</ul>
</li>
<li><a href="#orgdc01e0d">3.4.2. LR(k) Parsing</a>
<ul>
<li><a href="#org1a11429">3.4.2.1. Simple LR Parsing (SLR)</a></li>
<li><a href="#orgb80a362">3.4.2.2. LR(1)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd6eef91">4. Syntax Directed Translation</a></li>
<li><a href="#org2ee913b">5. FIRST and FOLLOW</a></li>
<li><a href="#orgf0b5063">6. Error Recovery</a></li>
<li><a href="#orgd9f2d57">7. Tools</a>
<ul>
<li><a href="#org01b5a32">7.1. Elsa and Elkhound</a></li>
<li><a href="#org4594cb3">7.2. Semantic Design Inc</a></li>
<li><a href="#orgc447206">7.3. Parser generator</a></li>
</ul>
</li>
<li><a href="#org31de83c">8. Samples</a></li>
</ul>
</div>
</div>
<p>
This file describe the general concept of a compiler. I'm going to
relearn it in the hard way.
</p>

<div id="outline-container-org48bdee1" class="outline-2">
<h2 id="org48bdee1"><span class="section-number-2">1</span> Tmp</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org13b70f9" class="outline-3">
<h3 id="org13b70f9"><span class="section-number-3">1.1</span> CYK parser</h3>
<div class="outline-text-3" id="text-1-1">
<p>
According to the length \(n\) of the program measured by tokens, it
construct a triangle table with length \(n\).
</p>

<pre class="example">
T
T T
T T T
T T T T
a a b b
</pre>
</div>
</div>

<div id="outline-container-org39d2e35" class="outline-3">
<h3 id="org39d2e35"><span class="section-number-3">1.2</span> Earley's algorithm</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Invented by Jay Earley, it is used to parse CFG. It can parse all CFG,
while LR and LL can only handle restricted classes. It executes in
O(n<sup>3</sup>) where n is length of string, O(n<sup>2</sup>) for unambiguous grammars,
and linear for almost all LR(k) grammars. It performs particularly
well for left-recursive grammars.
</p>

<p>
Notation: for every input position, it generates a <i>state set</i> (called
S(k) for input position k), consisting of:
</p>
<ul class="org-ul">
<li>the production rule using</li>
<li>the position in that production rule</li>
<li>the original position in the string</li>
</ul>

<p>
The parser repeatedly executes three options:
</p>
<ul class="org-ul">
<li><b>Prediction</b>: for every state in S(k) of the form \(X->\alpha \cdot Y
  \beta\), add \(Y->\cdot \gamma\) to <b>S(k)</b></li>
<li><b>Scanning</b>: for every state in S(k) of form \(Y -> \alpha \cdot a
  \beta\), add \(X -> \alpha a \cdot \beta\) to <b>S(k+1)</b></li>
<li><b>Completion</b>: for every state in S(k) of the form \(X -> \gammar
  \cdot\), and &#x2026; (TODO), add \(Y -> \alpha X \cdot \beta\) to <b>S(k)</b></li>
</ul>

<pre class="example">
procedure PREDICTOR((A → α•B, i), j, grammar)
  for each (B → γ) in GRAMMAR-RULES-FOR(B, grammar) do
    ADD-TO-SET((B → •γ, j), chart[ j])
procedure SCANNER((A → α•B, i), j)
  if B ⊂ PARTS-OF-SPEECH(word[j]) then
    ADD-TO-SET((B → word[j], i), chart[j + 1])
procedure COMPLETER((B → γ•, j), k)
  for each (A → α•Bβ, i) in chart[j] do
    ADD-TO-SET((A → αB•β, i), chart[k])
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a64783" class="outline-2">
<h2 id="org8a64783"><span class="section-number-2">2</span> Chomsky Hierarchy</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org2c61208" class="outline-3">
<h3 id="org2c61208"><span class="section-number-3">2.1</span> Attribute grammar</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The <b>evaluation</b> of the node will benefit from the attributes. It is
categories into synthesized attributes and inherited attributes. This
is mentioned in the syntax-directed translation part of dragon book,
so I don't really think it is syntax related.
</p>
</div>
</div>

<div id="outline-container-orgc4c1ddb" class="outline-3">
<h3 id="orgc4c1ddb"><span class="section-number-3">2.2</span> Affix grammar</h3>
<div class="outline-text-3" id="text-2-2">
<p>
This seems to be synonyms of attribute grammar. Wikipedia has an
example of using it to resolve the plural verbs, e.g. <code>John likes
children</code>. The grammar does make perfect sense to me though.
</p>

<pre class="example">
Sentence → Subject + number Predicate+number
Subject + number → Noun + number
Predicate + number → Verb + number Object
Object → Noun + number
Noun + singular → John
Noun + singular → Mary
Noun + plural → children
Noun + plural → parents
Verb + singular → likes
Verb + plural → like
Verb + singular → helps
Verb + plural → help
</pre>
</div>
</div>


<div id="outline-container-org07d5382" class="outline-3">
<h3 id="org07d5382"><span class="section-number-3">2.3</span> two-level grammar</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Two level grammar is used to generate another formal grammar. This is
like meta programming, or abstraction. One advantage is that is can
define a grammar with infinite number of rules, due that it is
generated.
</p>

<p>
For the context-sensitive language <code>{a^nb^nc^n}</code>, the two level
grammar is:
</p>
<pre class="example">
N ::= 1 | N1
X ::= a | b
</pre>

<p>
<b>Together</b> with the schema:
</p>
<pre class="example">
S ::= &lt;a^N&gt;&lt;b^N&gt;&lt;c^N&gt;
&lt;X^{N1}&gt; ::= &lt;X^N&gt; X
&lt;X^1&gt; ::= X
</pre>
</div>
</div>

<div id="outline-container-org7bb2c9d" class="outline-3">
<h3 id="org7bb2c9d"><span class="section-number-3">2.4</span> Van Wijngaarden grammar</h3>
<div class="outline-text-3" id="text-2-4">
<p>
It is named by its inventor, and used in the language ALGOL 68. It is
also called vW-grammar, or W-grammar. Also note that it is too
powerful and also impractical as well.
</p>


<p>
It is:
</p>
<ul class="org-ul">
<li>affix grammar</li>
<li>two-level grammar</li>
</ul>

<p>
The ALGOL 68 grammar:
</p>
<pre class="example">
a) program : open symbol, standard prelude,
     library prelude option, particular program, exit,
     library postlude option, standard postlude, close symbol.
b) standard prelude : declaration prelude sequence.
c) library prelude : declaration prelude sequence.
d) particular program :
     label sequence option, strong CLOSED void clause.
e) exit : go on symbol, letter e letter x letter i letter t, label symbol.
f) library postlude : statement interlude.
g) standard postlude : strong void clause train
</pre>

<p>
The idea is simple: provide non-terminal symbols with attributes (or
affixes) that pass information between nodes of parse tree. This seems
essentially to be using syntax to specify semantics. E.g. <code>variable :=
value</code> is in-complete but instead <code>REF TYPE variable := TYPE value</code>.
</p>
</div>
</div>


<div id="outline-container-org2269b64" class="outline-3">
<h3 id="org2269b64"><span class="section-number-3">2.5</span> Generalized LR parser</h3>
<div class="outline-text-3" id="text-2-5">
<p>
LR cannot handle nondeteministic and ambiguous grammars. GLR allows
shift/reduce and reduce/reduce conflicts. It does that by doing a
breadth-first-search, whenever multiple choices can be taken. All the
choices are explored simultaneously, until it reach an error state or
merge into another (if they generate the same set of symbols).
</p>
</div>
</div>

<div id="outline-container-org3561fdd" class="outline-3">
<h3 id="org3561fdd"><span class="section-number-3">2.6</span> About C Grammar</h3>
<div class="outline-text-3" id="text-2-6">
<p>
This is a easily misunderstood problem.
There's a old 1989 discussion on comp.lang.misc:
</p>
<ul class="org-ul">
<li><a href="https://groups.google.com/forum/#!topic/comp.lang.misc/MCZmQv56--Q">https://groups.google.com/forum/#!topic/comp.lang.misc/MCZmQv56--Q</a></li>
</ul>

<p>
So here's my understanding:
C language is context sensitive:
</p>
<ul class="org-ul">
<li>an identifier must be previously defined, to be able to be a typedef-name
<ul class="org-ul">
<li>this is different from an undeclared variable: an identifier is
always parsed into category "identifier", regardless of whether it
has been declared. However, undefined typedefs are ambiguous.</li>
<li>typedef-name : identifier</li>
</ul></li>
<li>else must match the closest else-less if</li>
<li>continue and break must be in correct context</li>
</ul>

<p>
On the other hand, the C grammar in the back of K&amp;R, <b>is</b>
context-free, because it is in BNF format. However, it accepts more
than C language.
</p>

<p>
Also in another word, the K&amp;R grammar generates valid C programs and
some invalid ones, and those are detected by the semantic analyzer.
</p>

<p>
A word about ambiguity: it does not affect the language it generates,
but only generates (or recognizes) the same sentence in multiple ways.
</p>

<p>
Yacc generates LALR(1) parser. The C grammar is not a <i>no-feedback
yacc-able grammar.</i> The thing is, when the lexer is trying the rule
"typedef-name: identifier", the lexer should answer "typedef-name" iff
the identifier happens to be a typedef name.. We also need to make
sure that it tries this rule before the rule "primary: identifier". So
the implementation is to add a predicate
"identifier-is-really-typedef" to the action of the rule
"typedef-name".
</p>


<p>
K&amp;R has the following sentence:
</p>
<blockquote>
<p>
With one further change, namely deleting the production typedef-name:
identifier and making typedef-name a terminal symbol, this grammar is
acceptable to the YACC parser-generator.
</p>
</blockquote>

<p>
This is the fundamental reason why the yacc grammar differs from the
K&amp;R grammar. The typedef-name a terminal symbol also means that, C
does have a infinite number of (non?-)terminals.
</p>

<p>
David Gudeman in that mailing archive said one sentence:
</p>
<blockquote>
<p>
The grammar is intended to show syntactic categories with semantic
attachment.
</p>
</blockquote>

<p>
And someone said:
</p>
<blockquote>
<p>
we generally do not write grammars that accept only strictly correct
inputs.  Instead, we take some shortcuts and patch things up via
semantics.
</p>
</blockquote>

<p>
Chris Torek:
</p>
<blockquote>
<p>
Strictly speaking (as long as you stick with `typedef produces a new
type specifier'), C's grammar is not context free; but it is indeed
not seriously `screwed up'.  Perfect generators are not necessary, and
a language `close enough to C' exists that can be parsed simply.
</p>
</blockquote>

<p>
Since typedef produce a new "terminal", can we really say C grammar
has infinite number of "terminals", and the definition of Chomsky
hierarchy context free grammar does not hold for C grammar.
</p>

<p>
The C grammar in back of K&amp;R by no means is the correct C grammar, or
the grammar used in compiler implementation.
</p>

<p>
The typedef-name problem is also called <i>The Lexer Hack</i>. There must
be a feedback loop from the parser to insert the typedef-name into the
symbol table, and the lexer will use this information to determine
whether it is a typedef-name or token. The parser action must insert
this table before the <code>,=;</code> declarator terminator, because the lexer
is allowed to lookahead 1 token, and the token might be an identifier.
</p>
</div>
</div>
</div>



<div id="outline-container-org465b2a5" class="outline-2">
<h2 id="org465b2a5"><span class="section-number-2">3</span> Parser</h2>
<div class="outline-text-2" id="text-3">
<p>
Three category of parsers:
</p>
<dl class="org-dl">
<dt>universal</dt><dd>Cocke–Younger–Kasami algorithm (CYK) and the Earley
parser. They can parse any grammar, but slow.</dd>
<dt>bottom up</dt><dd>build parse tree from bottom to top</dd>
<dt>top down</dt><dd>build parse tree from top to bottom</dd>
</dl>

<p>
There are many different methods of each top-down and bottom-up
parsers. The most efficient top-down and bottom-up methods work only
for subclasses of grammars. Some important subclasses is LL and LR
grammar.
</p>

<dl class="org-dl">
<dt>LL grammar</dt><dd>often used by hand-implemented parser</dd>
<dt>LR grammar</dt><dd>accept more grammars, but usually construct by tools</dd>
</dl>

<p>
Some terms:
</p>
<dl class="org-dl">
<dt>parse tree</dt><dd>a graphical representation of a derivation that
filters out the order in which productions are applied
to replace non-terminals.</dd>
</dl>

<p>
Of course, regular expression is a subset of context free grammar.
</p>

<p>
About how to divide lexer rules and parser rules: use regular
expression.
</p>
<ul class="org-ul">
<li>Regular expression is most useful for describing structure of
constructs, such as ID and keywords.</li>
<li>Grammar is most useful for describing nested structures such as
parentheses, begin-end, if-then-else.</li>
</ul>
</div>

<div id="outline-container-orgec22bcb" class="outline-3">
<h3 id="orgec22bcb"><span class="section-number-3">3.1</span> AST</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>In Syntax Tree, interior nodes represent programming constructs.</li>
<li>In parse tree, interior nodes represent non-terminals</li>
<li>many non-terminals of a grammar represent programming constructs,
but others are helpers of one sort of another, such as term, factors.</li>
<li>In syntax tree, these helpers typically are not needed and hence dropped.</li>
</ul>

<p>
To conclude:
</p>
<dl class="org-dl">
<dt>concrete syntax tree</dt><dd>the parse tree</dd>
<dt>concrete syntax</dt><dd>the underlying grammar of a parse tree</dd>
</dl>

<p>
Some new understanding of them (quotes from dragon book):
</p>
<dl class="org-dl">
<dt>CST</dt><dd>A parse tree pictorially shows how the start symbol of a
grammar derives a string in the language.</dd>
<dt>AST</dt><dd>Abstract syntax trees, or simply syntax trees, differ from
parse trees because superficial distinctions of form,
unimportant for translation, do not appear in syntax trees.</dd>
</dl>

<p>
That is to say, CST exactly reflect the grammar, and AST removes a lot
of things but keep the structure.  This includes:
</p>
<ul class="org-ul">
<li>remove non-value-carrying leaves</li>
<li>remove unary productions</li>
<li>compress spines caused by left or right recursive grammar rules into
explicit list nodes.</li>
</ul>

<p>
The implementation of AST is different for different parser designers. For example as the Clang fold said<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>:
</p>

<blockquote>
<p>
Clang’s AST is different from ASTs produced by some other compilers in
that it closely resembles both the written C++ code and the C++
standard. For example, parenthesis expressions and compile time
constants are available in an unreduced form in the AST. This makes
Clang’s AST a good fit for refactoring tools.
</p>
</blockquote>

<pre class="example">
var a = 2,
    b = (a + 2) * 3;
</pre>

<p>
Here, the ( ) around a + 2 is not represented in the AST, because the
structure of the tree, combined with operator precedence rules,
absolutely implies that it must exist, and moreover a + 2 * 3 would
have been a different tree structure. <sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> <sup>, </sup><sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>
</p>

<p>
Estools <sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup> is a good collection of repos that have many
interesting discussion threads about AST and CST.
</p>

<p>
Also, a post from semantic design <sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>, mentioned: 
</p>

<blockquote>
<p>
Typical parser generators force the grammar engineer to specify not
only the grammar, but also to explicitly specify how to procedurally
build the AST as well.
</p>
</blockquote>

<blockquote>
<p>
In contrast, DMS automatically builds a syntax tree, either a concrete
tree ("CST", mainly for debugging, containing all the language
tokens), or what amounts to an AST (for production, in which non-value
carrying terminals are eliminated, useless unary productions are
removed, and lists are formed).
</p>
</blockquote>

<p>
A very good comparison on a lecture note <sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup>.
</p>
</div>
</div>
<div id="outline-container-org811f2f7" class="outline-3">
<h3 id="org811f2f7"><span class="section-number-3">3.2</span> <span class="todo TODO">TODO</span> Write/Fix the grammar</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org0bbe0ad" class="outline-4">
<h4 id="org0bbe0ad"><span class="section-number-4">3.2.1</span> <span class="todo TODO">TODO</span> Ambiguity</h4>
</div>
<div id="outline-container-org1cdaaba" class="outline-4">
<h4 id="org1cdaaba"><span class="section-number-4">3.2.2</span> Left Recursion</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
Top down parser cannot handle left recursion.
</p>

<p>
The grammar
</p>
<pre class="example">
A ::= A alpha | beta
</pre>

<p>
Can be rewritten as:
</p>
<pre class="example">
A ::= beta R
R ::= alpha | epsilon
</pre>
</div>
</div>

<div id="outline-container-org6a50ab3" class="outline-4">
<h4 id="org6a50ab3"><span class="section-number-4">3.2.3</span> Left Factoring</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
a technique to rewrite production rule to achieve the effect that we
wait until enough input has been seen to make decision. It makes
grammar more suitable for predictive or top-down parsing.
</p>
</div>
</div>
</div>


<div id="outline-container-orgb29a3d9" class="outline-3">
<h3 id="orgb29a3d9"><span class="section-number-3">3.3</span> Top Down Parsing</h3>
<div class="outline-text-3" id="text-3-3">
<dl class="org-dl">
<dt>Recusrive descent parsing</dt><dd><ul class="org-ul">
<li>general form of top-down parsing</li>
<li>may require backtracking</li>
</ul></dd>
<dt>Predictive parsing</dt><dd><ul class="org-ul">
<li>a special case of recursive-descent parsing</li>
<li>do not require backtracking</li>
<li>By look ahead fixed number (usually 1) of tokens</li>
</ul></dd>
<dt>LL(k)</dt><dd>A class of grammar, for which we can construct a predictive
parser by looking k symbols ahead.</dd>
</dl>

<p>
The general recursive descent parsing problem is:
</p>

<pre class="example">
void A() {
  choose an A-production
  for (i = 1 to k) {
    if (xi is nonterminal) call X();
    else if (xi = input symbol) advance_to_next_symbol();
    else error();
  }
}
</pre>

<p>
This is non-deterministic since it begins with choose a production. To
augment backtracking to the algorithm, we need:
</p>
<ul class="org-ul">
<li>try different productions</li>
<li>at error, return to the line of choose production</li>
<li>we need a local variable to store where is the input symbol when
choosing production.</li>
</ul>

<p>
Left recursive grammar can cause a recursive-descent parser (even the
one with backtracking) into an infinite-loop. Because it try to expand
A without consuming any input.
</p>
</div>

<div id="outline-container-org2a1eb40" class="outline-4">
<h4 id="org2a1eb40"><span class="section-number-4">3.3.1</span> <span class="todo TODO">TODO</span> LL(1)</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
What's the LL?
</p>
<dl class="org-dl">
<dt>L</dt><dd>Scanning input from Left to right</dd>
<dt>L</dt><dd>producing Leftmost derivation</dd>
<dt>1</dt><dd>lookahead 1 symbol</dd>
</dl>

<p>
It is rich enough to cover most programming constructs. However,
left-recursive and ambiguous can not.
</p>

<p>
The parser will construct a predictive parsing table.  To solve LL(1),
we use <i>non-recursive predictive parsing</i>.  Do not need recursive call
(really??), because it constructs a parsing table. It is table-driven.
</p>

<ul class="org-ul">
<li>algorithm 1: construct predictive parsing table</li>
<li>algorithm 2: table driven predictive parsing</li>
</ul>
</div>
</div>

<div id="outline-container-org9888422" class="outline-4">
<h4 id="org9888422"><span class="section-number-4">3.3.2</span> Recursive Decent Parser v.s. LR Parser generator</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
Well, In a word, this is actually important. See what the clang guys say <sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup>
</p>

<blockquote>
<p>
Clang is the "C Language Family Front-end", which means we intend to
support the most popular members of the C family. We are convinced
that the right parsing technology for this class of languages is a
hand-built recursive-descent parser. Because it is plain C++ code,
recursive descent makes it very easy for new developers to understand
the code, it easily supports ad-hoc rules and other strange hacks
required by C/C++, and makes it straight-forward to implement
excellent diagnostics and error recovery.
</p>
</blockquote>
</div>
</div>
</div>



<div id="outline-container-org8da52da" class="outline-3">
<h3 id="org8da52da"><span class="section-number-3">3.4</span> Bottom Up Parsing</h3>
<div class="outline-text-3" id="text-3-4">
<dl class="org-dl">
<dt>shift-reduce parsing</dt><dd>a general style of bottom-up parsing</dd>
<dt>LR grammar</dt><dd>the largest class of grammars for which shift-reduce
parsers can be built</dd>
</dl>

<p>
The bottom up parsing can think as reducing a string to the start
symbol. At each reduction step, a substring is replaced by a
non-terminal. Thus the key decisions are:
</p>
<ul class="org-ul">
<li>when to reduce</li>
<li>what production to apply</li>
</ul>
</div>

<div id="outline-container-org824c2e3" class="outline-4">
<h4 id="org824c2e3"><span class="section-number-4">3.4.1</span> shift-reduce parsing</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
Think about a stack holding current string, and the input holding the rest input tokens.
</p>
<dl class="org-dl">
<dt>shift</dt><dd>move from input to stack</dd>
<dt>reduce</dt><dd>replace a substring at the top of the stack</dd>
</dl>

<p>
The conflict here:
</p>
<dl class="org-dl">
<dt>shift/reduce conflict</dt><dd>don't know to shift or reduce.</dd>
<dt>reduce/reduce conflict</dt><dd>don't know which production rule to use</dd>
</dl>

<p>
Grammar that contains these conflicts are non-LR grammar.
</p>
</div>

<div id="outline-container-orgfad3cc0" class="outline-5">
<h5 id="orgfad3cc0"><span class="section-number-5">3.4.1.1</span> The dangling else problem</h5>
<div class="outline-text-5" id="text-3-4-1-1">
<p>
This is a canonical example for shift/reduce conflict. The C grammar
for selection-statement is like this. <a href="https://www.gnu.org/software/bison/manual/html_node/Shift_002fReduce.html">The bison way</a> to deal with it is
to "choose shift, unless otherwise directed by operator precedence
declarations". This naturally groups the else with nearest if. But
bison will <i>STILL</i> report 2 shift/reduce conflicts. You can suppress
this warning by use <code>%expect 2</code>, but this is not recommended.
</p>

<p>
More elegant way is to use precedence or associativity. To do this,
either make <code>else</code> to have higher precedence than <code>then</code>, <i>OR</i> make them
equal precedence, but give both <code>then</code> and <code>else</code> right
associativity. In the case there is no <code>then</code> keyword, like C, the
terminal is <code>r-paren</code>.
</p>

<p>
Below is the code giving <code>else</code> higher precedence. Note that <code>%token</code>
only declares the token exists, no precedence. <code>%precedence</code> does both
declaring and precedence assigning. It follows the same rule: the
lower the position, the higher the precedence.
</p>
<pre class="example">
%precedence "then"
%precedence "else"
</pre>

<p>
Give right associativity:
</p>
<pre class="example">
%right "then" "else"
</pre>



<p>
One more way to resolve this is to slightly modify the grammar:
</p>
<pre class="example">
statement = ...
   | selection-statement

statement-with-else = ...
   | selection-statement-with-else

selection-statement = ...
   | IF ( expression ) statement
   | IF ( expression ) statement-with-else ELSE statement

selection-statement-with-else = ...
   | IF ( expression ) statement-with-else ELSE statement-with-else
</pre>
</div>
</div>
</div>


<div id="outline-container-orgdc01e0d" class="outline-4">
<h4 id="orgdc01e0d"><span class="section-number-4">3.4.2</span> LR(k) Parsing</h4>
<div class="outline-text-4" id="text-3-4-2">
<dl class="org-dl">
<dt>L</dt><dd>left to right scanning</dd>
<dt>R</dt><dd>producing rightmost derivation</dd>
<dt>k</dt><dd>number of lookahead (when omitted, assume 1)</dd>
</dl>

<p>
LR parsers are table driven, like the non-recursive LL parsers.
</p>
<dl class="org-dl">
<dt>LR Grammar</dt><dd>a grammar for which we can construct a LR parser for it.</dd>
</dl>

<p>
Over LL parsing, it is better because:
</p>
<ul class="org-ul">
<li>LR parsers can be constructed to recognize virtually all programming
language constructs for which context-free grammars can be written.</li>
<li>the most general non-backtracking shift-reduce parsing, and can be
implemented as efficient as others</li>
<li>can detect syntactic error as soon as it is possible to do so on a
left-to-right scan of input</li>
<li>LR grammar is super set of LL grammar</li>
</ul>

<p>
The drawback: hard to construct by hand.
</p>
</div>

<div id="outline-container-org1a11429" class="outline-5">
<h5 id="org1a11429"><span class="section-number-5">3.4.2.1</span> Simple LR Parsing (SLR)</h5>
<div class="outline-text-5" id="text-3-4-2-1">
<dl class="org-dl">
<dt>LR(0) Item</dt><dd>each production rule will be written in a dot format:
put one dot somewhere in the rule. This will result in
many items.</dd>
<dt>Set of LR(0) Items</dt><dd>a set of the items</dd>
<dt>Canonical LR(0) collection</dt><dd>a collection of <i>sets</i> of LR(0) Items,
that is typically used (others are useless).</dd>
</dl>

<p>
To construct Canonical LR(0) collection, introduce the CLOSURE and
GOTO functions:
</p>
<dl class="org-dl">
<dt>CLOSURE(I)</dt><dd>where I is a set of items, if \(A \rightarrow \alpha
                \cdot B \beta\) is in CLOSURE(I), and \(B \rightarrow
                \gamma\), \(B \rightarrow \cdot \gamma\) is in the set.</dd>
<dt>GOTO(I,X)</dt><dd>where I is a set of items, X is a grammar
symbol. Produce a closure, if \(A \rightarrow \alpha
               \cdot X \beta\), \(A \rightarrow \alpha X \cdot \beta\) is
in GOTO(T,X).</dd>
</dl>

<p>
Now the algorithm to construct canonical LR(0) items
</p>
<pre class="example">
void items(G') {
  C=CLOSURE({S-&gt;.S'});
  repeat until no new {
    for (each set I in C) {
      for (each grammar symbol X) {
        add GOTO(I,X) to C}}}}
</pre>

<p>
Now we can define LR(0) Automata:
</p>
<dl class="org-dl">
<dt>state</dt><dd>the canonical LR(0) collection</dd>
<dt>transition</dt><dd>GOTO function</dd>
</dl>

<p>
Set up for parsing: Now we have the components:
</p>
<dl class="org-dl">
<dt>input</dt><dd>the remaining input</dd>
<dt>stack</dt><dd>the stack holds the states. Note that each state
corresponding to exactly one symbol (yes, but why??). So we
can always convert to the symbols from states.</dd>
<dt>parsing table</dt><dd>contains two parts: ACTION and GOTO
<dl class="org-dl">
<dt>ACTION(i,a)</dt><dd>state i, next terminal a. The result is
<dl class="org-dl">
<dt>shift j</dt><dd>shift the terminal and go to state j</dd>
<dt>reduce \(A \rightarrow \beta\)</dt><dd>reduce &beta; (on the top of stack)
to A</dd>
<dt>accept</dt><dd></dd>

<dt>error</dt><dd></dd>
</dl></dd>
<dt>GOTO(i, A)=j</dt><dd>map state i and non-terminal A to state j</dd>
</dl></dd>
</dl>

<p>
Parsing algorithm:
</p>
<dl class="org-dl">
<dt>action = shift s</dt><dd>do it</dd>
<dt>action = reduce \(A \rightarrow \beta\)</dt><dd>do the reduction by popping
out \(|\beta|\) states, and then push state GOTO(stack.top, A).</dd>
</dl>

<p>
The algorithm can be written as:
</p>

<pre class="example">
while (true) {
  s = stack.top;
  a = next input;
  if (ACTION(s,a) = shift t) {
    stack.push(t)
    advance(a)
  } else if (ACTION(s,a) = reduce A to beta) {
    stack.pop(len(beta));
    t = stack.top
    stack.push(GOTO(t,A))
    output production A-&gt;beta
  } else if (ACTION=accept | error) {}
}
</pre>

<p>
Algorithm for construct SLR parsing table:
</p>
<ol class="org-ol">
<li>get canonical LR(0) collection</li>
<li>ACTION(i,a) = 
<dl class="org-dl">
<dt>shift j</dt><dd>if \(A \rightarrow \alpha \cdot a \beta\) is in I<sub>i</sub>, and
GOTO(I<sub>i,a</sub>)=I<sub>j</sub></dd>
<dt>reduce A to &alpha;</dt><dd>if \(A \rightarrow \alpha \cdot\) in I<sub>i</sub> and a
in FOLLOW(A).</dd>
<dt>accept</dt><dd>if \(S' \rightarrow S \cdot\) is in I<sub>i</sub> and a = $</dd>
</dl></li>
</ol>
</div>
</div>

<div id="outline-container-orgb80a362" class="outline-5">
<h5 id="orgb80a362"><span class="section-number-5">3.4.2.2</span> LR(1)</h5>
<div class="outline-text-5" id="text-3-4-2-2">
<p>
So we now allow lookahead. By this we can handle more grammars than
LR(0). There're two methods:
</p>
<dl class="org-dl">
<dt>canonical-LR (LR)</dt><dd>construct based on LR(1) items, a much larger
set than LR(0) items. The parsing table is much bigger, so not
good in practice.</dd>
<dt>lookahead-LR (LALR)</dt><dd>based on LR(0) (??? should be LR(1) here?)
sets of items, but has many fewer states than LR(1) items. The
parsing table is no bigger than SLR tables. The modern choice.</dd>
</dl>
</div>
</div>
</div>
</div>
</div>



<div id="outline-container-orgd6eef91" class="outline-2">
<h2 id="orgd6eef91"><span class="section-number-2">4</span> Syntax Directed Translation</h2>
<div class="outline-text-2" id="text-4">
<dl class="org-dl">
<dt>Syntax Directed Definition (SDD)</dt><dd>a context-free grammar together
with attributes and rules. Attributes are associated with grammar
symbols, and rules are associated with productions.
<dl class="org-dl">
<dt>synthesized attribute</dt><dd>for a non-terminal A at a parse tree node
N is defined by a semantic rule associated with the production
at N. This includes N and its children.</dd>
<dt>inherited attribute</dt><dd>for a non-terminal B at a parse tree node N
is defined by a semantic rule associated with the production at
the parent of N. This includes N's parent, N, and N's siblings.</dd>
<dt>S-attributed</dt><dd>an SDD is S-attributed if every attribute is
synthesized. We can evaluate it in any bottom-up
fashion, e.g. a post order traversal.</dd>
<dt>L-attributed</dt><dd>an SDD is L-attributed if each attribute is either
synthesized or, inherited but only depends on the
value of the parent and the symbols to the left of
it on its siblings. This rule says the evaluation
should go from left to right, but not right to
left.</dd>
</dl></dd>
<dt>Syntax Directed Translation Scheme (SDT)</dt><dd>a context free grammar
with program fragment embedded within production bodies. (This is
the typical grammar file for a parser generator like ANTLR!)</dd>
</dl>

<p>
Any SDT can be implemented by
</p>
<ol class="org-ol">
<li>build the parse tree</li>
<li>perform the actions in a left-to-right depth-first order, that is
during a pre-order traversal.</li>
</ol>

<p>
Typically SDT's are implemented during parsing, without building a
parse tree. We focus on two important classes of SDD:
</p>
<ol class="org-ol">
<li>grammar is LR-parsable and SDD is S-attributed, using Postfix
Translation Scheme.  This scheme essentially do a bottom-up parsing
and evaluate the attributes in place (right at ends of
productions).</li>
<li>grammar is LL-parsable and SDD is L-attributed. The L-attributed
SDD is more general, but we must assume the grammar is
LL-parsable. Otherwise it is "impossible to perform translation in
connection with either an LL or an LR parser". The solution is to
evaluate in a pre-order traversal of the tree.</li>
</ol>
</div>
</div>

<div id="outline-container-org2ee913b" class="outline-2">
<h2 id="org2ee913b"><span class="section-number-2">5</span> FIRST and FOLLOW</h2>
<div class="outline-text-2" id="text-5">
<p>
The construction of <i>both</i> top-down and bottom-up parsers needs these
two functions.
</p>

<dl class="org-dl">
<dt>FIRST(\(\alpha\))</dt><dd>\(\alpha\) is a string of grammar symbols. The set
of terminals that \(\alpha\) can begin with. E.g <code>A::=cB</code>, <code>FIRST(A)=c</code></dd>
<dt>FOLLOW(A)</dt><dd>non-terminal A, to be the set of terminals that can
appear immediately to the right of A.</dd>
</dl>
</div>
</div>


<div id="outline-container-orgf0b5063" class="outline-2">
<h2 id="orgf0b5063"><span class="section-number-2">6</span> Error Recovery</h2>
<div class="outline-text-2" id="text-6">
<dl class="org-dl">
<dt>panic-mode</dt><dd>discard input symbols until <i>synchronizing tokens</i> are
found. This is typically delimiters, such as semicolon
or braces.</dd>
<dt>phrase-level</dt><dd>perform local correction, such as remove extra
semicolon, replace coma with semicolon. This is not
good.</dd>
<dt>error-production</dt><dd>use common errors</dd>
<dt>global-correction</dt><dd>there are some algorithms to choose a minimal
sequence of changes to obtain a globally least cost
correction. (What are they??) [Dragon P196]</dd>
</dl>
</div>
</div>



<div id="outline-container-orgd9f2d57" class="outline-2">
<h2 id="orgd9f2d57"><span class="section-number-2">7</span> Tools</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org01b5a32" class="outline-3">
<h3 id="org01b5a32"><span class="section-number-3">7.1</span> Elsa and Elkhound</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li><a href="http://www.scottmcpeak.com/elkhound/">http://www.scottmcpeak.com/elkhound/</a></li>
</ul>

<p>
Elkhound is an ancient parser generator, and Elsa is the C++ parser built upon it.
It is clean docs, maybe clean code, worth to check out.
</p>

<p>
It implements the Generalized LR (GLR) parsing, which works with any context-free grammars.
LR parsers (like bison) requires the grammar to be LALR(1).
</p>

<ul class="org-ul">
<li>GLR: <a href="https://en.wikipedia.org/wiki/GLR_parser">https://en.wikipedia.org/wiki/GLR_parser</a></li>
</ul>


<p>
Parsing with arbitrary context-free grammars has two key advantages:
(1) unbounded lookahead, and (2) support for ambiguous grammars. Both
of them are achieved by allowing multiple potential parses to coexist
for as long as necessary.
</p>

<p>
The downside, since it is more general, is slower performance.
</p>
</div>
</div>

<div id="outline-container-org4594cb3" class="outline-3">
<h3 id="org4594cb3"><span class="section-number-3">7.2</span> Semantic Design Inc</h3>
<div class="outline-text-3" id="text-7-2">
<p>
A Commercial Parser Front end:
</p>
<ul class="org-ul">
<li><a href="http://www.semanticdesigns.com/Products/FrontEnds/CppFrontEnd.html">http://www.semanticdesigns.com/Products/FrontEnds/CppFrontEnd.html</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc447206" class="outline-3">
<h3 id="orgc447206"><span class="section-number-3">7.3</span> Parser generator</h3>
<div class="outline-text-3" id="text-7-3">
<dl class="org-dl">
<dt>yacc &amp; lex</dt><dd>generate LALR</dd>
<dt>bison &amp; flex</dt><dd>open source for yacc, so also LALR</dd>
<dt>antlr</dt><dd>top down parser generator, generates recursive-descent parser</dd>
</dl>
</div>
</div>
</div>



<div id="outline-container-org31de83c" class="outline-2">
<h2 id="org31de83c"><span class="section-number-2">8</span> Samples</h2>
<div class="outline-text-2" id="text-8">
<div class="org-src-container">
<pre class="src src-clang">int main() {
  int a,b;
  b=a+b;
  int* arp[5];
  b=(a+b)*a;
}
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://github.com/estree/estree/issues/41">https://github.com/estree/estree/issues/41</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
<a href="https://github.com/getify/concrete-syntax-tree">https://github.com/getify/concrete-syntax-tree</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
<a href="https://github.com/estools">https://github.com/estools</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
<a href="http://www.semdesigns.com/Products/DMS/LifeAfterParsing.html?Home=DMSToolkit">http://www.semdesigns.com/Products/DMS/LifeAfterParsing.html?Home=DMSToolkit</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
<a href="http://www.cse.chalmers.se/edu/year/2011/course/TIN321/lectures/proglang-02.html">http://www.cse.chalmers.se/edu/year/2011/course/TIN321/lectures/proglang-02.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
<a href="http://clang.llvm.org/features.html">http://clang.llvm.org/features.html</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2017-12-14 Thu 12:25</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
