<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-10-26 Thu 16:40 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Compiler</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="assets/hebi.css" /><link rel="stylesheet" type="text/css" href="assets/test.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Compiler</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org03dfd1b">1. Parser</a>
<ul>
<li><a href="#orgd5d9180">1.1. AST</a></li>
<li><a href="#org60e5a32">1.2. <span class="todo TODO">TODO</span> Write/Fix the grammar</a>
<ul>
<li><a href="#org080b1f4">1.2.1. <span class="todo TODO">TODO</span> Ambiguity</a></li>
<li><a href="#org3867ac0">1.2.2. Left Recursion</a></li>
<li><a href="#orga7e69e7">1.2.3. Left Factoring</a></li>
</ul>
</li>
<li><a href="#org4592555">1.3. Top Down Parsing</a>
<ul>
<li><a href="#org9d7be72">1.3.1. <span class="todo TODO">TODO</span> LL(1)</a></li>
<li><a href="#org67cb96e">1.3.2. Recursive Decent Parser v.s. LR Parser generator</a></li>
</ul>
</li>
<li><a href="#orga5c18e9">1.4. Bottom Up Parsing</a>
<ul>
<li><a href="#org1d1cdb6">1.4.1. shift-reduce parsing</a></li>
<li><a href="#orgb9a184b">1.4.2. LR(k) Parsing</a>
<ul>
<li><a href="#orga2b1eb5">1.4.2.1. Simple LR Parsing (SLR)</a></li>
<li><a href="#orgbdbf3b0">1.4.2.2. LR(1)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org99b9827">2. Syntax Directed Translation</a></li>
<li><a href="#orgebfb9cf">3. FIRST and FOLLOW</a></li>
<li><a href="#orgfac9520">4. Error Recovery</a></li>
<li><a href="#org0754f3c">5. Tools</a>
<ul>
<li><a href="#orge46ba33">5.1. Elsa and Elkhound</a></li>
<li><a href="#org7f7c321">5.2. Semantic Design Inc</a></li>
<li><a href="#org7a8305b">5.3. Parser generator</a></li>
</ul>
</li>
<li><a href="#org62890e6">6. Samples</a></li>
</ul>
</div>
</div>
<p>
This file describe the general concept of a compiler. I'm going to
relearn it in the hard way.
</p>


<div id="outline-container-org03dfd1b" class="outline-2">
<h2 id="org03dfd1b"><span class="section-number-2">1</span> Parser</h2>
<div class="outline-text-2" id="text-1">
<p>
Three category of parsers:
</p>
<dl class="org-dl">
<dt>universal</dt><dd>Cocke–Younger–Kasami algorithm (CYK) and the Earley
parser. They can parse any grammar, but slow.</dd>
<dt>bottom up</dt><dd>build parse tree from bottom to top</dd>
<dt>top down</dt><dd>build parse tree from top to bottom</dd>
</dl>

<p>
There are many different methods of each top-down and bottom-up
parsers. The most efficient top-down and bottom-up methods work only
for subclasses of grammars. Some important subclasses is LL and LR
grammar.
</p>

<dl class="org-dl">
<dt>LL grammar</dt><dd>often used by hand-implemented parser</dd>
<dt>LR grammar</dt><dd>accept more grammars, but usually construct by tools</dd>
</dl>

<p>
Some terms:
</p>
<dl class="org-dl">
<dt>parse tree</dt><dd>a graphical representation of a derivation that
filters out the order in which productions are applied
to replace non-terminals.</dd>
</dl>

<p>
Of course, regular expression is a subset of context free grammar.
</p>

<p>
About how to divide lexer rules and parser rules: use regular
expression.
</p>
<ul class="org-ul">
<li>Regular expression is most useful for describing structure of
constructs, such as ID and keywords.</li>
<li>Grammar is most useful for describing nested structures such as
parentheses, begin-end, if-then-else.</li>
</ul>
</div>

<div id="outline-container-orgd5d9180" class="outline-3">
<h3 id="orgd5d9180"><span class="section-number-3">1.1</span> AST</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>In Syntax Tree, interior nodes represent programming constructs.</li>
<li>In parse tree, interior nodes represent non-terminals</li>
<li>many non-terminals of a grammar represent programming constructs,
but others are helpers of one sort of another, such as term, factors.</li>
<li>In syntax tree, these helpers typically are not needed and hence dropped.</li>
</ul>

<p>
To conclude:
</p>
<dl class="org-dl">
<dt>concrete syntax tree</dt><dd>the parse tree</dd>
<dt>concrete syntax</dt><dd>the underlying grammar of a parse tree</dd>
</dl>

<p>
Some new understanding of them (quotes from dragon book):
</p>
<dl class="org-dl">
<dt>CST</dt><dd>A parse tree pictorially shows how the start symbol of a
grammar derives a string in the language.</dd>
<dt>AST</dt><dd>Abstract syntax trees, or simply syntax trees, differ from
parse trees because superficial distinctions of form,
unimportant for translation, do not appear in syntax trees.</dd>
</dl>

<p>
That is to say, CST exactly reflect the grammar, and AST removes a lot
of things but keep the structure.  This includes:
</p>
<ul class="org-ul">
<li>remove non-value-carrying leaves</li>
<li>remove unary productions</li>
<li>compress spines caused by left or right recursive grammar rules into
explicit list nodes.</li>
</ul>

<p>
The implementation of AST is different for different parser designers. For example as the Clang fold said<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>:
</p>

<blockquote>
<p>
Clang’s AST is different from ASTs produced by some other compilers in
that it closely resembles both the written C++ code and the C++
standard. For example, parenthesis expressions and compile time
constants are available in an unreduced form in the AST. This makes
Clang’s AST a good fit for refactoring tools.
</p>
</blockquote>

<pre class="example">
var a = 2,
    b = (a + 2) * 3;
</pre>

<p>
Here, the ( ) around a + 2 is not represented in the AST, because the
structure of the tree, combined with operator precedence rules,
absolutely implies that it must exist, and moreover a + 2 * 3 would
have been a different tree structure. <sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> <sup>, </sup><sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>
</p>

<p>
Estools <sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup> is a good collection of repos that have many
interesting discussion threads about AST and CST.
</p>

<p>
Also, a post from semantic design <sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>, mentioned: 
</p>

<blockquote>
<p>
Typical parser generators force the grammar engineer to specify not
only the grammar, but also to explicitly specify how to procedurally
build the AST as well.
</p>
</blockquote>

<blockquote>
<p>
In contrast, DMS automatically builds a syntax tree, either a concrete
tree ("CST", mainly for debugging, containing all the language
tokens), or what amounts to an AST (for production, in which non-value
carrying terminals are eliminated, useless unary productions are
removed, and lists are formed).
</p>
</blockquote>

<p>
A very good comparison on a lecture note <sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup>.
</p>
</div>
</div>
<div id="outline-container-org60e5a32" class="outline-3">
<h3 id="org60e5a32"><span class="section-number-3">1.2</span> <span class="todo TODO">TODO</span> Write/Fix the grammar</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org080b1f4" class="outline-4">
<h4 id="org080b1f4"><span class="section-number-4">1.2.1</span> <span class="todo TODO">TODO</span> Ambiguity</h4>
</div>
<div id="outline-container-org3867ac0" class="outline-4">
<h4 id="org3867ac0"><span class="section-number-4">1.2.2</span> Left Recursion</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Top down parser cannot handle left recursion.
</p>

<p>
The grammar
</p>
<pre class="example">
A ::= A alpha | beta
</pre>

<p>
Can be rewritten as:
</p>
<pre class="example">
A ::= beta R
R ::= alpha | epsilon
</pre>
</div>
</div>

<div id="outline-container-orga7e69e7" class="outline-4">
<h4 id="orga7e69e7"><span class="section-number-4">1.2.3</span> Left Factoring</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
a technique to rewrite production rule to achieve the effect that we
wait until enough input has been seen to make decision. It makes
grammar more suitable for predictive or top-down parsing.
</p>
</div>
</div>
</div>


<div id="outline-container-org4592555" class="outline-3">
<h3 id="org4592555"><span class="section-number-3">1.3</span> Top Down Parsing</h3>
<div class="outline-text-3" id="text-1-3">
<dl class="org-dl">
<dt>Recusrive descent parsing</dt><dd><ul class="org-ul">
<li>general form of top-down parsing</li>
<li>may require backtracking</li>
</ul></dd>
<dt>Predictive parsing</dt><dd><ul class="org-ul">
<li>a special case of recursive-descent parsing</li>
<li>do not require backtracking</li>
<li>By look ahead fixed number (usually 1) of tokens</li>
</ul></dd>
<dt>LL(k)</dt><dd>A class of grammar, for which we can construct a predictive
parser by looking k symbols ahead.</dd>
</dl>

<p>
The general recursive descent parsing problem is:
</p>

<pre class="example">
void A() {
  choose an A-production
  for (i = 1 to k) {
    if (xi is nonterminal) call X();
    else if (xi = input symbol) advance_to_next_symbol();
    else error();
  }
}
</pre>

<p>
This is non-deterministic since it begins with choose a production. To
augment backtracking to the algorithm, we need:
</p>
<ul class="org-ul">
<li>try different productions</li>
<li>at error, return to the line of choose production</li>
<li>we need a local variable to store where is the input symbol when
choosing production.</li>
</ul>

<p>
Left recursive grammar can cause a recursive-descent parser (even the
one with backtracking) into an infinite-loop. Because it try to expand
A without consuming any input.
</p>
</div>

<div id="outline-container-org9d7be72" class="outline-4">
<h4 id="org9d7be72"><span class="section-number-4">1.3.1</span> <span class="todo TODO">TODO</span> LL(1)</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
What's the LL?
</p>
<dl class="org-dl">
<dt>L</dt><dd>Scanning input from Left to right</dd>
<dt>L</dt><dd>producing Leftmost derivation</dd>
<dt>1</dt><dd>lookahead 1 symbol</dd>
</dl>

<p>
It is rich enough to cover most programming constructs. However,
left-recursive and ambiguous can not.
</p>

<p>
The parser will construct a predictive parsing table.  To solve LL(1),
we use <i>non-recursive predictive parsing</i>.  Do not need recursive call
(really??), because it constructs a parsing table. It is table-driven.
</p>

<ul class="org-ul">
<li>algorithm 1: construct predictive parsing table</li>
<li>algorithm 2: table driven predictive parsing</li>
</ul>
</div>
</div>

<div id="outline-container-org67cb96e" class="outline-4">
<h4 id="org67cb96e"><span class="section-number-4">1.3.2</span> Recursive Decent Parser v.s. LR Parser generator</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Well, In a word, this is actually important. See what the clang guys say <sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup>
</p>

<blockquote>
<p>
Clang is the "C Language Family Front-end", which means we intend to
support the most popular members of the C family. We are convinced
that the right parsing technology for this class of languages is a
hand-built recursive-descent parser. Because it is plain C++ code,
recursive descent makes it very easy for new developers to understand
the code, it easily supports ad-hoc rules and other strange hacks
required by C/C++, and makes it straight-forward to implement
excellent diagnostics and error recovery.
</p>
</blockquote>
</div>
</div>
</div>



<div id="outline-container-orga5c18e9" class="outline-3">
<h3 id="orga5c18e9"><span class="section-number-3">1.4</span> Bottom Up Parsing</h3>
<div class="outline-text-3" id="text-1-4">
<dl class="org-dl">
<dt>shift-reduce parsing</dt><dd>a general style of bottom-up parsing</dd>
<dt>LR grammar</dt><dd>the largest class of grammars for which shift-reduce
parsers can be built</dd>
</dl>

<p>
The bottom up parsing can think as reducing a string to the start
symbol. At each reduction step, a substring is replaced by a
non-terminal. Thus the key decisions are:
</p>
<ul class="org-ul">
<li>when to reduce</li>
<li>what production to apply</li>
</ul>
</div>

<div id="outline-container-org1d1cdb6" class="outline-4">
<h4 id="org1d1cdb6"><span class="section-number-4">1.4.1</span> shift-reduce parsing</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Think about a stack holding current string, and the input holding the rest input tokens.
</p>
<dl class="org-dl">
<dt>shift</dt><dd>move from input to stack</dd>
<dt>reduce</dt><dd>replace a substring at the top of the stack</dd>
</dl>

<p>
The conflict here:
</p>
<dl class="org-dl">
<dt>shift/reduce conflict</dt><dd>don't know to shift or reduce.</dd>
<dt>reduce/reduce conflict</dt><dd>don't know which production rule to use</dd>
</dl>

<p>
Grammar that contains these conflicts are non-LR grammar.
</p>
</div>
</div>

<div id="outline-container-orgb9a184b" class="outline-4">
<h4 id="orgb9a184b"><span class="section-number-4">1.4.2</span> LR(k) Parsing</h4>
<div class="outline-text-4" id="text-1-4-2">
<dl class="org-dl">
<dt>L</dt><dd>left to right scanning</dd>
<dt>R</dt><dd>producing rightmost derivation</dd>
<dt>k</dt><dd>number of lookahead (when omitted, assume 1)</dd>
</dl>

<p>
LR parsers are table driven, like the non-recursive LL parsers.
</p>
<dl class="org-dl">
<dt>LR Grammar</dt><dd>a grammar for which we can construct a LR parser for it.</dd>
</dl>

<p>
Over LL parsing, it is better because:
</p>
<ul class="org-ul">
<li>LR parsers can be constructed to recognize virtually all programming
language constructs for which context-free grammars can be written.</li>
<li>the most general non-backtracking shift-reduce parsing, and can be
implemented as efficient as others</li>
<li>can detect syntactic error as soon as it is possible to do so on a
left-to-right scan of input</li>
<li>LR grammar is super set of LL grammar</li>
</ul>

<p>
The drawback: hard to construct by hand.
</p>
</div>

<div id="outline-container-orga2b1eb5" class="outline-5">
<h5 id="orga2b1eb5"><span class="section-number-5">1.4.2.1</span> Simple LR Parsing (SLR)</h5>
<div class="outline-text-5" id="text-1-4-2-1">
<dl class="org-dl">
<dt>LR(0) Item</dt><dd>each production rule will be written in a dot format:
put one dot somewhere in the rule. This will result in
many items.</dd>
<dt>Set of LR(0) Items</dt><dd>a set of the items</dd>
<dt>Canonical LR(0) collection</dt><dd>a collection of <i>sets</i> of LR(0) Items,
that is typically used (others are useless).</dd>
</dl>

<p>
To construct Canonical LR(0) collection, introduce the CLOSURE and
GOTO functions:
</p>
<dl class="org-dl">
<dt>CLOSURE(I)</dt><dd>where I is a set of items, if \(A \rightarrow \alpha
                \cdot B \beta\) is in CLOSURE(I), and \(B \rightarrow
                \gamma\), \(B \rightarrow \cdot \gamma\) is in the set.</dd>
<dt>GOTO(I,X)</dt><dd>where I is a set of items, X is a grammar
symbol. Produce a closure, if \(A \rightarrow \alpha
               \cdot X \beta\), \(A \rightarrow \alpha X \cdot \beta\) is
in GOTO(T,X).</dd>
</dl>

<p>
Now the algorithm to construct canonical LR(0) items
</p>
<pre class="example">
void items(G') {
  C=CLOSURE({S-&gt;.S'});
  repeat until no new {
    for (each set I in C) {
      for (each grammar symbol X) {
        add GOTO(I,X) to C}}}}
</pre>

<p>
Now we can define LR(0) Automata:
</p>
<dl class="org-dl">
<dt>state</dt><dd>the canonical LR(0) collection</dd>
<dt>transition</dt><dd>GOTO function</dd>
</dl>

<p>
Set up for parsing: Now we have the components:
</p>
<dl class="org-dl">
<dt>input</dt><dd>the remaining input</dd>
<dt>stack</dt><dd>the stack holds the states. Note that each state
corresponding to exactly one symbol (yes, but why??). So we
can always convert to the symbols from states.</dd>
<dt>parsing table</dt><dd>contains two parts: ACTION and GOTO
<dl class="org-dl">
<dt>ACTION(i,a)</dt><dd>state i, next terminal a. The result is
<dl class="org-dl">
<dt>shift j</dt><dd>shift the terminal and go to state j</dd>
<dt>reduce \(A \rightarrow \beta\)</dt><dd>reduce &beta; (on the top of stack)
to A</dd>
<dt>accept</dt><dd></dd>

<dt>error</dt><dd></dd>
</dl></dd>
<dt>GOTO(i, A)=j</dt><dd>map state i and non-terminal A to state j</dd>
</dl></dd>
</dl>

<p>
Parsing algorithm:
</p>
<dl class="org-dl">
<dt>action = shift s</dt><dd>do it</dd>
<dt>action = reduce \(A \rightarrow \beta\)</dt><dd>do the reduction by popping
out \(|\beta|\) states, and then push state GOTO(stack.top, A).</dd>
</dl>

<p>
The algorithm can be written as:
</p>

<pre class="example">
while (true) {
  s = stack.top;
  a = next input;
  if (ACTION(s,a) = shift t) {
    stack.push(t)
    advance(a)
  } else if (ACTION(s,a) = reduce A to beta) {
    stack.pop(len(beta));
    t = stack.top
    stack.push(GOTO(t,A))
    output production A-&gt;beta
  } else if (ACTION=accept | error) {}
}
</pre>

<p>
Algorithm for construct SLR parsing table:
</p>
<ol class="org-ol">
<li>get canonical LR(0) collection</li>
<li>ACTION(i,a) = 
<dl class="org-dl">
<dt>shift j</dt><dd>if \(A \rightarrow \alpha \cdot a \beta\) is in I<sub>i</sub>, and
GOTO(I<sub>i,a</sub>)=I<sub>j</sub></dd>
<dt>reduce A to &alpha;</dt><dd>if \(A \rightarrow \alpha \cdot\) in I<sub>i</sub> and a
in FOLLOW(A).</dd>
<dt>accept</dt><dd>if \(S' \rightarrow S \cdot\) is in I<sub>i</sub> and a = $</dd>
</dl></li>
</ol>
</div>
</div>

<div id="outline-container-orgbdbf3b0" class="outline-5">
<h5 id="orgbdbf3b0"><span class="section-number-5">1.4.2.2</span> LR(1)</h5>
<div class="outline-text-5" id="text-1-4-2-2">
<p>
So we now allow lookahead. By this we can handle more grammars than
LR(0). There're two methods:
</p>
<dl class="org-dl">
<dt>canonical-LR (LR)</dt><dd>construct based on LR(1) items, a much larger
set than LR(0) items. The parsing table is much bigger, so not
good in practice.</dd>
<dt>lookahead-LR (LALR)</dt><dd>based on LR(0) (??? should be LR(1) here?)
sets of items, but has many fewer states than LR(1) items. The
parsing table is no bigger than SLR tables. The modern choice.</dd>
</dl>
</div>
</div>
</div>
</div>
</div>



<div id="outline-container-org99b9827" class="outline-2">
<h2 id="org99b9827"><span class="section-number-2">2</span> Syntax Directed Translation</h2>
<div class="outline-text-2" id="text-2">
<dl class="org-dl">
<dt>Syntax Directed Definition (SDD)</dt><dd>a context-free grammar together
with attributes and rules. Attributes are associated with grammar
symbols, and rules are associated with productions.
<dl class="org-dl">
<dt>synthesized attribute</dt><dd>for a non-terminal A at a parse tree node
N is defined by a semantic rule associated with the production
at N. This includes N and its children.</dd>
<dt>inherited attribute</dt><dd>for a non-terminal B at a parse tree node N
is defined by a semantic rule associated with the production at
the parent of N. This includes N's parent, N, and N's siblings.</dd>
<dt>S-attributed</dt><dd>an SDD is S-attributed if every attribute is
synthesized. We can evaluate it in any bottom-up
fashion, e.g. a post order traversal.</dd>
<dt>L-attributed</dt><dd>an SDD is L-attributed if each attribute is either
synthesized or, inherited but only depends on the
value of the parent and the symbols to the left of
it on its siblings. This rule says the evaluation
should go from left to right, but not right to
left.</dd>
</dl></dd>
<dt>Syntax Directed Translation Scheme (SDT)</dt><dd>a context free grammar
with program fragment embedded within production bodies. (This is
the typical grammar file for a parser generator like ANTLR!)</dd>
</dl>

<p>
Any SDT can be implemented by
</p>
<ol class="org-ol">
<li>build the parse tree</li>
<li>perform the actions in a left-to-right depth-first order, that is
during a pre-order traversal.</li>
</ol>

<p>
Typically SDT's are implemented during parsing, without building a
parse tree. We focus on two important classes of SDD:
</p>
<ol class="org-ol">
<li>grammar is LR-parsable and SDD is S-attributed, using Postfix
Translation Scheme.  This scheme essentially do a bottom-up parsing
and evaluate the attributes in place (right at ends of
productions).</li>
<li>grammar is LL-parsable and SDD is L-attributed. The L-attributed
SDD is more general, but we must assume the grammar is
LL-parsable. Otherwise it is "impossible to perform translation in
connection with either an LL or an LR parser". The solution is to
evaluate in a pre-order traversal of the tree.</li>
</ol>
</div>
</div>

<div id="outline-container-orgebfb9cf" class="outline-2">
<h2 id="orgebfb9cf"><span class="section-number-2">3</span> FIRST and FOLLOW</h2>
<div class="outline-text-2" id="text-3">
<p>
The construction of <i>both</i> top-down and bottom-up parsers needs these
two functions.
</p>

<dl class="org-dl">
<dt>FIRST(\(\alpha\))</dt><dd>\(\alpha\) is a string of grammar symbols. The set
of terminals that \(\alpha\) can begin with. E.g <code>A::=cB</code>, <code>FIRST(A)=c</code></dd>
<dt>FOLLOW(A)</dt><dd>non-terminal A, to be the set of terminals that can
appear immediately to the right of A.</dd>
</dl>
</div>
</div>


<div id="outline-container-orgfac9520" class="outline-2">
<h2 id="orgfac9520"><span class="section-number-2">4</span> Error Recovery</h2>
<div class="outline-text-2" id="text-4">
<dl class="org-dl">
<dt>panic-mode</dt><dd>discard input symbols until <i>synchronizing tokens</i> are
found. This is typically delimiters, such as semicolon
or braces.</dd>
<dt>phrase-level</dt><dd>perform local correction, such as remove extra
semicolon, replace coma with semicolon. This is not
good.</dd>
<dt>error-production</dt><dd>use common errors</dd>
<dt>global-correction</dt><dd>there are some algorithms to choose a minimal
sequence of changes to obtain a globally least cost
correction. (What are they??) [Dragon P196]</dd>
</dl>
</div>
</div>



<div id="outline-container-org0754f3c" class="outline-2">
<h2 id="org0754f3c"><span class="section-number-2">5</span> Tools</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orge46ba33" class="outline-3">
<h3 id="orge46ba33"><span class="section-number-3">5.1</span> Elsa and Elkhound</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li><a href="http://www.scottmcpeak.com/elkhound/">http://www.scottmcpeak.com/elkhound/</a></li>
</ul>

<p>
Elkhound is an ancient parser generator, and Elsa is the C++ parser built upon it.
It is clean docs, maybe clean code, worth to check out.
</p>

<p>
It implements the Generalized LR (GLR) parsing, which works with any context-free grammars.
LR parsers (like bison) requires the grammar to be LALR(1).
</p>

<ul class="org-ul">
<li>GLR: <a href="https://en.wikipedia.org/wiki/GLR_parser">https://en.wikipedia.org/wiki/GLR_parser</a></li>
</ul>


<p>
Parsing with arbitrary context-free grammars has two key advantages:
(1) unbounded lookahead, and (2) support for ambiguous grammars. Both
of them are achieved by allowing multiple potential parses to coexist
for as long as necessary.
</p>

<p>
The downside, since it is more general, is slower performance.
</p>
</div>
</div>

<div id="outline-container-org7f7c321" class="outline-3">
<h3 id="org7f7c321"><span class="section-number-3">5.2</span> Semantic Design Inc</h3>
<div class="outline-text-3" id="text-5-2">
<p>
A Commercial Parser Front end:
</p>
<ul class="org-ul">
<li><a href="http://www.semanticdesigns.com/Products/FrontEnds/CppFrontEnd.html">http://www.semanticdesigns.com/Products/FrontEnds/CppFrontEnd.html</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7a8305b" class="outline-3">
<h3 id="org7a8305b"><span class="section-number-3">5.3</span> Parser generator</h3>
<div class="outline-text-3" id="text-5-3">
<dl class="org-dl">
<dt>yacc &amp; lex</dt><dd>generate LALR</dd>
<dt>bison &amp; flex</dt><dd>open source for yacc, so also LALR</dd>
<dt>antlr</dt><dd>top down parser generator, generates recursive-descent parser</dd>
</dl>
</div>
</div>
</div>



<div id="outline-container-org62890e6" class="outline-2">
<h2 id="org62890e6"><span class="section-number-2">6</span> Samples</h2>
<div class="outline-text-2" id="text-6">
<div class="org-src-container">
<pre class="src src-clang">int main() {
  int a,b;
  b=a+b;
  int* arp[5];
  b=(a+b)*a;
}
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://github.com/estree/estree/issues/41">https://github.com/estree/estree/issues/41</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
<a href="https://github.com/getify/concrete-syntax-tree">https://github.com/getify/concrete-syntax-tree</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
<a href="https://github.com/estools">https://github.com/estools</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
<a href="http://www.semdesigns.com/Products/DMS/LifeAfterParsing.html?Home=DMSToolkit">http://www.semdesigns.com/Products/DMS/LifeAfterParsing.html?Home=DMSToolkit</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
<a href="http://www.cse.chalmers.se/edu/year/2011/course/TIN321/lectures/proglang-02.html">http://www.cse.chalmers.se/edu/year/2011/course/TIN321/lectures/proglang-02.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
<a href="http://clang.llvm.org/features.html">http://clang.llvm.org/features.html</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2017-10-26 Thu 16:40</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
