<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-02-24 Fri 12:28 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LeetCode Used Data Structure</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style type="text/css">
a:visited {color: red;}
</style>
<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet"></link>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">LeetCode Used Data Structure</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb6d281d">1. Heap</a>
<ul>
<li><a href="#orgd80f27b">1.1. priority queue</a>
<ul>
<li><a href="#orga4900ff">1.1.1. Usage</a>
<ul>
<li><a href="#orga049d35">1.1.1.1. 295. Find Median from Data Stream</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org20ef3a5">1.2. Implement</a></li>
</ul>
</li>
<li><a href="#org6a081c5">2. <span class="todo TODO">TODO</span> Binary Search Tree</a></li>
<li><a href="#org77020d4">3. Other</a>
<ul>
<li><a href="#orgcdaed7d">3.1. Trie</a>
<ul>
<li><a href="#org3718c0d">3.1.1. 79. Word Search I</a></li>
<li><a href="#org2498d15">3.1.2. Trie</a></li>
<li><a href="#org2e1fa26">3.1.3. 212. Word Search II</a></li>
</ul>
</li>
<li><a href="#org8ef61a6">3.2. prefix tree</a>
<ul>
<li><a href="#org45960cf">3.2.1. Radix Tree</a></li>
</ul>
</li>
<li><a href="#orgd4aeecd">3.3. Aho Corasick</a>
<ul>
<li><a href="#org1aaabd1">3.3.1. Construct Trie</a></li>
<li><a href="#org0ecd308">3.3.2. Node</a></li>
<li><a href="#org7457673">3.3.3. Color</a></li>
<li><a href="#orgdd6e78a">3.3.4. blue arc</a></li>
<li><a href="#org7d3a9ba">3.3.5. Green Arc</a></li>
<li><a href="#orgcee28f9">3.3.6. Match Process</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgb6d281d" class="outline-2">
<h2 id="orgb6d281d"><span class="section-number-2">1</span> Heap</h2>
<div class="outline-text-2" id="text-1">
<p>
A heap is a structure that the value in the parent node is always <i>greater or equal</i> to its children.
Well, it can also be defined as the parent is <i>less or equal</i> to its children.
In C++ standard library, the <code>priority_queue</code> is organized as the top is the greatest, so lets just use this definition.
</p>

<p>
The heap must be of the shape of a complete binary tree. Meaning only the last layer can miss some leafs at the end.
</p>
</div>

<div id="outline-container-orgd80f27b" class="outline-3">
<h3 id="orgd80f27b"><span class="section-number-3">1.1</span> priority queue</h3>
<div class="outline-text-3" id="text-1-1">
<p>
We can <i>use</i> a heap data structure to implement a <i>priority queue</i>.
Instead of FIFO, the order that come out of priority queue is by its priority, a.k.a. value.
</p>
</div>

<div id="outline-container-orga4900ff" class="outline-4">
<h4 id="orga4900ff"><span class="section-number-4">1.1.1</span> Usage</h4>
<div class="outline-text-4" id="text-1-1-1">
</div><div id="outline-container-orga049d35" class="outline-5">
<h5 id="orga049d35"><span class="section-number-5">1.1.1.1</span> 295. Find Median from Data Stream</h5>
<div class="outline-text-5" id="text-1-1-1-1">
<blockquote>
<p>
Median is the middle value in an ordered integer list.
If the size of the list is even, there is no middle value.
So the median is the mean of the two middle value.
</p>

<p>
Design a data structure that supports the following two operations:
</p>
<ul class="org-ul">
<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>
<li>double findMedian() - Return the median of all elements so far.</li>
</ul>
</blockquote>

<p>
Here's a solution that use linked list. So slow.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MedianFinder</span> {
<span style="color: #859900; font-weight: bold;">public</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">Adds a number into the data structure.</span>
  <span style="color: #b58900;">void</span> <span style="color: #268bd2;">addNum</span>(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">num</span>) {
    <span style="color: #859900; font-weight: bold;">if</span> (m_data.empty()) {
      m_data.push_back(num);
      m_it = m_data.begin();
    } <span style="color: #859900; font-weight: bold;">else</span> {
      <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">list</span>&lt;<span style="color: #b58900;">int</span>&gt;::<span style="color: #b58900;">iterator</span> <span style="color: #268bd2;">it</span> = m_it;
      <span style="color: #859900; font-weight: bold;">if</span> (*it &lt; num) {
        <span style="color: #859900; font-weight: bold;">while</span> (it != m_data.end() &amp;&amp; *it &lt; num) {
          it++;
        }
        m_data.insert(it, num);
        <span style="color: #859900; font-weight: bold;">if</span> (m_data.size() % 2 == 1) {
          m_it++;
        }
      } <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> (*it == num) {
        m_data.insert(it, num);
        <span style="color: #859900; font-weight: bold;">if</span> (m_data.size() % 2 == 0) {
          m_it--;
        }
      } <span style="color: #859900; font-weight: bold;">else</span> {
        <span style="color: #859900; font-weight: bold;">while</span> (it != m_data.begin() &amp;&amp; *it &gt; num) {
          it--;
        }
        <span style="color: #859900; font-weight: bold;">if</span> (it == m_data.begin() &amp;&amp; *it &gt; num) {
          m_data.insert(it, num);
        } <span style="color: #859900; font-weight: bold;">else</span> {
          it++;
          m_data.insert(it, num);
        }
        <span style="color: #859900; font-weight: bold;">if</span> (m_data.size() % 2 == 0) {
          m_it--;
        }
      }
    }
  }

  <span style="color: #586e75;">// </span><span style="color: #586e75;">Returns the median of current data stream</span>
  <span style="color: #b58900;">double</span> <span style="color: #268bd2;">findMedian</span>() {
    <span style="color: #b58900;">double</span> <span style="color: #268bd2;">ret</span> = 0;
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">list</span>&lt;<span style="color: #b58900;">int</span>&gt;::<span style="color: #b58900;">iterator</span> <span style="color: #268bd2;">it</span> = m_it;
    <span style="color: #859900; font-weight: bold;">if</span> (m_data.size() % 2 == 0) {
      ret = *it;
      ret += *(++it);
      ret /= 2;
      <span style="color: #859900; font-weight: bold;">return</span> ret;
    } <span style="color: #859900; font-weight: bold;">else</span> {
      <span style="color: #859900; font-weight: bold;">return</span> *it;
    }
  }
<span style="color: #859900; font-weight: bold;">private</span>:
  <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">list</span>&lt;<span style="color: #b58900;">int</span>&gt; <span style="color: #268bd2;">m_data</span>;
  <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">list</span>&lt;<span style="color: #b58900;">int</span>&gt;::<span style="color: #b58900;">iterator</span> <span style="color: #268bd2;">m_it</span>;
};
</pre>
</div>

<p>
Instead, using priority queue, we can use two heap for the smaller half and larger half.
Some points needs to be careful:
</p>
<ul class="org-ul">
<li>Since C++ priority<sub>queue</sub> is greatest top, so the larger half can simply use the negative</li>
<li>But whenever use negative, you need to consider the range of int, so use a long</li>
<li>when calculate a int divided by a int, <i>cast to double</i>!</li>
<li>cannot get the top of an empty container!</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MedianFinder</span> {
<span style="color: #859900; font-weight: bold;">public</span>:
  <span style="color: #b58900;">void</span> <span style="color: #268bd2;">addNum</span>(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">num</span>) {
    <span style="color: #859900; font-weight: bold;">if</span> (smaller.empty()) {
      smaller.push(num);
      <span style="color: #859900; font-weight: bold;">return</span>;
    }
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">n</span> = num;
    <span style="color: #859900; font-weight: bold;">if</span> (smaller.size() == larger.size()) {
      <span style="color: #859900; font-weight: bold;">if</span> (larger.top() &gt; -n) {
        larger.push(-n);
        smaller.push(-larger.top());
        larger.pop();
      } <span style="color: #859900; font-weight: bold;">else</span> {
        smaller.push(n);
      }
    } <span style="color: #859900; font-weight: bold;">else</span> {
      <span style="color: #586e75;">// </span><span style="color: #586e75;">smaller have one more</span>
      <span style="color: #859900; font-weight: bold;">if</span> (smaller.top() &gt; n) {
        smaller.push(n);
        larger.push(-smaller.top());
        smaller.pop();
      } <span style="color: #859900; font-weight: bold;">else</span> {
        larger.push(-n);
      }
    }
  }
  <span style="color: #b58900;">double</span> <span style="color: #268bd2;">findMedian</span>() {
    assert(<span style="color: #b58900; font-weight: bold;">!</span>smaller.empty());
    <span style="color: #859900; font-weight: bold;">if</span> (smaller.size() == larger.size()) {
      <span style="color: #859900; font-weight: bold;">return</span> (<span style="color: #b58900;">double</span>)(smaller.top() - larger.top()) / 2;
    } <span style="color: #859900; font-weight: bold;">else</span> {
      <span style="color: #859900; font-weight: bold;">return</span> smaller.top();
    }
  }
<span style="color: #859900; font-weight: bold;">private</span>:
  <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">priority_queue</span>&lt;<span style="color: #b58900;">long</span>&gt; <span style="color: #268bd2;">smaller</span>;
  <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">priority_queue</span>&lt;<span style="color: #b58900;">long</span>&gt; <span style="color: #268bd2;">larger</span>;
};
</pre>
</div>

<p>
This is not very clean code, a more elegant one (Note this will have more push and pop to the heap, so more time overhead):
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MedianFinder3</span> {
<span style="color: #859900; font-weight: bold;">public</span>:
  <span style="color: #b58900;">void</span> <span style="color: #268bd2;">addNum</span>(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">num</span>) {
    smaller.push((<span style="color: #b58900;">long</span>)num);
    larger.push(-smaller.top());
    smaller.pop();
    <span style="color: #859900; font-weight: bold;">if</span> (larger.size() &gt; smaller.size()) {
      smaller.push(-larger.top());
      larger.pop();
    }
  }
  <span style="color: #b58900;">double</span> <span style="color: #268bd2;">findMedian</span>() {
    assert(<span style="color: #b58900; font-weight: bold;">!</span>smaller.empty());
    <span style="color: #859900; font-weight: bold;">return</span> smaller.size() == larger.size() ?
      (<span style="color: #b58900;">double</span>)(smaller.top() - larger.top()) / 2 : smaller.top();
  }
<span style="color: #859900; font-weight: bold;">private</span>:
  <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">priority_queue</span>&lt;<span style="color: #b58900;">long</span>&gt; <span style="color: #268bd2;">smaller</span>;
  <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">priority_queue</span>&lt;<span style="color: #b58900;">long</span>&gt; <span style="color: #268bd2;">larger</span>;
};
</pre>
</div>
</div>
</div>
</div>
</div>




<div id="outline-container-org20ef3a5" class="outline-3">
<h3 id="org20ef3a5"><span class="section-number-3">1.2</span> Implement</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Insert:
</p>
<ul class="org-ul">
<li>First, insert the value at the end of the array, so that we maintain the shape.</li>
<li>Then, pop the value up by comparing with parent, swap if possible and continue.</li>
</ul>

<p>
Remove:
</p>
<ul class="org-ul">
<li>first, remove the root, and move the end of the array to the root.</li>
<li>sink the root down, by comparing with its two children. Swap with the larger child if there is one.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6a081c5" class="outline-2">
<h2 id="org6a081c5"><span class="section-number-2">2</span> <span class="todo TODO">TODO</span> Binary Search Tree</h2>
</div>

<div id="outline-container-org77020d4" class="outline-2">
<h2 id="org77020d4"><span class="section-number-2">3</span> Other</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgcdaed7d" class="outline-3">
<h3 id="orgcdaed7d"><span class="section-number-3">3.1</span> Trie</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-org3718c0d" class="outline-4">
<h4 id="org3718c0d"><span class="section-number-4">3.1.1</span> 79. Word Search I</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring.
The same letter cell may not be used more than once.
</p>

<p>
No magic here, try to start from each cell.
Recur the four directions, so that the back-tracing is automatic by recurrence.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Solution</span> {
<span style="color: #859900; font-weight: bold;">public</span>:
  <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">exist</span>(<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">char</span>&gt;&gt;&amp; <span style="color: #268bd2;">board</span>, <span style="color: #b58900;">string</span> <span style="color: #268bd2;">word</span>) {
    <span style="color: #859900; font-weight: bold;">if</span> (board.empty() || board[0].empty()) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
    <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span>=0;i&lt;board.size();i++) {
      <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">j</span>=0;j&lt;board[0].size();j++) {
        <span style="color: #859900; font-weight: bold;">if</span> (recur(<span style="color: #b58900;">board</span>, word, i, j, 0)) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
      }
    }
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
  }
  <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">recur</span>(<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">char</span>&gt;&gt; &amp;<span style="color: #268bd2;">board</span>, <span style="color: #b58900;">string</span> <span style="color: #268bd2;">word</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">x</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">y</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">idx</span>) {
    <span style="color: #586e75;">// </span><span style="color: #586e75;">std::cout &lt;&lt; "recur: " &lt;&lt; x &lt;&lt; "," &lt;&lt; y  &lt;&lt; "\n";</span>
    <span style="color: #859900; font-weight: bold;">if</span> (idx &gt;= (<span style="color: #b58900;">int</span>)word.size()) {
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
    }
    <span style="color: #859900; font-weight: bold;">if</span> (x &lt; 0 || y &lt; 0 || x &gt;= (<span style="color: #b58900;">int</span>)board.size() || y &gt;= (<span style="color: #b58900;">int</span>)board[0].size()) {
      <span style="color: #586e75;">// </span><span style="color: #586e75;">std::cout &lt;&lt; "  &lt;--"  &lt;&lt; "\n";</span>
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
    }
    <span style="color: #859900; font-weight: bold;">if</span> (board[x][y] != word[idx]) {
      <span style="color: #586e75;">// </span><span style="color: #586e75;">std::cout &lt;&lt; "  &lt;--"  &lt;&lt; "\n";</span>
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
    }
    <span style="color: #859900; font-weight: bold;">if</span> (board[x][y] == word[idx]) {
      <span style="color: #b58900;">char</span> <span style="color: #268bd2;">c</span> = board[x][y];
      board[x][y] = <span style="color: #2aa198;">'\0'</span>;
      <span style="color: #859900; font-weight: bold;">if</span> (
          recur(<span style="color: #b58900;">board</span>, word, x+1, y, idx+1)
          || recur(<span style="color: #b58900;">board</span>, word, x, y+1, idx+1)
          || recur(<span style="color: #b58900;">board</span>, word, x-1, y, idx+1)
          || recur(<span style="color: #b58900;">board</span>, word, x, y-1, idx+1)
          ) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
      board[x][y] = c;
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
    }
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org2498d15" class="outline-4">
<h4 id="org2498d15"><span class="section-number-4">3.1.2</span> Trie</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The implementation is easy, but know when to use it is hard!
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">TrieNode</span> {
<span style="color: #859900; font-weight: bold;">public</span>:
  <span style="color: #268bd2;">TrieNode</span>() {
  }
  <span style="color: #b58900;">TrieNode</span> *<span style="color: #268bd2;">child</span>(<span style="color: #b58900;">char</span> <span style="color: #268bd2;">c</span>) {
    <span style="color: #859900; font-weight: bold;">if</span> (m_map.count(c) == 1) <span style="color: #859900; font-weight: bold;">return</span> m_map[c];
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">NULL</span>;
  }
  <span style="color: #b58900;">TrieNode</span> *<span style="color: #268bd2;">addChild</span>(<span style="color: #b58900;">char</span> <span style="color: #268bd2;">c</span>) {
    <span style="color: #b58900;">TrieNode</span> *<span style="color: #268bd2;">node</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">TrieNode</span>();
    m_map[c] = node;
    <span style="color: #859900; font-weight: bold;">return</span> node;
  }
  <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">isLeaf</span>() {
    <span style="color: #859900; font-weight: bold;">return</span> m_isleaf;
  }
  <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setLeaf</span>() {
    m_isleaf = <span style="color: #268bd2; font-weight: bold;">true</span>;
  }
  <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">hasChild</span>() {
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900; font-weight: bold;">!</span>m_map.empty();
  }

<span style="color: #859900; font-weight: bold;">private</span>:
  <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">map</span>&lt;<span style="color: #b58900;">char</span>, <span style="color: #b58900;">TrieNode</span>*&gt; <span style="color: #268bd2;">m_map</span>;
  <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">m_isleaf</span> = <span style="color: #268bd2; font-weight: bold;">false</span>;
};

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Trie</span> {
<span style="color: #859900; font-weight: bold;">public</span>:
  <span style="color: #268bd2;">Trie</span>() {
    root = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">TrieNode</span>();
  }

  <span style="color: #586e75;">// </span><span style="color: #586e75;">Inserts a word into the trie.</span>
  <span style="color: #b58900;">void</span> <span style="color: #268bd2;">insert</span>(<span style="color: #b58900;">string</span> <span style="color: #268bd2;">word</span>) {
    <span style="color: #b58900;">TrieNode</span> *<span style="color: #268bd2;">node</span> = root;
    <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">char</span> <span style="color: #268bd2;">c</span> : word) {
      <span style="color: #859900; font-weight: bold;">if</span> (node-&gt;child(c)) {
        node = node-&gt;child(c);
      } <span style="color: #859900; font-weight: bold;">else</span> {
        node = node-&gt;addChild(c);
      }
    }
    node-&gt;setLeaf();
  }

  <span style="color: #586e75;">// </span><span style="color: #586e75;">Returns if the word is in the trie.</span>
  <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">search</span>(<span style="color: #b58900;">string</span> <span style="color: #268bd2;">word</span>) {
    <span style="color: #b58900;">TrieNode</span> *<span style="color: #268bd2;">node</span> = root;
    <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">char</span> <span style="color: #268bd2;">c</span> : word) {
      <span style="color: #859900; font-weight: bold;">if</span> ((node = node-&gt;child(c))) {
      } <span style="color: #859900; font-weight: bold;">else</span> {
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
      }
    }
    <span style="color: #859900; font-weight: bold;">if</span> (node-&gt;isLeaf()) {
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
    }
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
  }

  <span style="color: #586e75;">// </span><span style="color: #586e75;">Returns if there is any word in the trie</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">that starts with the given prefix.</span>
  <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">startsWith</span>(<span style="color: #b58900;">string</span> <span style="color: #268bd2;">prefix</span>) {
    <span style="color: #b58900;">TrieNode</span> *<span style="color: #268bd2;">node</span> = root;
    <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">char</span> <span style="color: #268bd2;">c</span> : prefix) {
      <span style="color: #859900; font-weight: bold;">if</span> ((node = node-&gt;child(c))) {
      } <span style="color: #859900; font-weight: bold;">else</span> {
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
      }
    }
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
  }

<span style="color: #859900; font-weight: bold;">private</span>:
  <span style="color: #b58900;">TrieNode</span>* <span style="color: #268bd2;">root</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org2e1fa26" class="outline-4">
<h4 id="org2e1fa26"><span class="section-number-4">3.1.3</span> 212. Word Search II</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
We only carry the TrieNode, and it should store the word, aka the value.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Solution</span> {
<span style="color: #859900; font-weight: bold;">public</span>:
  <span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">string</span>&gt; <span style="color: #268bd2;">findWords</span>(<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">char</span>&gt;&gt;&amp; <span style="color: #268bd2;">board</span>, <span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">string</span>&gt;&amp; <span style="color: #268bd2;">words</span>) {
    <span style="color: #586e75;">// </span><span style="color: #586e75;">construct a trie for all the words to search</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">continue to do the recursive method</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">keep the track of current value</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">if cannot search it on trie, stop the recursion along this line</span>
    <span style="color: #b58900;">Trie</span> <span style="color: #268bd2;">trie</span>;
    <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">string</span> <span style="color: #268bd2;">s</span> : words) {
      trie.insert(s);
    }
    <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span>=0;i&lt;(<span style="color: #b58900;">int</span>)board.size();i++) {
      <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span>=0;j&lt;(<span style="color: #b58900;">int</span>)board[0].size();j++) {
        recur(<span style="color: #b58900;">board</span>, i, j, trie.getRoot());
      }
    }
    <span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">string</span>&gt; <span style="color: #268bd2;">retv</span> (ret.begin(), ret.end());
    <span style="color: #859900; font-weight: bold;">return</span> retv;
  }
  <span style="color: #b58900;">void</span> <span style="color: #268bd2;">recur</span>(<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">char</span>&gt; &gt; &amp;<span style="color: #268bd2;">board</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span>, <span style="color: #b58900;">TrieNode</span> *<span style="color: #268bd2;">node</span>) {
    <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #b58900; font-weight: bold;">!</span>node) {<span style="color: #859900; font-weight: bold;">return</span>;}
    <span style="color: #859900; font-weight: bold;">if</span> (node-&gt;isLeaf()) ret.insert(node-&gt;Value());
    <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #b58900; font-weight: bold;">!</span>node-&gt;hasChild()) {<span style="color: #859900; font-weight: bold;">return</span>;}
    <span style="color: #859900; font-weight: bold;">if</span> (i &lt; 0 || j &lt; 0 || i &gt;= (<span style="color: #b58900;">int</span>)board.size() || j &gt;= (<span style="color: #b58900;">int</span>)board[0].size()) {<span style="color: #859900; font-weight: bold;">return</span>;}
    <span style="color: #859900; font-weight: bold;">if</span> (node-&gt;child(<span style="color: #b58900;">board</span>[i][j])) {
      <span style="color: #b58900;">char</span> <span style="color: #268bd2;">c</span> = board[i][j];
      board[i][j] = <span style="color: #2aa198;">'\0'</span>;
      node = node-&gt;child(c);
      recur(<span style="color: #b58900;">board</span>, i, j-1, node);
      recur(<span style="color: #b58900;">board</span>, i, j+1, node);
      recur(<span style="color: #b58900;">board</span>, i-1, j, node);
      recur(<span style="color: #b58900;">board</span>, i+1, j, node);
      board[i][j] = c;
    } <span style="color: #859900; font-weight: bold;">else</span> {
      <span style="color: #859900; font-weight: bold;">return</span>;
    }
  }
<span style="color: #859900; font-weight: bold;">private</span>:
  <span style="color: #b58900;">set</span>&lt;<span style="color: #b58900;">string</span>&gt; <span style="color: #268bd2;">ret</span>;
};
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org8ef61a6" class="outline-3">
<h3 id="org8ef61a6"><span class="section-number-3">3.2</span> prefix tree</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Alias: <code>Trie</code>, <code>Prefix Tree</code>, <code>Radix Tree</code>
</p>

<p>
It is an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings
</p>



<div class="figure">
<p><img src="https://farm8.staticflickr.com/7527/16078670017_18478a43e5_o.png" alt="16078670017_18478a43e5_o.png" />
</p>
</div>
</div>


<div id="outline-container-org45960cf" class="outline-4">
<h4 id="org45960cf"><span class="section-number-4">3.2.1</span> Radix Tree</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
A radix tree (also patricia trie or radix trie or compact prefix tree) is a space-optimized trie data structure where each node with only one child is merged with its parent.
</p>

<p>
Unlike in regular tries, edges can be labeled with sequences of elements as well as single elements.
</p>


<div class="figure">
<p><img src="https://farm8.staticflickr.com/7533/16264560645_3ec5648d69_o.png" alt="16264560645_3ec5648d69_o.png" />
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgd4aeecd" class="outline-3">
<h3 id="orgd4aeecd"><span class="section-number-3">3.3</span> Aho Corasick</h3>
<div class="outline-text-3" id="text-3-3">
<p>
It is a multiple string match algorithm. <code>fgrep</code> is based on this.
</p>
</div>


<div id="outline-container-org1aaabd1" class="outline-4">
<h4 id="org1aaabd1"><span class="section-number-4">3.3.1</span> Construct Trie</h4>
<div class="outline-text-4" id="text-3-3-1">

<div class="figure">
<p><img src="https://farm8.staticflickr.com/7572/16085105388_86fedb2235_o.png" alt="16085105388_86fedb2235_o.png" />
</p>
</div>

<p>
dictionary: <code>{a,ab,bab,bc,bca,c,caa}</code>
</p>
</div>
</div>

<div id="outline-container-org0ecd308" class="outline-4">
<h4 id="org0ecd308"><span class="section-number-4">3.3.2</span> Node</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
The data structure has one node for every prefix of every string in the dictionary.
So if (bca) is in the dictionary,
then there will be nodes for (bca), (bc), (b), and ().
</p>
</div>
</div>

<div id="outline-container-org7457673" class="outline-4">
<h4 id="org7457673"><span class="section-number-4">3.3.3</span> Color</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
If a node is in the dictionary then it is blue node.
Otherwise it is a grey node.
</p>
</div>
</div>

<div id="outline-container-orgdd6e78a" class="outline-4">
<h4 id="orgdd6e78a"><span class="section-number-4">3.3.4</span> blue arc</h4>
<div class="outline-text-4" id="text-3-3-4">
<p>
a blue directed "suffix" arc from each node to the node that is the longest possible strict suffix of it in the graph.
For example, for node (caa), its strict suffixes are (aa) and (a) and ().
The longest of these that exists in the graph is (a).
So there is a blue arc from (caa) to (a).
</p>
</div>
</div>

<div id="outline-container-org7d3a9ba" class="outline-4">
<h4 id="org7d3a9ba"><span class="section-number-4">3.3.5</span> Green Arc</h4>
<div class="outline-text-4" id="text-3-3-5">
<p>
There is a green "dictionary suffix" arc from each node to the next node in the dictionary that can be reached by following blue arcs. For example, there is a green arc from (bca) to (a) because (a) is the first node in the dictionary (i.e. a blue node) that is reached when following the blue arcs to (ca) and then on to (a).
</p>
</div>
</div>

<div id="outline-container-orgcee28f9" class="outline-4">
<h4 id="orgcee28f9"><span class="section-number-4">3.3.6</span> Match Process</h4>
<div class="outline-text-4" id="text-3-3-6">
<p>
At each step, the current node is extended by finding its child,
and if that doesn't exist, finding its suffix's child,
and if that doesn't work, finding its suffix's suffix's child,
and so on, finally ending in the root node if nothing's seen before.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2017-02-24 Fri 12:28</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
