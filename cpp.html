<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-03-10 Thu 13:11 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>C++</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style>
a:visited {color: red;}
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">C++</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline2">1. Tips</a>
<ul>
<li><a href="#orgheadline1">1.1. function object</a></li>
</ul>
</li>
<li><a href="#orgheadline10">2. constant</a>
<ul>
<li><a href="#orgheadline3">2.1. Rationale</a></li>
<li><a href="#orgheadline9">2.2. How to use</a>
<ul>
<li><a href="#orgheadline6">2.2.1. const</a>
<ul>
<li><a href="#orgheadline4">2.2.1.1. data and pointer const</a></li>
<li><a href="#orgheadline5">2.2.1.2. const return value of operator</a></li>
</ul>
</li>
<li><a href="#orgheadline7">2.2.2. enums</a></li>
<li><a href="#orgheadline8">2.2.3. inlines</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline13">3. friendship</a>
<ul>
<li><a href="#orgheadline11">3.1. Friend function</a></li>
<li><a href="#orgheadline12">3.2. Friend Class</a></li>
</ul>
</li>
<li><a href="#orgheadline17">4. Inheritance</a>
<ul>
<li><a href="#orgheadline14">4.1. public inheritance</a></li>
<li><a href="#orgheadline15">4.2. hide method</a></li>
<li><a href="#orgheadline16">4.3. make it visible</a></li>
</ul>
</li>
<li><a href="#orgheadline20">5. lambda</a>
<ul>
<li><a href="#orgheadline18">5.1. syntax</a></li>
<li><a href="#orgheadline19">5.2. Explanations</a></li>
</ul>
</li>
<li><a href="#orgheadline21">6. Overload</a></li>
<li><a href="#orgheadline22">7. Polymorphism</a></li>
<li><a href="#orgheadline28">8. reference vs. value</a>
<ul>
<li><a href="#orgheadline23">8.1. pass-by-reference</a></li>
<li><a href="#orgheadline27">8.2. don't return reference when you must return a value</a>
<ul>
<li><a href="#orgheadline24">8.2.1. stack</a></li>
<li><a href="#orgheadline25">8.2.2. heap</a></li>
<li><a href="#orgheadline26">8.2.3. the right way</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline34">9. rvalue</a>
<ul>
<li><a href="#orgheadline29">9.1. lvalue</a></li>
<li><a href="#orgheadline30">9.2. prvalue</a></li>
<li><a href="#orgheadline31">9.3. xvalue</a></li>
<li><a href="#orgheadline33">9.4. rvalue</a>
<ul>
<li><a href="#orgheadline32">9.4.1. std::move</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline40">10. value</a>
<ul>
<li><a href="#orgheadline35">10.1. lvalue</a></li>
<li><a href="#orgheadline36">10.2. xvalue</a></li>
<li><a href="#orgheadline37">10.3. glvalue</a></li>
<li><a href="#orgheadline38">10.4. rvalue</a></li>
<li><a href="#orgheadline39">10.5. prvalue</a></li>
</ul>
</li>
<li><a href="#orgheadline41">11. Smart Pointer</a></li>
<li><a href="#orgheadline42">12. undefined behavior</a></li>
<li><a href="#orgheadline45">13. 函数</a>
<ul>
<li><a href="#orgheadline43">13.1. auto</a></li>
<li><a href="#orgheadline44">13.2. at</a></li>
</ul>
</li>
<li><a href="#orgheadline59">14. Constructor</a>
<ul>
<li><a href="#orgheadline48">14.1. auto-gen by compiler</a>
<ul>
<li><a href="#orgheadline46">14.1.1. explicitly disallow the auto-gen</a></li>
<li><a href="#orgheadline47">14.1.2. compile time solution</a></li>
</ul>
</li>
<li><a href="#orgheadline54">14.2. Copy constructor &amp; copy assignment</a>
<ul>
<li><a href="#orgheadline53">14.2.1. copy assignment</a>
<ul>
<li><a href="#orgheadline49">14.2.1.1. Should return `*this`:</a></li>
<li><a href="#orgheadline50">14.2.1.2. handle self assignment</a></li>
<li><a href="#orgheadline51">14.2.1.3. The way to get rid of self-assignment unsafe</a></li>
<li><a href="#orgheadline52">14.2.1.4. The way to get rid of both</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline55">14.3. explicit constructor</a></li>
<li><a href="#orgheadline58">14.4. initialization</a>
<ul>
<li><a href="#orgheadline56">14.4.1. Default Constructor</a></li>
<li><a href="#orgheadline57">14.4.2. initialization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline64">15. virtual</a>
<ul>
<li><a href="#orgheadline60">15.1. Bottom Line</a></li>
<li><a href="#orgheadline61">15.2. Description</a></li>
<li><a href="#orgheadline62">15.3. Virtual vs. Non-Virtual</a></li>
<li><a href="#orgheadline63">15.4. Virtual vs. Pure Virtual</a></li>
</ul>
</li>
<li><a href="#orgheadline70">16. Stream</a>
<ul>
<li><a href="#orgheadline68">16.1. file stream</a>
<ul>
<li><a href="#orgheadline65">16.1.1. When to flush</a></li>
<li><a href="#orgheadline66">16.1.2. mode</a></li>
<li><a href="#orgheadline67">16.1.3. seek</a></li>
</ul>
</li>
<li><a href="#orgheadline69">16.2. iostream</a></li>
</ul>
</li>
<li><a href="#orgheadline88">17. String</a>
<ul>
<li><a href="#orgheadline71">17.1. Constructor</a></li>
<li><a href="#orgheadline72">17.2. operator=</a></li>
<li><a href="#orgheadline76">17.3. handy routine</a>
<ul>
<li><a href="#orgheadline73">17.3.1. trim a string</a></li>
<li><a href="#orgheadline74">17.3.2. split a string</a></li>
<li><a href="#orgheadline75">17.3.3. better split string</a></li>
</ul>
</li>
<li><a href="#orgheadline82">17.4. member function</a>
<ul>
<li><a href="#orgheadline77">17.4.1. iterator</a></li>
<li><a href="#orgheadline78">17.4.2. capacity</a></li>
<li><a href="#orgheadline79">17.4.3. access</a></li>
<li><a href="#orgheadline80">17.4.4. mofifier</a></li>
<li><a href="#orgheadline81">17.4.5. operation</a></li>
</ul>
</li>
<li><a href="#orgheadline87">17.5. non-member function</a>
<ul>
<li><a href="#orgheadline83">17.5.1. operator +</a></li>
<li><a href="#orgheadline84">17.5.2. rational</a></li>
<li><a href="#orgheadline85">17.5.3. &gt;&gt;</a></li>
<li><a href="#orgheadline86">17.5.4. getline</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline89">18. decltype</a></li>
<li><a href="#orgheadline90">19. pair</a></li>
<li><a href="#orgheadline92">20. non-member function</a>
<ul>
<li><a href="#orgheadline91">20.1. A common pattern</a></li>
</ul>
</li>
<li><a href="#orgheadline106">21. STL</a>
<ul>
<li><a href="#orgheadline93">21.1. comparison function</a></li>
<li><a href="#orgheadline97">21.2. vector</a>
<ul>
<li><a href="#orgheadline94">21.2.1. init</a></li>
<li><a href="#orgheadline95">21.2.2. functions</a></li>
<li><a href="#orgheadline96">21.2.3. Note</a></li>
</ul>
</li>
<li><a href="#orgheadline102">21.3. map</a>
<ul>
<li><a href="#orgheadline98">21.3.1. iterator</a></li>
<li><a href="#orgheadline99">21.3.2. init</a></li>
<li><a href="#orgheadline100">21.3.3. functions</a></li>
<li><a href="#orgheadline101">21.3.4. multimap</a></li>
</ul>
</li>
<li><a href="#orgheadline105">21.4. pass to legacy API</a>
<ul>
<li><a href="#orgheadline103">21.4.1. vector</a></li>
<li><a href="#orgheadline104">21.4.2. String</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline121">22. Algorithm</a>
<ul>
<li><a href="#orgheadline107">22.1. <code>count</code> &amp; <code>count_if</code></a></li>
<li><a href="#orgheadline108">22.2. <code>std::find</code></a></li>
<li><a href="#orgheadline109">22.3. <code>std::find_if</code></a></li>
<li><a href="#orgheadline110">22.4. for</a></li>
<li><a href="#orgheadline111">22.5. <code>std::for_each</code></a></li>
<li><a href="#orgheadline112">22.6. <code>mem_fun</code></a></li>
<li><a href="#orgheadline113">22.7. <code>std::move</code></a></li>
<li><a href="#orgheadline114">22.8. not1</a></li>
<li><a href="#orgheadline115">22.9. reverse</a></li>
<li><a href="#orgheadline119">22.10. sort</a>
<ul>
<li><a href="#orgheadline116">22.10.1. <code>partition</code></a></li>
<li><a href="#orgheadline117">22.10.2. <code>nth_element</code></a></li>
<li><a href="#orgheadline118">22.10.3. <code>partial_sort</code></a></li>
</ul>
</li>
<li><a href="#orgheadline120">22.11. transform</a></li>
</ul>
</li>
<li><a href="#orgheadline128">23. Best Practices</a>
<ul>
<li><a href="#orgheadline127">23.1. compilation dependence</a>
<ul>
<li><a href="#orgheadline122">23.1.1. Forward-declaration doesn't work.</a></li>
<li><a href="#orgheadline123">23.1.2. Why Java don't have such problem?</a></li>
<li><a href="#orgheadline125">23.1.3. Solution 1: pimpl(Pointer to implementation)</a>
<ul>
<li><a href="#orgheadline124">23.1.3.1. Example:</a></li>
</ul>
</li>
<li><a href="#orgheadline126">23.1.4. Solution 2: Interface Class</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline134">24. coding standards</a>
<ul>
<li><a href="#orgheadline129">24.1. &lt;xxx&gt; and &lt;xxx.h&gt;</a></li>
<li><a href="#orgheadline130">24.2. using</a></li>
<li><a href="#orgheadline131">24.3. where to declare variables</a></li>
<li><a href="#orgheadline132">24.4. some lint-like guidelines</a></li>
<li><a href="#orgheadline133">24.5. some crazy unix abbr</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">1</span> Tips</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li><code>main~函数的返回类型必须是 ~int</code></li>
<li>发出警告: <code>-Wall</code></li>
<li><code>cin&gt;&gt;a</code> 遇到 <code>EOF</code> 为假。遇到 <code>&lt;C-D&gt;</code> 为假。</li>
<li><code>./a.out &lt;infile &gt;outfile</code></li>
</ul>
</div>
<div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3">1.1</span> function object</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Objects that act like functions.
Such objects come from classes that overload `operator()`.
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10"><span class="section-number-2">2</span> constant</h2>
<div class="outline-text-2" id="text-2">
<p>
Prefer `const`s, `enum`s, and `inline`s to `#dfine`s.
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">2.1</span> Rationale</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>prefer the compiler to preprocessor,</li>
</ol>
<p>
the define may never be seen by compiler,
thus less meaningful debug information,
less optimization.
</p>
<ol class="org-ol">
<li>`#define`s don't respect scope.</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">2.2</span> How to use</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4">2.2.1</span> const</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">name</span> = <span style="color: #008000;">"Hebi Li"</span>;
<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">std</span>::string name(<span style="color: #008000;">"Hebi Li"</span>);
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> {
<span style="color: #D0372D;">private</span>:
  <span style="color: #0000FF;">static</span> <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">num</span> = 5;
};
</pre>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-5">
<h5 id="orgheadline4"><span class="section-number-5">2.2.1.1</span> data and pointer const</h5>
<div class="outline-text-5" id="text-2-2-1-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">name</span>[] = <span style="color: #008000;">"Hebi Li"</span>;
<span style="color: #6434A3;">char</span> *<span style="color: #BA36A5;">p</span> = name; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">non-const</span>
<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span> *<span style="color: #BA36A5;">p</span> = name; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">const data</span>
<span style="color: #6434A3;">char</span>* <span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">p</span> = name; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">const pointer</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">data     pointer</span>
<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">p</span> = name; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">double const</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-5">
<h5 id="orgheadline5"><span class="section-number-5">2.2.1.2</span> const return value of operator</h5>
<div class="outline-text-5" id="text-2-2-1-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">const</span> <span style="color: #6434A3;">A</span> <span style="color: #006699;">A</span>::operator*(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">A</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">A</span>&amp; rhs);
<span style="color: #0000FF;">if</span> (<span style="color: #6434A3;">a</span>*<span style="color: #BA36A5;">b</span> = c) ... <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">ERROR assign c to a*b</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">char</span>&amp; B::operator[](std::size_t position);
<span style="color: #6434A3;">B</span> <span style="color: #BA36A5;">b</span>[];
b[0] = <span style="color: #008000;">'x'</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">need &amp; in return value, or this assignment can't work because assign to a char</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7"><span class="section-number-4">2.2.2</span> enums</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Some compilers don't support to init value at definition,
because they insist they need to get the when compiling the class.
In this case, use <span class="underline">enum hack</span>:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> {
<span style="color: #D0372D;">private</span>:
  <span style="color: #0000FF;">enum</span> {<span style="color: #BA36A5;">Num</span> = 5}; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">the enum hack: make Num a symbolic name for 5</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8"><span class="section-number-4">2.2.3</span> inlines</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
replace
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #808080;">#define</span> <span style="color: #006699;">CALL_WITH_MAX</span>(<span style="color: #BA36A5;">a</span>,<span style="color: #BA36A5;">b</span>) f((a) &gt; (b) ? (a) : (b))
</pre>
</div>

<p>
with
</p>

<div class="org-src-container">

<pre class="src src-C">template&lt;typename T&gt; <span style="color: #0000FF;">inline</span> <span style="color: #6434A3;">void</span> callWithMax(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">T</span>&amp; a, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">T</span>&amp; b) {
  f(a&gt;b?a:b);
}
</pre>
</div>

<p>
Because you need worry about the parenthesize for define:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">a</span>=5,<span style="color: #BA36A5;">b</span>=0;
CALL_WITH_MAX(++a, b); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">a increased twice</span>
CALL_WITH_MAX(++a, b+10); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">a increased once</span>
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13"><span class="section-number-2">3</span> friendship</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">3.1</span> Friend function</h3>
<div class="outline-text-3" id="text-3-1">
<p>
private and protected member cannot be accessed outside the class, except friends.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> {
<span style="color: #D0372D;">public</span>:
  friend <span style="color: #6434A3;">A</span> <span style="color: #BA36A5;">func</span>(<span style="color: #6434A3;">A</span> <span style="color: #BA36A5;">a</span>); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">declare friend</span>
<span style="color: #D0372D;">private</span>:
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">m</span>;
};
<span style="color: #6434A3;">A</span> <span style="color: #006699;">func</span>(A&amp; a) {
  <span style="color: #6434A3;">A</span> <span style="color: #BA36A5;">res</span>;
  res.m = a.m; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">access both param and return value</span>
  <span style="color: #0000FF;">return</span> res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">3.2</span> Friend Class</h3>
<div class="outline-text-3" id="text-3-2">
<p>
a class whose member functions can access private and protected member of another class.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Rectangle</span> {
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">width</span>, <span style="color: #BA36A5;">height</span>;
public:
  <span style="color: #6434A3;">int</span> area () {}
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">convert</span> (<span style="color: #6434A3;">Square</span> <span style="color: #BA36A5;">a</span>) {
    width = a.side; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">access side in Square</span>
    height = a.side;
  }
};

<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Square</span> {
  friend <span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Rectangle</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">friend declaration</span>
<span style="color: #D0372D;">private</span>:
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">side</span>;
public:
  Square (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">a</span>) : side(a) {}
};
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline17" class="outline-2">
<h2 id="orgheadline17"><span class="section-number-2">4</span> Inheritance</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">4.1</span> public inheritance</h3>
<div class="outline-text-3" id="text-4-1">
<p>
"is-a" relation.
</p>

<p>
Private inheritance means "is-implemented-in-terms-of".
Private inheritance means nothing during software design,
only during software implementation.
Means Derived objects are implemented in terms of Base objects, nothing more.
</p>

<p>
Composition means either "has-a" or "is-implementated-in-terms-of".
</p>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">4.2</span> hide method</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Base</span> {
<span style="color: #D0372D;">private</span>:
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">x</span>;
public:
  virtual <span style="color: #6434A3;">void</span> mf1() = 0;
  virtual <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">mf1</span>(<span style="color: #6434A3;">int</span>);

  virtual <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">mf2</span>();

  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">mf3</span>();
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">mf3</span>(<span style="color: #6434A3;">double</span>);
};
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Derived</span> : public Base {
<span style="color: #D0372D;">public</span>:
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">using Base::mf1; // making all things in Base named mf1 and mf3</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">using Base::mf3; // visible and public in Derived's scope</span>
  virtual <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">mf2</span>() {  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">forwarding function</span>
    Base::mf1();
  }
  virtual <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">mf1</span>();
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">mf3</span>();
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">mf4</span>();
};
</pre>
</div>

<p>
the `mf3` in Derived will hide both of the `mf3` in Base.
The rationale behind this behavior is that
it prevents you from accidentally inheriting overloads from distant base classes
when you create a new derived class in a library or application framework.
</p>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">4.3</span> make it visible</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>`using` declarations</li>
<li>forwarding functions</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-2">
<h2 id="orgheadline20"><span class="section-number-2">5</span> lambda</h2>
<div class="outline-text-2" id="text-5">
<p>
Constructs a closure: an unnamed function object capable of capturing variables in scope.
</p>

<p>
reference:
</p>

<ul class="org-ul">
<li><a href="http://en.cppreference.com/w/cpp/language/lambda">http://en.cppreference.com/w/cpp/language/lambda</a></li>
</ul>
</div>

<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18"><span class="section-number-3">5.1</span> syntax</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>Full declaration:</li>
</ul>

<div class="org-src-container">

<pre class="src src-C">[ capture-list ] ( params ) mutable(optional) <span style="color: #6434A3;">exception</span> <span style="color: #BA36A5;">attribute</span> -&gt; ret { body }
</pre>
</div>

<ul class="org-ul">
<li>Declaration of a const lambda: the objects captured by copy cannot be modified.</li>
</ul>

<div class="org-src-container">

<pre class="src src-C">[ capture-list ] ( params ) -&gt; ret { body }
</pre>
</div>

<p>
for example
</p>

<div class="org-src-container">

<pre class="src src-C">[]()-&gt;<span style="color: #6434A3;">int</span> { <span style="color: #0000FF;">return</span> 2; }
</pre>
</div>

<ul class="org-ul">
<li>Omitted trailing-return-type</li>
</ul>

<div class="org-src-container">

<pre class="src src-C">[ capture-list ] ( params ) { body }
</pre>
</div>

<p>
if the `body` contains nothing but a single return statement, the return type is that expression's type. Otherwise return type is `void`.
</p>

<ul class="org-ul">
<li>Omitted parameter list</li>
</ul>

<p>
take no parameters.
</p>

<div class="org-src-container">

<pre class="src src-C">[ capture-list ] { body }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19"><span class="section-number-3">5.2</span> Explanations</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>`mutable`: allows body to modify the parameters captured by copy, and to call their non-const member functions</li>
<li>`exception`: provides the exception specification or the noexcept clause for operator() of the closure type</li>
<li>`attribute`: provides the attribute specification for operator() of the closure type</li>
<li>`capture-list`: a comma-separated list of zero or more captures
<ul class="org-ul">
<li>`[a,&amp;b]`: where a is captured by value and b is captured by reference.</li>
<li>`[this]`: captures the this pointer by value</li>
<li>`[&amp;]`: captures all automatic variables odr-used in the body of the lambda by reference</li>
<li>`[=]`: captures all automatic variables odr-used in the body of the lambda by value</li>
<li>`[]`: captures nothing</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-2">
<h2 id="orgheadline21"><span class="section-number-2">6</span> Overload</h2>
<div class="outline-text-2" id="text-6">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">void</span> <span style="color: #006699;">print</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>) {
  cout &lt;&lt; <span style="color: #008000;">"Printing int: "</span> &lt;&lt; i &lt;&lt; endl;
}
<span style="color: #6434A3;">void</span> <span style="color: #006699;">print</span>(<span style="color: #6434A3;">double</span>  <span style="color: #BA36A5;">f</span>) {
  cout &lt;&lt; <span style="color: #008000;">"Printing float: "</span> &lt;&lt; f &lt;&lt; endl;
}
<span style="color: #6434A3;">void</span> <span style="color: #006699;">print</span>(<span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">c</span>) {
  cout &lt;&lt; <span style="color: #008000;">"Printing character: "</span> &lt;&lt; c &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-2">
<h2 id="orgheadline22"><span class="section-number-2">7</span> Polymorphism</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Polygon</span> {
<span style="color: #D0372D;">protected</span>:
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">width</span>, <span style="color: #BA36A5;">height</span>;
public:
  <span style="color: #6434A3;">void</span> set_values (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">a</span>, <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">b</span>)
  { width=a; height=b; }
};
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Rectangle</span>: public Polygon {
<span style="color: #D0372D;">public</span>:
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">area</span>()
  { <span style="color: #0000FF;">return</span> width*height; }
};
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Triangle</span>: public Polygon {
<span style="color: #D0372D;">public</span>:
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">area</span>()
  { <span style="color: #0000FF;">return</span> width*height/2; }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-2">
<h2 id="orgheadline28"><span class="section-number-2">8</span> reference vs. value</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23"><span class="section-number-3">8.1</span> pass-by-reference</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Apart from copy problem, there's also a slicing problem.
When a derived class object is passed by value as a base class object,
the base class constructor is called.
</p>

<p>
reference is often implemented as pointer.
So some situation pass by value is more efficient:
</p>

<ul class="org-ul">
<li>built-in type(e.g. int)</li>
<li>iterators and function objects in STL, they are designed to pass by value</li>
</ul>

<p>
But do not just pass by value because the struct seems to be small.
</p>

<ul class="org-ul">
<li>it can be large, by inheritance</li>
<li>the copy constructor may be costly: a object contain little more than a pointer, but the constructor will copy everything they point to.</li>
<li>some compiler treat built-in type and structure differently.</li>
</ul>
<p>
Some will refuse to put a struct that only contains a double into register,
but it will surely put a double into register.
</p>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27"><span class="section-number-3">8.2</span> don't return reference when you must return a value</h3>
<div class="outline-text-3" id="text-8-2">
<p>
A function can create a new object in only two ways: on stack or heap.
</p>

<ul class="org-ul">
<li>Stack =&gt; local variable</li>
<li>Heap =&gt; new</li>
</ul>
</div>

<div id="outline-container-orgheadline24" class="outline-4">
<h4 id="orgheadline24"><span class="section-number-4">8.2.1</span> stack</h4>
<div class="outline-text-4" id="text-8-2-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Rational</span>&amp; operator*(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Rational</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Rational</span>&amp; rhs) {
  <span style="color: #6434A3;">Rational</span> <span style="color: #BA36A5;">result</span>(lhs.n * rhs.n, lhs.d * rhs.d);
  <span style="color: #0000FF;">return</span> result;
}
</pre>
</div>

<p>
The result is a local variable, so it doesn't exist when the function returns.
</p>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25"><span class="section-number-4">8.2.2</span> heap</h4>
<div class="outline-text-4" id="text-8-2-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Rational</span>&amp; operator*(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Rational</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Rational</span>&amp; rhs) {
  <span style="color: #6434A3;">Rational</span> * <span style="color: #BA36A5;">result</span> = new Rational(lhs.n * rhs.h, lhs.d * rhs.d);
  <span style="color: #0000FF;">return</span> result;
}
<span style="color: #6434A3;">Rational</span> <span style="color: #BA36A5;">w</span>,<span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span>,<span style="color: #BA36A5;">z</span>;
w = x * y * z;
</pre>
</div>

<p>
The result of `x*y` will never be freed.
</p>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26"><span class="section-number-4">8.2.3</span> the right way</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
the right way to write a function that must return a new object is to have that function return a new object.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">inline</span> <span style="color: #0000FF;">const</span> Rational operator*(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Rational</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Rational</span>&amp; rhs) {
  <span style="color: #0000FF;">return</span> Rational(lhs.n * rhs.n, lhs.d * rhs.d);
}
</pre>
</div>

<p>
The return value incurs the cost of constructing and destructing,
but it can offer correct behavior.
Besides, the bill that so terrifies you may never arrive.
Compiler optimizations in some cases can eliminate this.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-2">
<h2 id="orgheadline34"><span class="section-number-2">9</span> rvalue</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29"><span class="section-number-3">9.1</span> lvalue</h3>
<div class="outline-text-3" id="text-9-1">
<p>
An lvalue is an expression that identifies a non-temporary object or a non-member function.
</p>

<ul class="org-ul">
<li>The name of a variable or function in scope</li>
<li>Function call or overloaded operator expression if the function's or overloaded operator's return type is an lvalue reference</li>
<li>string literal</li>
<li>&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30"><span class="section-number-3">9.2</span> prvalue</h3>
<div class="outline-text-3" id="text-9-2">
<p>
A prvalue ("pure" rvalue) is an expression that identifies a temporary object (or a subobject thereof)
or is a value not associated with any object.
</p>

<ul class="org-ul">
<li>literal(except string literal): 42, true</li>
<li>&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-3">
<h3 id="orgheadline31"><span class="section-number-3">9.3</span> xvalue</h3>
<div class="outline-text-3" id="text-9-3">
<p>
An xvalue is an expression that identifies an "eXpiring" object, that is, the object that may be moved from.
</p>

<ul class="org-ul">
<li>A function call or overloaded operator expression</li>
</ul>
<p>
if the function's or the overloaded operator's return type is an rvalue reference to object type,
such as std::move(val)
</p>
<ul class="org-ul">
<li>&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline33" class="outline-3">
<h3 id="orgheadline33"><span class="section-number-3">9.4</span> rvalue</h3>
<div class="outline-text-3" id="text-9-4">
<p>
An rvalue is an expression that is either a prvalue or an xvalue.
</p>
</div>

<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32"><span class="section-number-4">9.4.1</span> std::move</h4>
<div class="outline-text-4" id="text-9-4-1">
<p>
std::move obtains an rvalue reference to its argument and converts it to an xvalue.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-2">
<h2 id="orgheadline40"><span class="section-number-2">10</span> value</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-orgheadline35" class="outline-3">
<h3 id="orgheadline35"><span class="section-number-3">10.1</span> lvalue</h3>
<div class="outline-text-3" id="text-10-1">
<p>
An `lvalue` (so-called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object.
</p>

<p>
Example:
</p>

<ul class="org-ul">
<li>If `E` is an expression of pointer type, then `*E` is an lvalue expression referring to the object or function to which E points.</li>
<li>As another example, the result of calling a function whose return type is an lvalue reference is an lvalue.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline36" class="outline-3">
<h3 id="orgheadline36"><span class="section-number-3">10.2</span> xvalue</h3>
<div class="outline-text-3" id="text-10-2">
<p>
An `xvalue` (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references.
</p>

<p>
Example:
</p>

<ul class="org-ul">
<li>The result of calling a function whose return type is an rvalue reference is an xvalue.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37"><span class="section-number-3">10.3</span> glvalue</h3>
<div class="outline-text-3" id="text-10-3">
<p>
A `glvalue` (“generalized” lvalue) is an lvalue or an xvalue.
</p>
</div>
</div>

<div id="outline-container-orgheadline38" class="outline-3">
<h3 id="orgheadline38"><span class="section-number-3">10.4</span> rvalue</h3>
<div class="outline-text-3" id="text-10-4">
<p>
An `rvalue` (so-called, historically, because rvalues could appear on the right-hand side of an assignment expression) is an xvalue, a temporary object or subobject thereof, or a value that is not associated with an object.
</p>
</div>
</div>

<div id="outline-container-orgheadline39" class="outline-3">
<h3 id="orgheadline39"><span class="section-number-3">10.5</span> prvalue</h3>
<div class="outline-text-3" id="text-10-5">
<p>
A `prvalue` (“pure” rvalue) is an rvalue that is not an xvalue.
</p>

<p>
Example:
</p>

<ul class="org-ul">
<li>The result of calling a function whose return type is not a reference is a prvalue.</li>
</ul>

<div class="org-src-container">

<pre class="src src-text">    ______ ______
  /       X      \
 /       / \      \
|   l   | x |  pr  |
 \       \ /      /
  \______ X______/
      gl    r
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline41" class="outline-2">
<h2 id="orgheadline41"><span class="section-number-2">11</span> Smart Pointer</h2>
<div class="outline-text-2" id="text-11">
<div class="org-src-container">

<pre class="src src-C">std::unique_ptr&lt;Type&gt; ptr; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">ensure that the pointer is deleted after going out of scope.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline42" class="outline-2">
<h2 id="orgheadline42"><span class="section-number-2">12</span> undefined behavior</h2>
<div class="outline-text-2" id="text-12">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">int</span> *<span style="color: #BA36A5;">p</span> = 0; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">null pointer</span>
std::cout &lt;&lt; *p; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">UNDEFINED dereferencing a null pointer</span>
<span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">name</span>[] = <span style="color: #008000;">"Carla"</span>;
<span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span> = name[10]; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">UNDEFINED invalid array index</span>
</pre>
</div>

<p>
They most come from pointer and address.
</p>
</div>
</div>

<div id="outline-container-orgheadline45" class="outline-2">
<h2 id="orgheadline45"><span class="section-number-2">13</span> 函数</h2>
<div class="outline-text-2" id="text-13">
</div><div id="outline-container-orgheadline43" class="outline-3">
<h3 id="orgheadline43"><span class="section-number-3">13.1</span> auto</h3>
<div class="outline-text-3" id="text-13-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">auto</span> <span style="color: #6434A3;">g</span> = bind(f, a, b, _2, c, _1);
</pre>
</div>
<p>
此后，调用 <code>g(-1,-2)</code> 等价于调用f，并把 <code>_1</code> 换成 <code>-1</code>, <code>_2</code> 换成 <code>-2</code>.
</p>
</div>
</div>

<div id="outline-container-orgheadline44" class="outline-3">
<h3 id="orgheadline44"><span class="section-number-3">13.2</span> at</h3>
<div class="outline-text-3" id="text-13-2">
<p>
适用于 <code>string</code>, <code>vector</code>, <code>deque</code>, <code>array</code>
</p>

<p>
<code>c.at(n)</code> 返回下表为~n~的元素的引用。如果下标越界，可以抛出 <code>out_of_range</code> 异常。
</p>
</div>
</div>
</div>



<div id="outline-container-orgheadline59" class="outline-2">
<h2 id="orgheadline59"><span class="section-number-2">14</span> Constructor</h2>
<div class="outline-text-2" id="text-14">
</div><div id="outline-container-orgheadline48" class="outline-3">
<h3 id="orgheadline48"><span class="section-number-3">14.1</span> auto-gen by compiler</h3>
<div class="outline-text-3" id="text-14-1">
<p>
If you don't write, the compiler will generate:
</p>

<ul class="org-ul">
<li>a copy constructor</li>
<li>a copy assignment operator</li>
<li>a destructor</li>
<li>a default constructor(if you defined no constructors at all)</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> {
<span style="color: #D0372D;">public</span>:
  <span style="color: #BA36A5;">A</span>() {...} <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">default</span>
  <span style="color: #BA36A5;">A</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">A</span>&amp; rhs) {...} <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">copy</span>
  ~A() {...} <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">destructor</span>
  A&amp; operator=(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">A</span>&amp; rhs) {...} <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">copy assignment operator</span>
};
</pre>
</div>

<p>
But they are generated only if they are needed.
</p>

<p>
For the `operator=`, compiler will generate it iff:
</p>

<ul class="org-ul">
<li>resulting code is legal</li>
<li>reasonable to make sense</li>
</ul>

<p>
e.g.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> {
<span style="color: #D0372D;">private</span>:
  std::string &amp;name;
  <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">num</span>;
};
</pre>
</div>

<p>
compiler will reject to generate `operator=` because when doing assignment,
should the reference be modified?
<span class="underline">C++ doesn't allow make a reference refer to another object.</span>
Should the referred string be modified? It will affect other objects!
It is not legal to modify a const member either.
</p>

<p>
If you want to support copy assignment in the class containing reference or const,
you must define it yourself.
</p>
</div>

<div id="outline-container-orgheadline46" class="outline-4">
<h4 id="orgheadline46"><span class="section-number-4">14.1.1</span> explicitly disallow the auto-gen</h4>
<div class="outline-text-4" id="text-14-1-1">
<p>
### link time solution
Declare the copy constructor and the copy assignment operator private.
So that compiler will not generate, outside can not see them.
</p>

<p>
However, member and friend functions can still call them.
</p>
</div>
</div>

<div id="outline-container-orgheadline47" class="outline-4">
<h4 id="orgheadline47"><span class="section-number-4">14.1.2</span> compile time solution</h4>
<div class="outline-text-4" id="text-14-1-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Uncopyable</span> {
<span style="color: #D0372D;">protected</span>:
  <span style="color: #BA36A5;">Uncopyable</span>() {}
  ~Uncopyable() {}
<span style="color: #D0372D;">private</span>:
  Uncopyable(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Uncopyable</span>&amp;);
  Uncopyable&amp; operator=(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Uncopyable</span>&amp;);
};
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> : private Uncopyable {}
</pre>
</div>

<p>
This works because the compiler will try to
generate copy constructor and copy assignment when anybody tries to copy it.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline54" class="outline-3">
<h3 id="orgheadline54"><span class="section-number-3">14.2</span> Copy constructor &amp; copy assignment</h3>
<div class="outline-text-3" id="text-14-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> {
<span style="color: #D0372D;">public</span>:
  A();
  A(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">A</span>&amp; rhs); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">copy constructor</span>
  A&amp; operator=(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">A</span>&amp; rhs); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">copy assignment operator</span>
};

<span style="color: #6434A3;">A</span> <span style="color: #BA36A5;">a1</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">default constructor</span>
<span style="color: #6434A3;">A</span> <span style="color: #006699;">a2</span>(a1); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">copy constructor</span>
a1 = a2; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">copy assignment operator</span>
<span style="color: #6434A3;">A</span> <span style="color: #BA36A5;">a3</span> = a2; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">copy constructor</span>
</pre>
</div>

<p>
if new object is being defined, a constructor has to be called.
That's why `a3` is not calling a copy assignment operator.
</p>

<p>
copy constructor matters because it defines how an object is <b><b>passed by value</b></b>.
In particular, pass-by-value means "call the copy constructor".
</p>
</div>

<div id="outline-container-orgheadline53" class="outline-4">
<h4 id="orgheadline53"><span class="section-number-4">14.2.1</span> copy assignment</h4>
<div class="outline-text-4" id="text-14-2-1">
</div><div id="outline-container-orgheadline49" class="outline-5">
<h5 id="orgheadline49"><span class="section-number-5">14.2.1.1</span> Should return `*this`:</h5>
<div class="outline-text-5" id="text-14-2-1-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> {
<span style="color: #D0372D;">public</span>:
  A&amp; operator=(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">A</span>&amp; rhs) {
    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
    <span style="color: #0000FF;">return</span> * this; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">return the reference to the lhs argument</span>
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline50" class="outline-5">
<h5 id="orgheadline50"><span class="section-number-5">14.2.1.2</span> handle self assignment</h5>
<div class="outline-text-5" id="text-14-2-1-2">
<p>
This is often:
</p>

<div class="org-src-container">

<pre class="src src-C">a[i] = a[j]; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">in the case i=j</span>
*px = *py;
</pre>
</div>

<p>
The example:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> {};
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">B</span> {
<span style="color: #D0372D;">private</span>:
  <span style="color: #6434A3;">A</span> * <span style="color: #BA36A5;">pa</span>;
};
B&amp; B::operator=(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">B</span>&amp; rhs) {
  <span style="color: #6434A3;">delete</span> <span style="color: #BA36A5;">pa</span>;
  pa = new A(* rhs.pa);
  <span style="color: #0000FF;">return</span> * this;
}
</pre>
</div>

<ul class="org-ul">
<li>self-assignment unsafe:
`rhs.pa` is already deleted if `rhs == this`</li>
<li>exception unsafe:
if exception happens during new, pa will contains a pointer to a deleted A.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline51" class="outline-5">
<h5 id="orgheadline51"><span class="section-number-5">14.2.1.3</span> The way to get rid of self-assignment unsafe</h5>
<div class="outline-text-5" id="text-14-2-1-3">
<div class="org-src-container">

<pre class="src src-C">B&amp; B::operator=(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">B</span>&amp; rhs) {
  <span style="color: #0000FF;">if</span> (this == &amp;rhs) <span style="color: #0000FF;">return</span> * this;
  <span style="color: #6434A3;">delete</span> <span style="color: #BA36A5;">pa</span>;
  pa = new A(* rhs.pa);
  <span style="color: #0000FF;">return</span> * this;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline52" class="outline-5">
<h5 id="orgheadline52"><span class="section-number-5">14.2.1.4</span> The way to get rid of both</h5>
<div class="outline-text-5" id="text-14-2-1-4">
<p>
"copy and swap"
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">B</span> {
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">swap</span>(B&amp; rhs);
};
B&amp; B::operator=(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">B</span>&amp; rhs) {
  <span style="color: #6434A3;">B</span> <span style="color: #BA36A5;">tmp</span>(rhs);
  swap(tmp);
  <span style="color: #0000FF;">return</span> * this;
}
</pre>
</div>

<p>
Or just use pase-by-value:
</p>

<div class="org-src-container">

<pre class="src src-C">B&amp; B::operator=(<span style="color: #6434A3;">B</span> <span style="color: #BA36A5;">rhs</span>) {
  swap(rhs);
  <span style="color: #0000FF;">return</span> * this;
}
</pre>
</div>
</div>
</div>
</div>
</div>







<div id="outline-container-orgheadline55" class="outline-3">
<h3 id="orgheadline55"><span class="section-number-3">14.3</span> explicit constructor</h3>
<div class="outline-text-3" id="text-14-3">
<p>
The explicit prevents the class from being used to perform implicit type conversions,
though they may still be used for explicit type conversions.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">A</span> {
<span style="color: #D0372D;">public</span>:
  <span style="color: #6434A3;">explicit</span> <span style="color: #BA36A5;">A</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">x</span>=0, <span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">b</span>=<span style="color: #D0372D;">true</span>);
  <span style="color: #6434A3;">explicit</span> <span style="color: #BA36A5;">A</span>(<span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">non-default can also have explicit</span>
};
<span style="color: #6434A3;">void</span> <span style="color: #006699;">func</span>(<span style="color: #6434A3;">A</span> <span style="color: #BA36A5;">a</span>);

<span style="color: #6434A3;">A</span> <span style="color: #BA36A5;">a1</span>;
func(a1); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">ok</span>
<span style="color: #6434A3;">A</span> <span style="color: #006699;">a2</span>(20); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">ok</span>
func(20); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">error, cannot convert int to A implicitly</span>
func(A(20)); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">use B constructor to explicit convert</span>
</pre>
</div>

<p>
I declare it explicit unless I have a good reason
for allowing a constructor to be used for implicit type conversions.
</p>
</div>
</div>

<div id="outline-container-orgheadline58" class="outline-3">
<h3 id="orgheadline58"><span class="section-number-3">14.4</span> initialization</h3>
<div class="outline-text-3" id="text-14-4">
</div><div id="outline-container-orgheadline56" class="outline-4">
<h4 id="orgheadline56"><span class="section-number-4">14.4.1</span> Default Constructor</h4>
<div class="outline-text-4" id="text-14-4-1">
<p>
One that can be called without any arguments.
Such constructors have no parameters or have a default value for every parameter.
</p>

<p>
Compilers will automatically call default constructors
for data members of user-defined types
when those data members are not on initialization list.
</p>
</div>
</div>

<div id="outline-container-orgheadline57" class="outline-4">
<h4 id="orgheadline57"><span class="section-number-4">14.4.2</span> initialization</h4>
<div class="outline-text-4" id="text-14-4-2">
<p>
Data members that are const or references must be initialized; they cant be assigned.
</p>

<p>
Do not call constructors within each other.
If init is too many, move them into a private function,
and call the function in all constructors.
</p>

<p>
Base classes are initialized before derived classes;
within a class, data members are initialized in the order in which they declared,
not the position in initialization list.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline64" class="outline-2">
<h2 id="orgheadline64"><span class="section-number-2">15</span> virtual</h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-orgheadline60" class="outline-3">
<h3 id="orgheadline60"><span class="section-number-3">15.1</span> Bottom Line</h3>
<div class="outline-text-3" id="text-15-1">
<ul class="org-ul">
<li>polymorphic base classes should declare virtual destructors.
If a class has virtual functions, it should have virtual destructor</li>
<li>Classes should not have virtual destructor if it is not designed to be
<ul class="org-ul">
<li>base class, or</li>
<li>used polymorphically</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline61" class="outline-3">
<h3 id="orgheadline61"><span class="section-number-3">15.2</span> Description</h3>
<div class="outline-text-3" id="text-15-2">
<p>
`Factory Function`:
a function that returns a base class pointer
to a newly-created derived class object.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">TimeKeeper</span> {
<span style="color: #D0372D;">public</span>:
  TimeKeeper();
  virtual ~TimeKeeper(); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">must have the virtual, or disaster</span>
};
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">AtomicClock</span> : public TimeKeeper {};
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">WaterClock</span> : public TimeKeeper {};
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">WristWatch</span> : public TimeKeeper {};

TimeKeeper *getTimeKeeper(); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">can return any one</span>

<span style="color: #6434A3;">TimeKeeper</span> *<span style="color: #BA36A5;">ptk</span> = getTimeKeeper();
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
<span style="color: #6434A3;">delete</span> <span style="color: #BA36A5;">ptk</span>;
</pre>
</div>

<p>
If no virtual, the `delete ptk` will call the destructor of TimeKeeper,
so the AtomicClock part of the struct will be never destroyed.
</p>

<p>
But do not declare every destructor virtual:
If a class does not contain virtual functions,
it is not meant to be used as a base class.
DO NOT use virtual destructor for it. Because:
</p>

<ul class="org-ul">
<li>virtual requires the objects carry information that can be used at runtime to determine which virtual function to invoke. It will increase the size.</li>
<li>it is not the same as the counterpart in C, not portable.</li>
</ul>

<p>
Never call virtual functions during construction or destruction.
Because during base construction,
virtual functions never go down into the derived class.
</p>
</div>
</div>

<div id="outline-container-orgheadline62" class="outline-3">
<h3 id="orgheadline62"><span class="section-number-3">15.3</span> Virtual vs. Non-Virtual</h3>
<div class="outline-text-3" id="text-15-3">
<p>
Without `virtual` you get <b><b>early binding</b></b>. Which implementation of the method is used gets decided at <b><b>compile time based on the type of the pointer that you call through</b></b>.
</p>

<p>
With `virtual` you get <b><b>late binding</b></b>. Which implementation of the method is used gets decided at <b><b>run time based on the type of the pointed-to object</b></b> - what it was originally constructed as. This is not necessarily what you'd think based on the type of the pointer that points to that object.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Base</span>
{
<span style="color: #D0372D;">public</span>:
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">Method1</span> ()  {  std::cout &lt;&lt; <span style="color: #008000;">"Base::Method1"</span> &lt;&lt; std::endl;  }
  virtual <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">Method2</span> ()  {  std::cout &lt;&lt; <span style="color: #008000;">"Base::Method2"</span> &lt;&lt; std::endl;  }
};

<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Derived</span> : public Base
{
<span style="color: #D0372D;">public</span>:
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">Method1</span> ()  {  std::cout &lt;&lt; <span style="color: #008000;">"Derived::Method1"</span> &lt;&lt; std::endl;  }
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">Method2</span> ()  {  std::cout &lt;&lt; <span style="color: #008000;">"Derived::Method2"</span> &lt;&lt; std::endl;  }
};

<span style="color: #6434A3;">Base</span>* <span style="color: #BA36A5;">obj</span> = new Derived ();
<span style="color: #8D8D84;">//  </span><span style="color: #8D8D84; font-style: italic;">Note - constructed as Derived, but pointer stored as Base*</span>

obj-&gt;Method1 ();  <span style="color: #8D8D84;">//  </span><span style="color: #8D8D84; font-style: italic;">Prints "Base::Method1"</span>
obj-&gt;Method2 ();  <span style="color: #8D8D84;">//  </span><span style="color: #8D8D84; font-style: italic;">Prints "Derived::Method2"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline63" class="outline-3">
<h3 id="orgheadline63"><span class="section-number-3">15.4</span> Virtual vs. Pure Virtual</h3>
<div class="outline-text-3" id="text-15-4">
<ul class="org-ul">
<li>virtual function `can` be overriden</li>
<li>the pure virtual `must` be implemented in non-abstract class</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgheadline70" class="outline-2">
<h2 id="orgheadline70"><span class="section-number-2">16</span> Stream</h2>
<div class="outline-text-2" id="text-16">
</div><div id="outline-container-orgheadline68" class="outline-3">
<h3 id="orgheadline68"><span class="section-number-3">16.1</span> file stream</h3>
<div class="outline-text-3" id="text-16-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;fstream&gt;</span>
<span style="color: #6434A3;">ofstream</span> <span style="color: #BA36A5;">myfile</span>;
myfile.open(<span style="color: #008000;">"a.txt"</span>);
<span style="color: #0000FF;">if</span> (myfile.is_open()) {
  myfile &lt;&lt; <span style="color: #008000;">"..."</span>;
  myfile.close();
}
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">after close, it can used to open another file</span>
myfile.open(<span style="color: #008000;">"b.txt"</span>);
myfile.close();
</pre>
</div>
</div>

<div id="outline-container-orgheadline65" class="outline-4">
<h4 id="orgheadline65"><span class="section-number-4">16.1.1</span> When to flush</h4>
<div class="outline-text-4" id="text-16-1-1">
<ul class="org-ul">
<li>`file.close()`</li>
<li>buffer is full</li>
<li>`flush`, `endl` used as manipulators</li>
<li>`file.sync()`</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline66" class="outline-4">
<h4 id="orgheadline66"><span class="section-number-4">16.1.2</span> mode</h4>
<div class="outline-text-4" id="text-16-1-2">
<p>
open flag:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">flag</td>
<td class="org-left">desription</td>
</tr>

<tr>
<td class="org-left">:------------</td>
<td class="org-left">:----------------------------------------------------------------------------------</td>
</tr>

<tr>
<td class="org-left">ios::in</td>
<td class="org-left">input</td>
</tr>

<tr>
<td class="org-left">ios::out</td>
<td class="org-left">output</td>
</tr>

<tr>
<td class="org-left">ios::binary</td>
<td class="org-left">binary mode</td>
</tr>

<tr>
<td class="org-left">ios::ate</td>
<td class="org-left">initial position to the end of file</td>
</tr>

<tr>
<td class="org-left">ios::app</td>
<td class="org-left">all <b><b>output</b></b> operations are performed at the end of the file, append</td>
</tr>

<tr>
<td class="org-left">ios::trunc</td>
<td class="org-left">if the file is opened for output and already exists, previous content is replaced</td>
</tr>
</tbody>
</table>

<p>
Default:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">class</td>
<td class="org-left">default mode</td>
<td class="org-left">New flag action</td>
</tr>

<tr>
<td class="org-left">:---------</td>
<td class="org-left">:-------------------</td>
<td class="org-left">:----------------</td>
</tr>

<tr>
<td class="org-left">ofstream</td>
<td class="org-left">ios::out</td>
<td class="org-left">add</td>
</tr>

<tr>
<td class="org-left">ifstream</td>
<td class="org-left">ios::in</td>
<td class="org-left">add</td>
</tr>

<tr>
<td class="org-left">fstream</td>
<td class="org-left">ios::in 1 ios::out</td>
<td class="org-left">overwrite</td>
</tr>
</tbody>
</table>

<p>
binary mode cannot use &gt;&gt;, &lt;&lt;, getline, but use
</p>

<div class="org-src-container">

<pre class="src src-C">write(memory_block, size);
read(memory_block, size);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline67" class="outline-4">
<h4 id="orgheadline67"><span class="section-number-4">16.1.3</span> seek</h4>
<div class="outline-text-4" id="text-16-1-3">
<ul class="org-ul">
<li>tellg(): get <span class="underline">get position</span></li>
<li>tellp(): get <span class="underline">put position</span></li>
<li>seekg(position): count from the beginning</li>
<li>seekp(position)</li>
<li>seekg(offset, direction);</li>
<li>seekp(offset, direction);</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">direction</td>
<td class="org-left">description</td>
</tr>

<tr>
<td class="org-left">:----------</td>
<td class="org-left">:------------</td>
</tr>

<tr>
<td class="org-left">ios::beg</td>
<td class="org-left">beginning</td>
</tr>

<tr>
<td class="org-left">ios::cur</td>
<td class="org-left">current</td>
</tr>

<tr>
<td class="org-left">ios::end</td>
<td class="org-left">end</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgheadline69" class="outline-3">
<h3 id="orgheadline69"><span class="section-number-3">16.2</span> iostream</h3>
<div class="outline-text-3" id="text-16-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;iostream&gt;</span>
<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">price</span>;
cin&gt;&gt;price;
</pre>
</div>

<p>
If the input is not integer, the program will <b><b>continue</b></b> without setting price's value.
Then if a is used afterwards, undefined behavior.
</p>

<p>
To add a validation process, we need to use stringstream:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;sstream&gt;</span>
<span style="color: #6434A3;">string</span> <span style="color: #BA36A5;">mystr</span>;
getline(cin, mystr);
<span style="color: #6434A3;">stringstream</span> <span style="color: #BA36A5;">ss</span> = stringstream(mystr);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">validate ss</span>
<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">price</span>;
ss &gt;&gt; price;
</pre>
</div>

<p>
<b>Always use getline instead of cin directly</b>
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">while</span>(getline(cin, line)) {;}
<span style="color: #0000FF;">while</span>(getline(fs, line)) {;}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline88" class="outline-2">
<h2 id="orgheadline88"><span class="section-number-2">17</span> String</h2>
<div class="outline-text-2" id="text-17">
</div><div id="outline-container-orgheadline71" class="outline-3">
<h3 id="orgheadline71"><span class="section-number-3">17.1</span> Constructor</h3>
<div class="outline-text-3" id="text-17-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">default</span>
string();
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">copy</span>
string (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">substring</span>
string (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span> = npos);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">from c-string</span>
string (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">from sequence</span>
string (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">fill</span>
string (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">range</span>
template &lt;class InputIterator&gt;
string  (<span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">first</span>, <span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">last</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline72" class="outline-3">
<h3 id="orgheadline72"><span class="section-number-3">17.2</span> operator=</h3>
<div class="outline-text-3" id="text-17-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">string</span>
string&amp; operator= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">c-string</span>
string&amp; operator= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">character</span>
string&amp; operator= (<span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline76" class="outline-3">
<h3 id="orgheadline76"><span class="section-number-3">17.3</span> handy routine</h3>
<div class="outline-text-3" id="text-17-3">
</div><div id="outline-container-orgheadline73" class="outline-4">
<h4 id="orgheadline73"><span class="section-number-4">17.3.1</span> trim a string</h4>
<div class="outline-text-4" id="text-17-3-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;algorithm&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;functional&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;cctype&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;locale&gt;</span>

<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">trim from start</span>
<span style="color: #0000FF;">static</span> <span style="color: #0000FF;">inline</span> <span style="color: #6434A3;">std</span>::string &amp;ltrim(std::string &amp;s) {
  s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun&lt;<span style="color: #6434A3;">int</span>, <span style="color: #6434A3;">int</span>&gt;(std::isspace))));
  <span style="color: #0000FF;">return</span> s;
}

<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">trim from end</span>
<span style="color: #0000FF;">static</span> <span style="color: #0000FF;">inline</span> <span style="color: #6434A3;">std</span>::string &amp;rtrim(std::string &amp;s) {
  s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun&lt;<span style="color: #6434A3;">int</span>, <span style="color: #6434A3;">int</span>&gt;(std::isspace))).base(), s.end());
  <span style="color: #0000FF;">return</span> s;
}

<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">trim from both ends</span>
<span style="color: #0000FF;">static</span> <span style="color: #0000FF;">inline</span> <span style="color: #6434A3;">std</span>::string &amp;trim(std::string &amp;s) {
  <span style="color: #0000FF;">return</span> ltrim(rtrim(s));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline74" class="outline-4">
<h4 id="orgheadline74"><span class="section-number-4">17.3.2</span> split a string</h4>
<div class="outline-text-4" id="text-17-3-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">string</span> <span style="color: #006699;">s</span>(<span style="color: #008000;">"Somewhere down the road"</span>);
<span style="color: #6434A3;">istringstream</span> <span style="color: #006699;">iss</span>(s);

<span style="color: #0000FF;">do</span>
{
  <span style="color: #6434A3;">string</span> <span style="color: #BA36A5;">sub</span>;
  iss &gt;&gt; sub;
  cout &lt;&lt; <span style="color: #008000;">"Substring: "</span> &lt;&lt; sub &lt;&lt; endl;
} <span style="color: #0000FF;">while</span> (iss);
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C">std::vector&lt;std::string&gt; &amp;split(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">std</span>::string &amp;s, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">delim</span>, std::vector&lt;std::string&gt; &amp;elems) {
  std::stringstream ss(s);
  std::string item;
  <span style="color: #0000FF;">while</span> (std::getline(ss, item, delim)) {
    elems.push_back(item);
  }
  <span style="color: #0000FF;">return</span> elems;
}


std::vector&lt;std::string&gt; split(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">std</span>::string &amp;s, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">delim</span>) {
  std::vector&lt;std::string&gt; elems;
  split(s, delim, elems);
  <span style="color: #0000FF;">return</span> elems;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline75" class="outline-4">
<h4 id="orgheadline75"><span class="section-number-4">17.3.3</span> better split string</h4>
<div class="outline-text-4" id="text-17-3-3">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">to std::cout</span>
copy(
  istream_iterator&lt;string&gt;(iss),
  istream_iterator&lt;string&gt;(),
  ostream_iterator&lt;string&gt;(cout, <span style="color: #008000;">"\n"</span>)
);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">to a vector</span>
vector&lt;string&gt; tokens;
copy(
  istream_iterator&lt;string&gt;(iss),
  istream_iterator&lt;string&gt;(),
  back_inserter(tokens)
);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">construct the vector directly</span>
vector&lt;string&gt; tokens{
  istream_iterator&lt;string&gt;{iss},
  istream_iterator&lt;string&gt;{}
};
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline82" class="outline-3">
<h3 id="orgheadline82"><span class="section-number-3">17.4</span> member function</h3>
<div class="outline-text-3" id="text-17-4">
</div><div id="outline-container-orgheadline77" class="outline-4">
<h4 id="orgheadline77"><span class="section-number-4">17.4.1</span> iterator</h4>
<div class="outline-text-4" id="text-17-4-1">
<ul class="org-ul">
<li>begin()</li>
<li>end()</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline78" class="outline-4">
<h4 id="orgheadline78"><span class="section-number-4">17.4.2</span> capacity</h4>
<div class="outline-text-4" id="text-17-4-2">
<ul class="org-ul">
<li>size(): length of string</li>
<li>length(): length of string</li>
<li>empty()</li>
<li>clear()</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline79" class="outline-4">
<h4 id="orgheadline79"><span class="section-number-4">17.4.3</span> access</h4>
<div class="outline-text-4" id="text-17-4-3">
<ul class="org-ul">
<li>operator[]</li>
<li>at()</li>
<li>back(): A reference to the last character in the string</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline80" class="outline-4">
<h4 id="orgheadline80"><span class="section-number-4">17.4.4</span> mofifier</h4>
<div class="outline-text-4" id="text-17-4-4">
<ul class="org-ul">
<li>operator+=</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">string (1)</span>
string&amp; operator+= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">c-string</span>
string&amp; operator+= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">character</span>
string&amp; operator+= (<span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>);
</pre>
</div>

<ul class="org-ul">
<li>append</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">string</span>
string&amp; append (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">substring</span>
string&amp; append (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">subpos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">sublen</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">c-string</span>
string&amp; append (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">buffer</span>
string&amp; append (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">fill</span>
string&amp; append (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">range</span>
template &lt;class InputIterator&gt;
string&amp; append (<span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">first</span>, <span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">last</span>);
</pre>
</div>

<ul class="org-ul">
<li>push<sub>back</sub>(char): `void push<sub>back</sub> (char c);`</li>

<li>insert(): before the character indicated by pos (or p)</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">string</span>
string&amp; insert (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">substring</span>
string&amp; insert (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">subpos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">sublen</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">c-string</span>
string&amp; insert (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">buffer</span>
string&amp; insert (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">fill</span>
string&amp; insert (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>);
<span style="color: #6434A3;">void</span> <span style="color: #006699;">insert</span> (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">p</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">single character</span>
<span style="color: #6434A3;">iterator</span> <span style="color: #006699;">insert</span> (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">p</span>, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">range</span>
template &lt;class InputIterator&gt;
<span style="color: #6434A3;">void</span> insert (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">p</span>, <span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">first</span>, <span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">last</span>);
</pre>
</div>

<ul class="org-ul">
<li>erase(): erase part of the string</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">sequence</span>
string&amp; erase (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span> = 0, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span> = npos);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">character: Erases the character pointed by p</span>
<span style="color: #6434A3;">iterator</span> <span style="color: #006699;">erase</span> (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">p</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">range: [first,last)</span>
<span style="color: #6434A3;">iterator</span> <span style="color: #006699;">erase</span> (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">first</span>, <span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">last</span>);
</pre>
</div>

<ul class="org-ul">
<li>replace()</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">string</span>
string&amp; replace (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>,  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>,  <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str);
string&amp; replace (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i1</span>, <span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i2</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">substring</span>
string&amp; replace (
  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>,  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>,  <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str,
  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">subpos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">sublen</span>
);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">c-string</span>
string&amp; replace (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>,  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>,  <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>);
string&amp; replace (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i1</span>, <span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i2</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">buffer</span>
string&amp; replace (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>,  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>,  <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>);
string&amp; replace (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i1</span>, <span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i2</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">fill</span>
string&amp; replace (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>,  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>,  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>);
string&amp; replace (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i1</span>, <span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i2</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">range</span>
template &lt;class InputIterator&gt;
string&amp; replace (<span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i1</span>, <span style="color: #6434A3;">iterator</span> <span style="color: #BA36A5;">i2</span>,
  <span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">first</span>, <span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">last</span>
);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline81" class="outline-4">
<h4 id="orgheadline81"><span class="section-number-4">17.4.5</span> operation</h4>
<div class="outline-text-4" id="text-17-4-5">
<ul class="org-ul">
<li>c<sub>str</sub>(): A program <b><b>shall not alter</b></b> any of the characters in this sequence.</li>
<li>copy(): Copies a substring of the current value of the string object</li>
</ul>
<p>
into the array pointed by s.
<b><b>does not append null-terminator</b></b>
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">size_t</span> <span style="color: #006699;">copy</span> (<span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span> = 0) <span style="color: #0000FF;">const</span>;
</pre>
</div>

<ul class="org-ul">
<li>find(): the first occurrence of the sequence specified after pos</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">string</span>
<span style="color: #6434A3;">size_t</span> <span style="color: #006699;">find</span> (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span> = 0) <span style="color: #0000FF;">const</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">c-string</span>
<span style="color: #6434A3;">size_t</span> <span style="color: #006699;">find</span> (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span> = 0) <span style="color: #0000FF;">const</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">buffer</span>
<span style="color: #6434A3;">size_t</span> <span style="color: #006699;">find</span> (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>) <span style="color: #0000FF;">const</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">character</span>
<span style="color: #6434A3;">size_t</span> <span style="color: #006699;">find</span> (<span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span> = 0) <span style="color: #0000FF;">const</span>;
</pre>
</div>

<ul class="org-ul">
<li>substr(): Returns a newly constructed string object</li>
</ul>
<p>
with its value initialized to a copy of a substring of this object
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">string</span> <span style="color: #006699;">substr</span> (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span> = 0, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span> = npos) <span style="color: #0000FF;">const</span>;
</pre>
</div>

<ul class="org-ul">
<li>compare()</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">string</span>
<span style="color: #6434A3;">int</span> <span style="color: #006699;">compare</span> (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str) <span style="color: #0000FF;">const</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">substrings</span>
<span style="color: #6434A3;">int</span> <span style="color: #006699;">compare</span> (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str) <span style="color: #0000FF;">const</span>;
<span style="color: #6434A3;">int</span> <span style="color: #006699;">compare</span> (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str,
  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">subpos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">sublen</span>
) <span style="color: #0000FF;">const</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">c-string</span>
<span style="color: #6434A3;">int</span> <span style="color: #006699;">compare</span> (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>) <span style="color: #0000FF;">const</span>;
<span style="color: #6434A3;">int</span> <span style="color: #006699;">compare</span> (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>) <span style="color: #0000FF;">const</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">buffer</span>
<span style="color: #6434A3;">int</span> <span style="color: #006699;">compare</span> (<span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">pos</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">len</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">n</span>) <span style="color: #0000FF;">const</span>;
</pre>
</div>

<p>
return: 0, -, +
</p>

<ul class="org-ul">
<li>npos: max value of size<sub>t</sub></li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">static</span> <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">npos</span> = -1;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline87" class="outline-3">
<h3 id="orgheadline87"><span class="section-number-3">17.5</span> non-member function</h3>
<div class="outline-text-3" id="text-17-5">
</div><div id="outline-container-orgheadline83" class="outline-4">
<h4 id="orgheadline83"><span class="section-number-4">17.5.1</span> operator +</h4>
<div class="outline-text-4" id="text-17-5-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">string</span>
<span style="color: #6434A3;">string</span> <span style="color: #006699;">operator</span>+ (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">c-string</span>
<span style="color: #6434A3;">string</span> <span style="color: #006699;">operator</span>+ (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">rhs</span>);
<span style="color: #6434A3;">string</span> <span style="color: #006699;">operator</span>+ (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">lhs</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">character</span>
<span style="color: #6434A3;">string</span> <span style="color: #006699;">operator</span>+ (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #6434A3;">char</span>          <span style="color: #BA36A5;">rhs</span>);
<span style="color: #6434A3;">string</span> <span style="color: #006699;">operator</span>+ (<span style="color: #6434A3;">char</span>          <span style="color: #BA36A5;">lhs</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline84" class="outline-4">
<h4 id="orgheadline84"><span class="section-number-4">17.5.2</span> rational</h4>
<div class="outline-text-4" id="text-17-5-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>== (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>== (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">lhs</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>== (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">rhs</span>);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>!= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>!= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">lhs</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>!= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">rhs</span>);
<span style="color: #6434A3;">bool</span> <span style="color: #006699;">operator</span>&lt;  (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #006699;">operator</span>&lt;  (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">lhs</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #006699;">operator</span>&lt;  (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">rhs</span>);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>&lt;= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>&lt;= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">lhs</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>&lt;= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">rhs</span>);
<span style="color: #6434A3;">bool</span> <span style="color: #006699;">operator</span>&gt;  (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #006699;">operator</span>&gt;  (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">lhs</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #006699;">operator</span>&gt;  (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">rhs</span>);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>&gt;= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>&gt;= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">lhs</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; rhs);
<span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>&gt;= (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; lhs, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span>*   <span style="color: #BA36A5;">rhs</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline85" class="outline-4">
<h4 id="orgheadline85"><span class="section-number-4">17.5.3</span> &gt;&gt;</h4>
<div class="outline-text-4" id="text-17-5-3">
<p>
extract string from stream
</p>

<div class="org-src-container">

<pre class="src src-C">istream&amp; operator&gt;&gt; (istream&amp; is, string&amp; str);
ostream&amp; operator&lt;&lt; (ostream&amp; os, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>&amp; str);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline86" class="outline-4">
<h4 id="orgheadline86"><span class="section-number-4">17.5.4</span> getline</h4>
<div class="outline-text-4" id="text-17-5-4">
<p>
get line from stream into string
</p>

<div class="org-src-container">

<pre class="src src-C">istream&amp; getline (istream&amp; is, string&amp; str, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">delim</span>); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">delim</span>
istream&amp; getline (istream&amp; is, string&amp; str); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">new line</span>
</pre>
</div>
</div>
</div>
</div>
</div>




<div id="outline-container-orgheadline89" class="outline-2">
<h2 id="orgheadline89"><span class="section-number-2">18</span> decltype</h2>
<div class="outline-text-2" id="text-18">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">A</span> {
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">x</span>;
};
<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">A</span>* <span style="color: #BA36A5;">a</span> = new A{0};

decltype( a-&gt;x ) x3;       <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">type of x3 is double (declared type)</span>
decltype((a-&gt;x)) x4 = x3;  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">type of x4 is const double&amp; (lvalue expression)</span>

<span style="color: #0000FF;">auto</span> <span style="color: #6434A3;">f</span> = [](<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">a</span>, <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">b</span>) -&gt; <span style="color: #6434A3;">int</span> {
  <span style="color: #0000FF;">return</span> a*b;
};

decltype(f) f2 = f; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">the type of a lambda function is unique and unnamed</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline90" class="outline-2">
<h2 id="orgheadline90"><span class="section-number-2">19</span> pair</h2>
<div class="outline-text-2" id="text-19">
<p>
std::make<sub>pair</sub>
</p>

<div class="org-src-container">

<pre class="src src-C">template &lt;class T1,<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">T2</span>&gt;
pair&lt;T1,T2&gt; make_pair (<span style="color: #6434A3;">T1</span> <span style="color: #BA36A5;">x</span>, <span style="color: #6434A3;">T2</span> <span style="color: #BA36A5;">y</span>)
{
  <span style="color: #0000FF;">return</span> ( pair&lt;T1,T2&gt;(x,y) );
}
</pre>
</div>

<p>
for example:
</p>

<div class="org-src-container">

<pre class="src src-C">std::make_pair(<span style="color: #008000;">"hello"</span>, <span style="color: #008000;">"world"</span>);
</pre>
</div>

<p>
equals to:
</p>

<div class="org-src-container">

<pre class="src src-C">std::pair&lt;string, string&gt;(<span style="color: #008000;">"hello"</span>, <span style="color: #008000;">"world"</span>);
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline92" class="outline-2">
<h2 id="orgheadline92"><span class="section-number-2">20</span> non-member function</h2>
<div class="outline-text-2" id="text-20">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">void</span> <span style="color: #006699;">clearBrowser</span>(WebBrowser&amp; wb) {
  wb.clearCache();
  wb.clearHistory();
  wb.removeCookies();
}
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">WebBrowser</span> {
<span style="color: #D0372D;">public</span>:
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">clearCache</span>();
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">clearHistory</span>();
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">removeCookies</span>();
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">clearEverything</span>();
};
</pre>
</div>

<p>
Prefer use the non-member function,
because then less function can have access to private data,
thus better encapsulate.
</p>
</div>

<div id="outline-container-orgheadline91" class="outline-3">
<h3 id="orgheadline91"><span class="section-number-3">20.1</span> A common pattern</h3>
<div class="outline-text-3" id="text-20-1">
<p>
Putting all convenience functions in multiple header files,
but one namespace.
</p>

<p>
`webbrowser.h`
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">namespace</span> <span style="color: #BA36A5;">WebBrowserStuff</span> {
  <span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">WebBrowser</span> {...};
  <span style="color: #6434A3;">void</span> <span style="color: #BA36A5;">clearBrowser</span>(WebBrowser&amp; wb);
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
}
</pre>
</div>

<p>
`webbrowserbookmarks.h`
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">namespace</span> <span style="color: #BA36A5;">WebBrowserStuff</span> {
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">bookmark related functions</span>
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline106" class="outline-2">
<h2 id="orgheadline106"><span class="section-number-2">21</span> STL</h2>
<div class="outline-text-2" id="text-21">
</div><div id="outline-container-orgheadline93" class="outline-3">
<h3 id="orgheadline93"><span class="section-number-3">21.1</span> comparison function</h3>
<div class="outline-text-3" id="text-21-1">
<p>
Always have comparison functions return false for equal values.
</p>

<div class="org-src-container">

<pre class="src src-C">set&lt;<span style="color: #6434A3;">int</span>, less_equal&lt;<span style="color: #6434A3;">int</span>&gt; &gt; s;
s.insert(10);
s.insert(10);
</pre>
</div>

<p>
check equivalence:
</p>

<div class="org-src-container">

<pre class="src src-C">!(10A&lt;=10B) &amp;&amp; !(10B&lt;=10A);
!<span style="color: #D0372D;">true</span> &amp;&amp; !<span style="color: #D0372D;">true</span>
<span style="color: #D0372D;">false</span>
</pre>
</div>

<p>
a easy-to-made error:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">bool</span> <span style="color: #006699;">operator</span>()(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>* <span style="color: #BA36A5;">ps1</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span>* <span style="color: #BA36A5;">ps2</span>) onst {
  <span style="color: #0000FF;">return</span> !(* ps1&lt;* ps2); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">always pay attention to negative</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline97" class="outline-3">
<h3 id="orgheadline97"><span class="section-number-3">21.2</span> vector</h3>
<div class="outline-text-3" id="text-21-2">
</div><div id="outline-container-orgheadline94" class="outline-4">
<h4 id="orgheadline94"><span class="section-number-4">21.2.1</span> init</h4>
<div class="outline-text-4" id="text-21-2-1">
<p>
<b>ONLY WITH C++11</b>:
with flag <code>-std=c++11</code>
</p>

<div class="org-src-container">

<pre class="src src-C">vector&lt;<span style="color: #6434A3;">int</span>&gt; v {1,2,3};
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">row</span>,<span style="color: #BA36A5;">col</span>;
vector&lt; vector&lt;<span style="color: #6434A3;">int</span>&gt; &gt; heights(row, vector&lt;<span style="color: #6434A3;">int</span>&gt;(col));
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">init</span>[] = <span style="color: #008000;">"1111"</span>;
vector&lt;<span style="color: #6434A3;">char</span>&gt; v(init, end(init)-1); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">remove '\0'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline95" class="outline-4">
<h4 id="orgheadline95"><span class="section-number-4">21.2.2</span> functions</h4>
<div class="outline-text-4" id="text-21-2-2">
<ul class="org-ul">
<li><code>size()</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline96" class="outline-4">
<h4 id="orgheadline96"><span class="section-number-4">21.2.3</span> Note</h4>
<div class="outline-text-4" id="text-21-2-3">
<p>
Do not use <code>vector&lt;bool&gt;</code>.
It actually not store bool,
but proxy object, as the design to save space.
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline102" class="outline-3">
<h3 id="orgheadline102"><span class="section-number-3">21.3</span> map</h3>
<div class="outline-text-3" id="text-21-3">
</div><div id="outline-container-orgheadline98" class="outline-4">
<h4 id="orgheadline98"><span class="section-number-4">21.3.1</span> iterator</h4>
<div class="outline-text-4" id="text-21-3-1">
<div class="org-src-container">

<pre class="src src-C">map&lt;<span style="color: #6434A3;">int</span>,<span style="color: #6434A3;">int</span>&gt; m;
m[2]=3;
m[3]=4;
<span style="color: #0000FF;">for</span>(map&lt;<span style="color: #6434A3;">int</span>,<span style="color: #6434A3;">int</span>&gt;::iterator it=m.begin;it!=m.end();it++) {
  it-&gt;first;
  it-&gt;second;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline99" class="outline-4">
<h4 id="orgheadline99"><span class="section-number-4">21.3.2</span> init</h4>
<div class="outline-text-4" id="text-21-3-2">
<p>
<code>map&lt;int,int&gt; m</code> 中 <code>m[3]</code> 被初始化为0
</p>
</div>
</div>

<div id="outline-container-orgheadline100" class="outline-4">
<h4 id="orgheadline100"><span class="section-number-4">21.3.3</span> functions</h4>
<div class="outline-text-4" id="text-21-3-3">
<ul class="org-ul">
<li><code>size()</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline101" class="outline-4">
<h4 id="orgheadline101"><span class="section-number-4">21.3.4</span> multimap</h4>
<div class="outline-text-4" id="text-21-3-4">
<p>
No <code>[]</code> operator!
</p>

<div class="org-src-container">

<pre class="src src-C">std::multimap&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt; mymm;

mymm.insert(std::pair&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt;(<span style="color: #008000;">'a'</span>,10));
mymm.insert(std::pair&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt;(<span style="color: #008000;">'b'</span>,20));
mymm.insert(std::pair&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt;(<span style="color: #008000;">'b'</span>,30));
mymm.insert(std::pair&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt;(<span style="color: #008000;">'b'</span>,40));
mymm.insert(std::make_pair(<span style="color: #008000;">'c'</span>,50));
mymm.insert(std::pair&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt;(<span style="color: #008000;">'c'</span>,60));
mymm.insert(std::pair&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt;(<span style="color: #008000;">'d'</span>,60));

std::cout &lt;&lt; <span style="color: #008000;">"mymm contains:\n"</span>;
<span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">ch</span>=<span style="color: #008000;">'a'</span>; ch&lt;=<span style="color: #008000;">'d'</span>; ch++)
{
  std::pair &lt;std::multimap&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt;::iterator, std::multimap&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt;::iterator&gt; ret;
  ret = mymm.equal_range(ch);
  std::cout &lt;&lt; ch &lt;&lt; <span style="color: #008000;">" =&gt;"</span>;
  <span style="color: #0000FF;">for</span> (std::multimap&lt;<span style="color: #6434A3;">char</span>,<span style="color: #6434A3;">int</span>&gt;::iterator it=ret.first; it!=ret.second; ++it) {
    std::cout &lt;&lt; <span style="color: #008000;">' '</span> &lt;&lt; it-&gt;second;
  }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline105" class="outline-3">
<h3 id="orgheadline105"><span class="section-number-3">21.4</span> pass to legacy API</h3>
<div class="outline-text-3" id="text-21-4">
</div><div id="outline-container-orgheadline103" class="outline-4">
<h4 id="orgheadline103"><span class="section-number-4">21.4.1</span> vector</h4>
<div class="outline-text-4" id="text-21-4-1">
<div class="org-src-container">

<pre class="src src-C">vector&lt;<span style="color: #6434A3;">int</span>&gt; v;
<span style="color: #6434A3;">void</span> <span style="color: #006699;">func</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">int</span>* <span style="color: #BA36A5;">pi</span>, <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">num</span>);
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">wrong, the size of v may be 0</span>
func(&amp;v[0], v.size());
<span style="color: #0000FF;">if</span> (!v.empty()) {
  func(&amp;v[0], v.size());
}
</pre>
</div>

<p>
do not use <code>v.begin()</code> instead of <code>&amp;v[0]</code>, because:
</p>

<ul class="org-ul">
<li>v.begin() is a iterator, not always a pointer</li>
<li><code>&amp;*v.begin()</code> is same as <code>&amp;v[0]</code>, but &#x2026;</li>
</ul>

<p>
Note, the legacy API should not add/remove items,
because no way for the container to know the size.
</p>
</div>
</div>

<div id="outline-container-orgheadline104" class="outline-4">
<h4 id="orgheadline104"><span class="section-number-4">21.4.2</span> String</h4>
<div class="outline-text-4" id="text-21-4-2">
<p>
Only vectors are guarnteed to have the same underlying memory layout as arrays.
String not.
</p>

<ul class="org-ul">
<li>data for strings is not guaranteed to be stored in contiguous memory.</li>
<li>is not guaranteed to be null terminated</li>
</ul>

<p>
so put the data into a <code>vector&lt;char&gt;</code> first, and use vector trick.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline121" class="outline-2">
<h2 id="orgheadline121"><span class="section-number-2">22</span> Algorithm</h2>
<div class="outline-text-2" id="text-22">
</div><div id="outline-container-orgheadline107" class="outline-3">
<h3 id="orgheadline107"><span class="section-number-3">22.1</span> <code>count</code> &amp; <code>count_if</code></h3>
<div class="outline-text-3" id="text-22-1">
<div class="org-src-container">

<pre class="src src-C">template&lt; class InputIt, <span style="color: #6434A3;">class</span> <span style="color: #006699;">T</span> &gt;
typename iterator_traits&lt;InputIt&gt;::difference_type
count(
  <span style="color: #6434A3;">InputIt</span> <span style="color: #BA36A5;">first</span>,
  <span style="color: #6434A3;">InputIt</span> <span style="color: #BA36A5;">last</span>,
  <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">T</span> &amp;value
);
template&lt; class InputIt, <span style="color: #6434A3;">class</span> <span style="color: #006699;">UnaryPredicate</span> &gt;
typename iterator_traits&lt;InputIt&gt;::difference_type
count_if(
  <span style="color: #6434A3;">InputIt</span> <span style="color: #BA36A5;">first</span>,
  <span style="color: #6434A3;">InputIt</span> <span style="color: #BA36A5;">last</span>,
  <span style="color: #6434A3;">UnaryPredicate</span> <span style="color: #BA36A5;">p</span>
);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline108" class="outline-3">
<h3 id="orgheadline108"><span class="section-number-3">22.2</span> <code>std::find</code></h3>
<div class="outline-text-3" id="text-22-2">
<p>
Returns an iterator to the first element in the range [first,last) that compares equal to val. If no such element is found, the function returns last.
</p>

<div class="org-src-container">

<pre class="src src-C">template&lt;class InputIterator, <span style="color: #6434A3;">class</span> <span style="color: #006699;">T</span>&gt;
InputIterator find (<span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">first</span>, <span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">last</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">T</span>&amp; val)
{
  <span style="color: #0000FF;">while</span> (first!=last) {
    <span style="color: #0000FF;">if</span> (*first==val) <span style="color: #0000FF;">return</span> first; <span style="color: #8D8D84;">//</span><span style="color: #8D8D84; font-style: italic;">*</span>
    ++first;
  }
  <span style="color: #0000FF;">return</span> last;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline109" class="outline-3">
<h3 id="orgheadline109"><span class="section-number-3">22.3</span> <code>std::find_if</code></h3>
<div class="outline-text-3" id="text-22-3">
<p>
Returns an iterator to the first element in the range [first,last) for which pred returns true. If no such element is found, the function returns last.
</p>

<div class="org-src-container">

<pre class="src src-C">template&lt;class InputIterator, <span style="color: #6434A3;">class</span> <span style="color: #006699;">UnaryPredicate</span>&gt;
InputIterator find_if (<span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">first</span>, <span style="color: #6434A3;">InputIterator</span> <span style="color: #BA36A5;">last</span>, <span style="color: #6434A3;">UnaryPredicate</span> <span style="color: #BA36A5;">pred</span>)
{
  <span style="color: #0000FF;">while</span> (first!=last) {
    <span style="color: #0000FF;">if</span> (pred(* first)) <span style="color: #0000FF;">return</span> first;
    ++first;
  }
  <span style="color: #0000FF;">return</span> last;
}
</pre>
</div>

<p>
for example
</p>

<div class="org-src-container">

<pre class="src src-C">template &lt;typename T&gt;
class is_greater_than
{
<span style="color: #D0372D;">public</span>:
  is_greater_than (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">T</span> &amp; n)
  : value(n)
{}

  <span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>() (<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">T</span> &amp; element) <span style="color: #0000FF;">const</span>
{
  <span style="color: #0000FF;">return</span> element &gt; value;
}

private:
  T value;
};
</pre>
</div>

<p>
use here:
</p>

<div class="org-src-container">

<pre class="src src-C">find_if (values.begin(), values.end(), is_greater_than&lt;<span style="color: #6434A3;">int</span>&gt; (5)) != values.end();
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline110" class="outline-3">
<h3 id="orgheadline110"><span class="section-number-3">22.4</span> for</h3>
<div class="outline-text-3" id="text-22-4">
<div class="org-src-container">

<pre class="src src-C">vector&lt;<span style="color: #6434A3;">int</span>&gt; v;
<span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">auto</span> <span style="color: #6434A3;">i</span> : v) {
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">do with i</span>
}
</pre>
</div>

<p>
here `auto` means `vector&lt;int&gt;::value<sub>type</sub>`.
</p>

<p>
is equal-valent to:
</p>

<div class="org-src-container">

<pre class="src src-C">vector&lt;<span style="color: #6434A3;">int</span>&gt; v;
<span style="color: #0000FF;">for</span> (std::vector&lt;<span style="color: #6434A3;">int</span>&gt;::const_iterator it=v.begin();it!=v.end();it++) {
  <span style="color: #0000FF;">auto</span> <span style="color: #6434A3;">i</span>=*it; <span style="color: #8D8D84;">//</span><span style="color: #8D8D84; font-style: italic;">*</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">do with i</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline111" class="outline-3">
<h3 id="orgheadline111"><span class="section-number-3">22.5</span> <code>std::for_each</code></h3>
<div class="outline-text-3" id="text-22-5">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">void</span> <span style="color: #006699;">myfunction</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>) {  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">function:</span>
  std::cout &lt;&lt; <span style="color: #008000;">' '</span> &lt;&lt; i;
}

<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">myclass</span> {           <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">function object type:</span>
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">operator</span>() (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>) {std::cout &lt;&lt; <span style="color: #008000;">' '</span> &lt;&lt; i;}
} <span style="color: #BA36A5;">myobject</span>;

std::vector&lt;<span style="color: #6434A3;">int</span>&gt; myvector;

for_each (myvector.begin(), myvector.end(), myfunction);
for_each (myvector.begin(), myvector.end(), myobject);
for_each (v.begin(),v.end(),[](<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>) { cout&lt;&lt;i; });
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline112" class="outline-3">
<h3 id="orgheadline112"><span class="section-number-3">22.6</span> <code>mem_fun</code></h3>
<div class="outline-text-3" id="text-22-6">
<div class="org-src-container">

<pre class="src src-C">list&lt;Widget*&gt; lpw;
for_each(
  lpw.begin(),
  lpw.end(),
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">because the test is the member function of Widget</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">and we want to call it on all for_each item.</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">If no mem_fun, it can not compile</span>
  mem_fun(&amp;Widget::test)
);
</pre>
</div>

<p>
TODO:
</p>

<ul class="org-ul">
<li>ptr<sub>fun</sub></li>
<li>mem<sub>fun</sub><sub>ref</sub></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline113" class="outline-3">
<h3 id="orgheadline113"><span class="section-number-3">22.7</span> <code>std::move</code></h3>
<div class="outline-text-3" id="text-22-7">
<p>
<code>#include &lt;utility&gt;</code>
</p>

<p>
transfer ownership of the assets and properties of an object directly without having to copy them when the argument is an rvalue.
</p>

<p>
moved-from object is left in a valid but unspecified state
</p>

<div class="org-src-container">

<pre class="src src-C">std::string foo = <span style="color: #008000;">"foo-string"</span>;
std::string bar = <span style="color: #008000;">"bar-string"</span>;
std::vector&lt;std::string&gt; myvector;
myvector.push_back (foo);                    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">copies. foo remain.</span>
myvector.push_back (std::move(bar));         <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">moves. bar contain unspecified value.</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">int</span> <span style="color: #006699;">main</span>()
{
  std::string str = <span style="color: #008000;">"Hello"</span>;
  std::vector&lt;std::string&gt; v;

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">uses the push_back(const T&amp;) overload, which means</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">we'll incur the cost of copying str</span>
  v.push_back(str);
  std::cout &lt;&lt; <span style="color: #008000;">"After copy, str is \""</span> &lt;&lt; str &lt;&lt; <span style="color: #008000;">"\"\n"</span>;

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">uses the rvalue reference push_back(T&amp;&amp;) overload,</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">which means no strings will be copied; instead, the contents</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">of str will be moved into the vector.  This is less</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">expensive, but also means str might now be empty.</span>
  v.push_back(std::move(str));
  std::cout &lt;&lt; <span style="color: #008000;">"After move, str is \""</span> &lt;&lt; str &lt;&lt; <span style="color: #008000;">"\"\n"</span>;

  std::cout &lt;&lt; <span style="color: #008000;">"The contents of the vector are \""</span> &lt;&lt; v[0]
  &lt;&lt; <span style="color: #008000;">"\", \""</span> &lt;&lt; v[1] &lt;&lt; <span style="color: #008000;">"\"\n"</span>;

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">string move assignment operator is often implemented as swap,</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">in this case, the moved-from object is NOT empty</span>
  std::string str2 = <span style="color: #008000;">"Good-bye"</span>;
  std::cout &lt;&lt; <span style="color: #008000;">"Before move from str2, str2 = '"</span> &lt;&lt; str2 &lt;&lt; <span style="color: #008000;">"'\n"</span>;
  v[0] = std::move(str2);
  std::cout &lt;&lt; <span style="color: #008000;">"After move from str2, str2 = '"</span> &lt;&lt; str2 &lt;&lt; <span style="color: #008000;">"'\n"</span>;
}
</pre>
</div>

<p>
Possible output:
</p>

<div class="org-src-container">

<pre class="src src-text">After copy, str is "Hello"
After move, str is ""
The contents of the vector are "Hello", "Hello"
Before move from str2, str2 = 'Good-bye'
After move from str2, str2 = 'Hello'
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline114" class="outline-3">
<h3 id="orgheadline114"><span class="section-number-3">22.8</span> not1</h3>
<div class="outline-text-3" id="text-22-8">
<div class="org-src-container">

<pre class="src src-C">template&lt; class Predicate &gt;
std::unary_negate&lt;Predicate&gt; not1(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Predicate</span>&amp; pred);
template&lt; class Predicate &gt;
constexpr std::unary_negate&lt;Predicate&gt; not1(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Predicate</span>&amp; pred);
</pre>
</div>

<p>
not1 is a helper function to create a function object that returns the complement of the unary predicate function passed.
</p>

<p>
example:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">LessThan7</span> : std::unary_function&lt;<span style="color: #6434A3;">int</span>, <span style="color: #6434A3;">bool</span>&gt;
{
  <span style="color: #6434A3;">bool</span> <span style="color: #BA36A5;">operator</span>()(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>) <span style="color: #0000FF;">const</span> { <span style="color: #0000FF;">return</span> i &lt; 7; }
};
std::not1(LessThan7());
std::function&lt;<span style="color: #6434A3;">int</span>(<span style="color: #6434A3;">int</span>)&gt; less_than_9 = [](<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">x</span>){ <span style="color: #0000FF;">return</span> x &lt; 9; };
std::not1(less_than_9);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline115" class="outline-3">
<h3 id="orgheadline115"><span class="section-number-3">22.9</span> reverse</h3>
<div class="outline-text-3" id="text-22-9">
<div class="org-src-container">

<pre class="src src-C">reverse(v.begin(), v.end());
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline119" class="outline-3">
<h3 id="orgheadline119"><span class="section-number-3">22.10</span> sort</h3>
<div class="outline-text-3" id="text-22-10">
<p>
Do not use `qsort` for some unknown reason..
</p>

<p>
faster to slower:
</p>

<ol class="org-ol">
<li>partition</li>
<li>stable<sub>partition</sub></li>
<li>nth<sub>element</sub></li>
<li>partial<sub>sort</sub></li>
<li>sort</li>
<li>stable<sub>sort</sub></li>
</ol>

<p>
stable means the order of equal element is guaranteed to maintain.
</p>
</div>

<div id="outline-container-orgheadline116" class="outline-4">
<h4 id="orgheadline116"><span class="section-number-4">22.10.1</span> <code>partition</code></h4>
<div class="outline-text-4" id="text-22-10-1">
<p>
The returned iterator is middle.
From first to middle, the predicate is true.
From middle to last, the predicate is false.
</p>

<p>
API:
</p>

<div class="org-src-container">

<pre class="src src-C">template&lt; class BidirIt, <span style="color: #6434A3;">class</span> <span style="color: #006699;">UnaryPredicate</span> &gt;
BidirIt partition(
  <span style="color: #6434A3;">BidirIt</span> <span style="color: #BA36A5;">first</span>,
  <span style="color: #6434A3;">BidirIt</span> <span style="color: #BA36A5;">last</span>,
  <span style="color: #6434A3;">UnaryPredicate</span> <span style="color: #BA36A5;">p</span>
);
template&lt; class ForwardIt, <span style="color: #6434A3;">class</span> <span style="color: #006699;">UnaryPredicate</span> &gt;
ForwardIt partition(
  <span style="color: #6434A3;">ForwardIt</span> <span style="color: #BA36A5;">first</span>,
  <span style="color: #6434A3;">ForwardIt</span> <span style="color: #BA36A5;">last</span>,
  <span style="color: #6434A3;">UnaryPredicate</span> <span style="color: #BA36A5;">p</span>
);
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline117" class="outline-4">
<h4 id="orgheadline117"><span class="section-number-4">22.10.2</span> <code>nth_element</code></h4>
<div class="outline-text-4" id="text-22-10-2">
<p>
The first n elements in the container are best, but not sorted.
</p>

<p>
API:
</p>

<div class="org-src-container">

<pre class="src src-C">template&lt; class RandomIt &gt;
<span style="color: #6434A3;">void</span> nth_element(
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">first</span>,
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">nth</span>,
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">last</span>
);
template&lt; class RandomIt, <span style="color: #6434A3;">class</span> <span style="color: #006699;">Compare</span> &gt;
<span style="color: #6434A3;">void</span> nth_element(
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">first</span>,
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">nth</span>,
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">last</span>,
  <span style="color: #6434A3;">Compare</span> <span style="color: #BA36A5;">comp</span>
);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline118" class="outline-4">
<h4 id="orgheadline118"><span class="section-number-4">22.10.3</span> <code>partial_sort</code></h4>
<div class="outline-text-4" id="text-22-10-3">
<p>
The first n elements in the container are the best, and in order.
</p>

<p>
API:
</p>

<div class="org-src-container">

<pre class="src src-C">template&lt; class RandomIt &gt;
<span style="color: #6434A3;">void</span> partial_sort(
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">first</span>,
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">middle</span>,
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">last</span>
);
template&lt; class RandomIt, <span style="color: #6434A3;">class</span> <span style="color: #006699;">Compare</span> &gt;
<span style="color: #6434A3;">void</span> partial_sort(
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">first</span>,
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">middle</span>,
  <span style="color: #6434A3;">RandomIt</span> <span style="color: #BA36A5;">last</span>,
  <span style="color: #6434A3;">Compare</span> <span style="color: #BA36A5;">comp</span>
);
</pre>
</div>

<p>
example:
</p>

<div class="org-src-container">

<pre class="src src-C">partial_sort(
  v.begin(),
  v.begin()+20,
  v.end(),
  compare
);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline120" class="outline-3">
<h3 id="orgheadline120"><span class="section-number-3">22.11</span> transform</h3>
<div class="outline-text-3" id="text-22-11">
<div class="org-src-container">

<pre class="src src-C">template&lt; class InputIt, <span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">OutputIt</span>, <span style="color: #6434A3;">class</span> <span style="color: #006699;">UnaryOperation</span> &gt;
OutputIt transform(
  <span style="color: #6434A3;">InputIt</span> <span style="color: #BA36A5;">first1</span>,
  <span style="color: #6434A3;">InputIt</span> <span style="color: #BA36A5;">last1</span>,
  <span style="color: #6434A3;">OutputIt</span> <span style="color: #BA36A5;">d_first</span>,
  <span style="color: #6434A3;">UnaryOperation</span> <span style="color: #BA36A5;">unary_op</span>
);
template&lt; class InputIt1, <span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">InputIt2</span>, <span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">OutputIt</span>, <span style="color: #6434A3;">class</span> <span style="color: #006699;">BinaryOperation</span> &gt;
OutputIt transform(
  <span style="color: #6434A3;">InputIt1</span> <span style="color: #BA36A5;">first1</span>,
  <span style="color: #6434A3;">InputIt1</span> <span style="color: #BA36A5;">last1</span>,
  <span style="color: #6434A3;">InputIt2</span> <span style="color: #BA36A5;">first2</span>,
  <span style="color: #6434A3;">OutputIt</span> <span style="color: #BA36A5;">d_first</span>,
  <span style="color: #6434A3;">BinaryOperation</span> <span style="color: #BA36A5;">binary_op</span>
);
</pre>
</div>

<p>
`std::transform` applies the given function to a range and stores the result in another range, beginning at d<sub>first</sub>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline128" class="outline-2">
<h2 id="orgheadline128"><span class="section-number-2">23</span> Best Practices</h2>
<div class="outline-text-2" id="text-23">
</div><div id="outline-container-orgheadline127" class="outline-3">
<h3 id="orgheadline127"><span class="section-number-3">23.1</span> compilation dependence</h3>
<div class="outline-text-3" id="text-23-1">
<p>
The change of a single class can lead to a large amount of file to recompile,
because:
</p>

<ul class="org-ul">
<li>Inheritance</li>
<li>Use another class inside a class</li>
</ul>
</div>

<div id="outline-container-orgheadline122" class="outline-4">
<h4 id="orgheadline122"><span class="section-number-4">23.1.1</span> Forward-declaration doesn't work.</h4>
<div class="outline-text-4" id="text-23-1-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">int</span> <span style="color: #006699;">main</span>() {
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">x</span>;
  <span style="color: #6434A3;">Person</span> <span style="color: #BA36A5;">p</span>(params);
}
</pre>
</div>

<p>
Forward-declaration cannot make it because this is a define,
compiler need to know the size.
</p>
</div>
</div>

<div id="outline-container-orgheadline123" class="outline-4">
<h4 id="orgheadline123"><span class="section-number-4">23.1.2</span> Why Java don't have such problem?</h4>
<div class="outline-text-4" id="text-23-1-2">
<p>
Java treat the above code as
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">int</span> <span style="color: #006699;">main</span>() {
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">x</span>;
  <span style="color: #6434A3;">Person</span> * <span style="color: #BA36A5;">p</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline125" class="outline-4">
<h4 id="orgheadline125"><span class="section-number-4">23.1.3</span> Solution 1: pimpl(Pointer to implementation)</h4>
<div class="outline-text-4" id="text-23-1-3">
<p>
In C++, we can of course play the
"hide the object implementation behind a pointer" game ourself.
</p>

<p>
The key: <span class="underline">replacement of dependencies on definitions with dependencies on declarations.</span>
</p>

<ul class="org-ul">
<li>avoid using objects when object references and pointers will do</li>
<li>depend on class declarations instead of class definitions whenever you can</li>
</ul>

<p>
Note: you never need a class definition to declare a function using that class,
not even if the function passes or returns the class type by value:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Date</span>;
<span style="color: #6434A3;">Date</span> <span style="color: #006699;">today</span>();
<span style="color: #6434A3;">void</span> <span style="color: #006699;">clearAppointment</span>(<span style="color: #6434A3;">Date</span> <span style="color: #BA36A5;">d</span>);
</pre>
</div>

<p>
Because if anybody calls those functions, Date's definition must have been seen prior to the call.
So it is not that nobody calls them, it's that not everybody calls them.
</p>

<ul class="org-ul">
<li>provide separate header flies for declarations and definitions</li>
</ul>

<p>
Classes that employ the pimpl idiom are often called Handle Classes.
</p>
</div>

<div id="outline-container-orgheadline124" class="outline-5">
<h5 id="orgheadline124"><span class="section-number-5">23.1.3.1</span> Example:</h5>
<div class="outline-text-5" id="text-23-1-3-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;string&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;memory&gt;</span>
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">PersonImpl</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">forward decl</span>
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Date</span>;
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Address</span>;
<span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Person</span> {
<span style="color: #D0372D;">public</span>:
  Person(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">std</span>::string&amp; name, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Date</span>&amp; birthday, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Address</span>&amp; addr);
  std::string name() <span style="color: #0000FF;">const</span>;
  std::string birthDate() <span style="color: #0000FF;">const</span>;
  std::string address() <span style="color: #0000FF;">const</span>;
private:
  std::shared_ptr&lt;PersonImpl&gt; pImpl;
};
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #808080;">#include</span> <span style="color: #008000;">"Person.h"</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">we need include PersonImpl.h in order to call the member function</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">PersonImpl has exactly the same API</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">"PersonImpl.h"</span>
Person::Person(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">std</span>::string&amp; name, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Date</span>&amp; birthday, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Address</span>&amp; addr)
: pImpl(<span style="color: #6434A3;">new</span> <span style="color: #BA36A5;">PersonImpl</span>(name, birthday, addr)) {}

std::string Person::name() <span style="color: #0000FF;">const</span> {
  <span style="color: #0000FF;">return</span> pImpl-&gt;name();
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline126" class="outline-4">
<h4 id="orgheadline126"><span class="section-number-4">23.1.4</span> Solution 2: Interface Class</h4>
<div class="outline-text-4" id="text-23-1-4">
<p>
The implementation of non-virtual functions should be the same for all classes in a hierarchy,
so it makes sense to implement such functions as part of the Interface class.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">Person</span> {
<span style="color: #D0372D;">public</span>:
  virtual ~Person();
  <span style="color: #6434A3;">virtual</span> <span style="color: #BA36A5;">std</span>::string name() <span style="color: #0000FF;">const</span> = 0;
  <span style="color: #6434A3;">virtual</span> <span style="color: #BA36A5;">std</span>::string birthDate() <span style="color: #0000FF;">const</span> = 0;
  <span style="color: #6434A3;">virtual</span> <span style="color: #BA36A5;">std</span>::string address() <span style="color: #0000FF;">const</span> = 0;

  <span style="color: #0000FF;">static</span> <span style="color: #6434A3;">std</span>::shard_ptr&lt;Person&gt;
  create(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">std</span>::string&amp; name, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Date</span>&amp; birthday, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Address</span>&amp; addr);
};
std::shared_ptr&lt;Person&gt;
create(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">std</span>::string&amp; name, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Date</span>&amp; birthday, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Addrss</span>&amp; addr) {
  <span style="color: #0000FF;">return</span> std::shared_ptr&lt;Person&gt;(<span style="color: #6434A3;">new</span> <span style="color: #BA36A5;">RealPerson</span>(name, birthday, addr));
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">class</span> <span style="color: #BA36A5;">RealPerson</span> : public Person {
<span style="color: #D0372D;">public</span>:
  RealPerson(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">std</span>::string&amp; name, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Date</span>&amp; birthday, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Address</span>&amp; <span style="color: #D0372D;">addr</span>)
  : theName(name), theBirthDate(birthday), theAddress(addr) {}
  virtual ~RealPerson() {}

  std::string name() <span style="color: #0000FF;">const</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">implement</span>
  std::string birthDate() <span style="color: #0000FF;">const</span>;
  std::string address() <span style="color: #0000FF;">const</span>;
private:
  std::string theName;
  <span style="color: #6434A3;">Date</span> <span style="color: #BA36A5;">theBirthDate</span>;
  <span style="color: #6434A3;">Address</span> <span style="color: #BA36A5;">theAddress</span>;
};
</pre>
</div>

<p>
Clients of interface class need not recompile unless the Interface class's interface is modified.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline134" class="outline-2">
<h2 id="orgheadline134"><span class="section-number-2">24</span> coding standards</h2>
<div class="outline-text-2" id="text-24">
<p>
ref: <a href="https://isocpp.org/wiki/faq/coding-standards">https://isocpp.org/wiki/faq/coding-standards</a>
</p>
</div>

<div id="outline-container-orgheadline129" class="outline-3">
<h3 id="orgheadline129"><span class="section-number-3">24.1</span> &lt;xxx&gt; and &lt;xxx.h&gt;</h3>
<div class="outline-text-3" id="text-24-1">
<p>
C++ standard library is guaranteed to have 18 standard headers from C.
Two type of names: `&lt;cxxx&gt;` and `&lt;xxx.h&gt;`
</p>

<ul class="org-ul">
<li>`&lt;cxxx&gt;`: provide in the `std` namespace only</li>
<li>`&lt;xxx.h&gt;`: make them available in both `std` and global. <b><b>Deprecated</b></b></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline130" class="outline-3">
<h3 id="orgheadline130"><span class="section-number-3">24.2</span> using</h3>
<div class="outline-text-3" id="text-24-2">
<ul class="org-ul">
<li>using-directive: `using namespace std;`. Do not use.</li>
<li>using-declaration: `using std::cout;`. Can be used just as a statement, e.g. in a function.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline131" class="outline-3">
<h3 id="orgheadline131"><span class="section-number-3">24.3</span> where to declare variables</h3>
<div class="outline-text-3" id="text-24-3">
<p>
Declare near the first use.
</p>

<p>
If you don't have enough information to initialize an object until the middle of the code,
create it there.
Don't initialize it to empty and reassign it later,
because performance.
</p>
</div>
</div>

<div id="outline-container-orgheadline132" class="outline-3">
<h3 id="orgheadline132"><span class="section-number-3">24.4</span> some lint-like guidelines</h3>
<div class="outline-text-3" id="text-24-4">
<ul class="org-ul">
<li>A class `Fred`’s assignment operator should return `*this` as a `Fred&amp;` (allows chaining of assignments)</li>
<li>A class with any virtual functions ought to have a virtual destructor</li>
<li>A class with any of the following generally needs all 5
<ul class="org-ul">
<li>destructor</li>
<li>copy assignment operator</li>
<li>copy constructor</li>
<li>move assignment operator</li>
<li>move constructor</li>
</ul></li>
<li>A class `Fred`’s copy constructor and assignment operator should have const in the parameter: respectively `Fred::Fred(const Fred&amp;)` and `Fred&amp; Fred::operator= (const Fred&amp;)`</li>
<li>When initializing an object’s member objects in the constructor, always use initialization lists rather than assignment. 3x performance.</li>
<li>Assignment operators should make sure that self assignment does nothing, otherwise you may have a disaster</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline133" class="outline-3">
<h3 id="orgheadline133"><span class="section-number-3">24.5</span> some crazy unix abbr</h3>
<div class="outline-text-3" id="text-24-5">
<p>
`abbr evthng n sght, usng vry shrt idntfr nms`
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2016-03-10 Thu 13:11</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
