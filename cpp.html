<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-11-20 Mon 10:50 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="assets/hebi.css" /><link rel="stylesheet" type="text/css" href="assets/test.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">C++</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf55133b">1. Idioms</a>
<ul>
<li><a href="#orgcfabfdb">1.1. Curiously recurring template pattern (CRTP)</a>
<ul>
<li><a href="#org77722d5">1.1.1. Static Polymorphism</a></li>
<li><a href="#org35c7e46">1.1.2. Object Counter</a></li>
<li><a href="#orge4c7935">1.1.3. Polymorphic Copy Construction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd4bab3b">2. extern</a></li>
<li><a href="#org401d0e1">3. Class</a>
<ul>
<li><a href="#org3588ffd">3.1. Constructor</a>
<ul>
<li><a href="#orgdd9b82b">3.1.1. auto-gen by compiler</a></li>
<li><a href="#org8bcc076">3.1.2. explicitly disallow the auto-gen</a></li>
<li><a href="#org4b4f4a1">3.1.3. Copy Constructor &amp; Copy Assignment Operator</a></li>
<li><a href="#orgfbedf8e">3.1.4. Copy-and-swap Idiom</a></li>
<li><a href="#org56fd1df">3.1.5. Move Constructor &amp; Move Assignment Opeartor</a></li>
<li><a href="#org8f68d03">3.1.6. explicit constructor</a></li>
<li><a href="#org522554f">3.1.7. initialization</a>
<ul>
<li><a href="#org59eeedd">3.1.7.1. Default Constructor</a></li>
<li><a href="#org22763c2">3.1.7.2. initialization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org20b6595">3.2. virtual</a>
<ul>
<li><a href="#org7845783">3.2.1. Bottom Line</a></li>
<li><a href="#org3dca51d">3.2.2. Description</a></li>
<li><a href="#orgf475dc0">3.2.3. Virtual vs. Non-Virtual</a></li>
<li><a href="#org4774abb">3.2.4. Virtual vs. Pure Virtual</a></li>
</ul>
</li>
<li><a href="#orgc7e8a1d">3.3. Inheritance</a>
<ul>
<li><a href="#org042abf7">3.3.1. public inheritance</a></li>
<li><a href="#org2b148f9">3.3.2. hide method</a></li>
<li><a href="#org563ebe9">3.3.3. make it visible</a></li>
</ul>
</li>
<li><a href="#org026d544">3.4. Overload</a></li>
<li><a href="#org9746160">3.5. Polymorphism</a>
<ul>
<li><a href="#orgb524043">3.5.1. Static Polymorphism</a></li>
</ul>
</li>
<li><a href="#org82b3499">3.6. non-member function</a>
<ul>
<li><a href="#org827ee07">3.6.1. A common pattern</a></li>
</ul>
</li>
<li><a href="#orgce2812f">3.7. friendship</a>
<ul>
<li><a href="#org04980d9">3.7.1. Friend function</a></li>
<li><a href="#org43085a0">3.7.2. Friend Class</a></li>
</ul>
</li>
<li><a href="#org90e0d39">3.8. Nested Class</a></li>
</ul>
</li>
<li><a href="#org02705f5">4. Concept</a>
<ul>
<li><a href="#orgf74f4f0">4.1. reference vs. value</a>
<ul>
<li><a href="#org0b27d92">4.1.1. Pass-by Problems</a></li>
<li><a href="#org89339cc">4.1.2. rvalue and lvalue</a>
<ul>
<li><a href="#org6b535cb">4.1.2.1. lvalue</a></li>
<li><a href="#org309bb55">4.1.2.2. rvalue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9110fda">4.2. rvalue reference</a>
<ul>
<li><a href="#org635bac1">4.2.1. The move semantic and swap</a></li>
<li><a href="#org4c5b6d9">4.2.2. Perfect Forwarding</a></li>
<li><a href="#org9937ded">4.2.3. Other properties</a></li>
</ul>
</li>
<li><a href="#org74cbe36">4.3. lambda</a>
<ul>
<li><a href="#org5472823">4.3.1. syntax</a></li>
<li><a href="#org5a2278b">4.3.2. Explanations</a></li>
</ul>
</li>
<li><a href="#orgec3b7bf">4.4. Smart Pointer</a></li>
<li><a href="#orgcc178cf">4.5. Exception Handling</a>
<ul>
<li><a href="#org9c8e2ce">4.5.1. Exception specification</a></li>
</ul>
</li>
<li><a href="#org6ca74a5">4.6. Template</a>
<ul>
<li><a href="#orge6a877f">4.6.1. Template specialization</a></li>
<li><a href="#org613fde8">4.6.2. Non-type parameter</a></li>
<li><a href="#org5acf43f">4.6.3. Template Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0ba11f1">5. Library</a>
<ul>
<li><a href="#orgaed1c43">5.1. Stream</a>
<ul>
<li><a href="#orgc59ebb0">5.1.1. file stream</a>
<ul>
<li><a href="#org12eb486">5.1.1.1. When to flush</a></li>
<li><a href="#org16bfc24">5.1.1.2. mode</a></li>
<li><a href="#org464bdd5">5.1.1.3. seek</a></li>
</ul>
</li>
<li><a href="#org047847b">5.1.2. iostream</a></li>
</ul>
</li>
<li><a href="#orgbd16caf">5.2. String</a>
<ul>
<li><a href="#org322c3c2">5.2.1. Constructor</a></li>
<li><a href="#org382d823">5.2.2. operator=</a></li>
<li><a href="#org195826b">5.2.3. handy routine</a>
<ul>
<li><a href="#org7d5e182">5.2.3.1. trim a string</a></li>
<li><a href="#org34bfe92">5.2.3.2. split a string</a></li>
<li><a href="#org9868874">5.2.3.3. better split string</a></li>
</ul>
</li>
<li><a href="#org9742d23">5.2.4. member function</a>
<ul>
<li><a href="#org9487729">5.2.4.1. iterator</a></li>
<li><a href="#org0afacfb">5.2.4.2. capacity</a></li>
<li><a href="#org2276023">5.2.4.3. access</a></li>
<li><a href="#org7a87943">5.2.4.4. mofifier</a></li>
<li><a href="#orgf932403">5.2.4.5. operation</a></li>
</ul>
</li>
<li><a href="#org2a0b33e">5.2.5. non-member function</a>
<ul>
<li><a href="#orgb6ef4dc">5.2.5.1. operator +</a></li>
<li><a href="#orgbed2fc2">5.2.5.2. rational</a></li>
<li><a href="#orge2629e2">5.2.5.3. &gt;&gt;</a></li>
<li><a href="#org9c0c06c">5.2.5.4. getline</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org321d195">6. Other</a>
<ul>
<li><a href="#orga687aef">6.1. Tips</a>
<ul>
<li><a href="#org72f1c74">6.1.1. function object</a></li>
<li><a href="#org2cc17e0">6.1.2. auto</a></li>
<li><a href="#orgd9a76e3">6.1.3. at</a></li>
<li><a href="#org1aa77cb">6.1.4. decltype</a></li>
<li><a href="#org23a6cec">6.1.5. pair</a></li>
</ul>
</li>
<li><a href="#orgbdd4b8c">6.2. constant</a>
<ul>
<li><a href="#orga4a590d">6.2.1. Rationale</a></li>
<li><a href="#org420afc2">6.2.2. How to use</a>
<ul>
<li><a href="#org0cdde5f">6.2.2.1. const</a></li>
<li><a href="#orgbdc9128">6.2.2.2. enums</a></li>
<li><a href="#org3d40cd0">6.2.2.3. inlines</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge4b35b4">6.3. undefined behavior</a></li>
<li><a href="#orgad0acac">6.4. Best Practices</a>
<ul>
<li><a href="#orgc56bcfe">6.4.1. compilation dependence</a>
<ul>
<li><a href="#orga046a84">6.4.1.1. Forward-declaration doesn't work.</a></li>
<li><a href="#org73ab5ef">6.4.1.2. Why Java don't have such problem?</a></li>
<li><a href="#org44c0d5c">6.4.1.3. Solution 1: pimpl(Pointer to implementation)</a></li>
<li><a href="#org4abe903">6.4.1.4. Solution 2: Interface Class</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org23c99b4">6.5. coding standards</a>
<ul>
<li><a href="#org19a38df">6.5.1. &lt;xxx&gt; and &lt;xxx.h&gt;</a></li>
<li><a href="#org1da1f64">6.5.2. using</a></li>
<li><a href="#org8443d30">6.5.3. where to declare variables</a></li>
<li><a href="#org7397c60">6.5.4. some lint-like guidelines</a></li>
<li><a href="#org54f6da0">6.5.5. some crazy unix abbr</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5811689">7. C++ Standards</a>
<ul>
<li><a href="#org4201916">7.1. C++11</a>
<ul>
<li><a href="#org0d83a72">7.1.1. Default and Delete</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgf55133b" class="outline-2">
<h2 id="orgf55133b"><span class="section-number-2">1</span> Idioms</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgcfabfdb" class="outline-3">
<h3 id="orgcfabfdb"><span class="section-number-3">1.1</span> Curiously recurring template pattern (CRTP)</h3>
<div class="outline-text-3" id="text-1-1">
<p>
a class X derives from a class template instantiation using X itself
as template argument.
</p>

<p>
General form:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #228b22;">tempalte</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Base</span> {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">methods of Base can access members of Derived</span>
};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Derived</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Base</span>&lt;<span style="color: #228b22;">Derived</span>&gt; {};
</pre>
</div>
</div>

<div id="outline-container-org77722d5" class="outline-4">
<h4 id="org77722d5"><span class="section-number-4">1.1.1</span> Static Polymorphism</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
It can achieve effect of virtual function but without the cost of
dynamic polymorphism.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Base</span> {
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">implementation</span>() {
    <span style="color: #a020f0;">static_cast</span>&lt;<span style="color: #228b22;">T</span>*&gt;(<span style="color: #a020f0;">this</span>)-&gt;implementation();
  }
  <span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">static_func</span>() {
    <span style="color: #008b8b;">T</span>::static_sub_func();
  }
};
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Derived</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Base</span>&lt;<span style="color: #228b22;">Derived</span>&gt; {
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">implementation</span>();
  <span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">static_sub_func</span>();
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org35c7e46" class="outline-4">
<h4 id="org35c7e46"><span class="section-number-4">1.1.2</span> Object Counter</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
<code>counter&lt;X&gt;</code> and <code>counter&lt;Y&gt;</code> are different class, so the counters are
separate for X and Y.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">counter</span> {
  <span style="color: #a020f0;">static</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">objects_created</span>;
  <span style="color: #a020f0;">static</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">objects_alive</span>;
  <span style="color: #0000ff;">counter</span>() {
    ++objects_created;
    ++objects_alive;
 }
  <span style="color: #0000ff;">counter</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">counter</span>&amp;) {
    ++objects_created;
    ++objects_alive;
  }
<span style="color: #a020f0;">protected</span>:
  ~<span style="color: #0000ff;">counter</span>() {
    -- objects_alive;
  }
};
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #228b22;">int</span> <span style="color: #008b8b;">counter</span>&lt;<span style="color: #228b22;">T</span>&gt;::<span style="color: #a0522d;">objects_created</span>(0);
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #228b22;">int</span> <span style="color: #008b8b;">counter</span>&lt;<span style="color: #228b22;">T</span>&gt;::<span style="color: #a0522d;">objects_alive</span>(0);

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">X</span> : <span style="color: #228b22;">counter</span>&lt;<span style="color: #228b22;">X</span>&gt; {};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Y</span> : <span style="color: #228b22;">counter</span>&lt;<span style="color: #228b22;">Y</span>&gt; {};
</pre>
</div>
</div>
</div>
<div id="outline-container-orge4c7935" class="outline-4">
<h4 id="orge4c7935"><span class="section-number-4">1.1.3</span> Polymorphic Copy Construction</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
When using polymorphism, one sometimes needs to create copies of
objects by the base class pointer. So a clone virtual function is
created in the base class, and defined in every derived classes. To
avoid duplication in the derived class:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Shape</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #a020f0;">virtual</span> ~<span style="color: #0000ff;">Shape</span>() {};
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">Shape</span> *<span style="color: #0000ff;">clone</span>() <span style="color: #a020f0;">const</span> = 0;
};
<span style="color: #b22222;">// </span><span style="color: #b22222;">CRTP class</span>
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Derived</span>&gt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Shape_CRTP</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Shape</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">Shape</span> *<span style="color: #0000ff;">clone</span>() <span style="color: #a020f0;">const</span> {
    <span style="color: #a020f0;">return</span> <span style="color: #a020f0;">new</span> <span style="color: #228b22;">Derived</span>(<span style="color: #a020f0;">static_cast</span>&lt;<span style="color: #228b22;">Derived</span> <span style="color: #a020f0;">const</span>&amp;&gt;(*<span style="color: #a020f0;">this</span>));
  }
};
<span style="color: #b22222;">// </span><span style="color: #b22222;">ensure correct usage</span>
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">Derive_Shape_CRTP</span>(<span style="color: #a0522d;">Type</span>) <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Type</span>: <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Shape_CRTP</span>(Type)
<span style="color: #b22222;">// </span><span style="color: #b22222;">usage</span>
<span style="color: #0000ff;">Derive_Shape_CRTP</span>(Square) {};
<span style="color: #0000ff;">Derive_Shape_CRTP</span>(Circle) {};

</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd4bab3b" class="outline-2">
<h2 id="orgd4bab3b"><span class="section-number-2">2</span> extern</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #483d8b;">#ifdef</span> __cplusplus
<span style="color: #a020f0;">extern</span> <span style="color: #8b2252;">"C"</span> {
<span style="color: #483d8b;">#endif</span>

<span style="color: #228b22;">char</span> *<span style="color: #0000ff;">strcpy</span>(<span style="color: #228b22;">char</span> *, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*);
<span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>

<span style="color: #483d8b;">#ifdef</span> __cplusplus
}
<span style="color: #483d8b;">#endif</span>
</pre>
</div>

<p>
<code>extern "C"</code> is used to use a C header file in a C++ project.
It is called linkage convention.
C++ supports overload, but C does not.
C++ typically add more to a function name.
If this is the case, C++ will not find the correct C library because it looks for a different name.
By using this, during the linkage, the compiler will look for the original name, i.e. using C linkage method.
</p>
</div>
</div>


<div id="outline-container-org401d0e1" class="outline-2">
<h2 id="org401d0e1"><span class="section-number-2">3</span> Class</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org3588ffd" class="outline-3">
<h3 id="org3588ffd"><span class="section-number-3">3.1</span> Constructor</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-orgdd9b82b" class="outline-4">
<h4 id="orgdd9b82b"><span class="section-number-4">3.1.1</span> auto-gen by compiler</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
If you don't write, the compiler will generate:
</p>

<ul class="org-ul">
<li>a copy constructor</li>
<li>a copy assignment operator</li>
<li>a destructor</li>
<li>a default constructor(if you defined no constructors at all)</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">class</span> <span style="color: #a0522d;">A</span> {
<span style="color: #008b8b;">public</span>:
  <span style="color: #0000ff;">A</span>() {...} <span style="color: #b22222;">// </span><span style="color: #b22222;">default</span>
  <span style="color: #0000ff;">A</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; rhs) {...} <span style="color: #b22222;">// </span><span style="color: #b22222;">copy</span>
  ~A() {...} <span style="color: #b22222;">// </span><span style="color: #b22222;">destructor</span>
  A&amp; operator=(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; rhs) {...} <span style="color: #b22222;">// </span><span style="color: #b22222;">copy assignment operator</span>
};
</pre>
</div>

<p>
But they are generated only if they are needed.
For the <code>operator=</code>, compiler will generate it iff:
</p>
<ul class="org-ul">
<li>resulting code is legal</li>
<li>reasonable to make sense</li>
</ul>
<p>
e.g.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">class</span> <span style="color: #a0522d;">A</span> {
<span style="color: #008b8b;">private</span>:
  std::string &amp;name;
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">num</span>;
};
</pre>
</div>
<p>
compiler will reject to generate <code>operator=</code> because when doing assignment,
should the reference be modified?
<span class="underline">C++ doesn't allow make a reference refer to another object.</span>
Should the referred string be modified? It will affect other objects!
It is not legal to modify a const member either.
If you want to support copy assignment in the class containing reference or const,
you must define it yourself.
</p>
</div>
</div>

<div id="outline-container-org8bcc076" class="outline-4">
<h4 id="org8bcc076"><span class="section-number-4">3.1.2</span> explicitly disallow the auto-gen</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
<i>link time solution</i>:
 Declare the copy constructor and the copy assignment operator private.
 So that compiler will not generate, outside can not see them.
 However, member and friend functions can still call them.
</p>

<p>
<i>compile time solution</i>:
Inheritate from <code>Uncopyable</code> class who declared but didn't define the copy constructor and assginment operator.
This works because the compiler will try to
generate copy constructor and copy assignment when anybody tries to copy it,
but will of course fail.
It will give error says no instance of copy instructor implemented,
in other word you can't pass compilation.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Uncopyable</span> {
<span style="color: #a020f0;">protected</span>:
  <span style="color: #0000ff;">Uncopyable</span>() {}
  ~<span style="color: #0000ff;">Uncopyable</span>() {}
<span style="color: #a020f0;">private</span>:
  <span style="color: #0000ff;">Uncopyable</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Uncopyable</span>&amp;);
  <span style="color: #228b22;">Uncopyable</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Uncopyable</span>&amp;);
};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">A</span> : <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Uncopyable</span> {}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4b4f4a1" class="outline-4">
<h4 id="org4b4f4a1"><span class="section-number-4">3.1.3</span> Copy Constructor &amp; Copy Assignment Operator</h4>
<div class="outline-text-4" id="text-3-1-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">A</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #0000ff;">A</span>();
  <span style="color: #0000ff;">A</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">rhs</span>); <span style="color: #b22222;">// </span><span style="color: #b22222;">copy constructor</span>
  <span style="color: #228b22;">A</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">rhs</span>) { <span style="color: #b22222;">// </span><span style="color: #b22222;">copy assignment operator</span>
    <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">should return *this</span>
  }
};

<span style="color: #228b22;">A</span> <span style="color: #a0522d;">a1</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">default constructor</span>
<span style="color: #228b22;">A</span> <span style="color: #0000ff;">a2</span>(a1); <span style="color: #b22222;">// </span><span style="color: #b22222;">copy constructor</span>
a1 = a2; <span style="color: #b22222;">// </span><span style="color: #b22222;">copy assignment operator</span>
<span style="color: #228b22;">A</span> <span style="color: #a0522d;">a3</span> = a2; <span style="color: #b22222;">// </span><span style="color: #b22222;">copy constructor</span>
</pre>
</div>

<p>
if new object is being defined, a constructor has to be called.
That's why <code>a3</code> is not calling a copy assignment operator.
</p>

<p>
copy constructor matters because it defines how an object is <b><b>passed by value</b></b>.
In particular, pass-by-value means "call the copy constructor".
</p>
</div>
</div>

<div id="outline-container-orgfbedf8e" class="outline-4">
<h4 id="orgfbedf8e"><span class="section-number-4">3.1.4</span> Copy-and-swap Idiom</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
To create an exception safe implementation of overloaded assignment operator.
The copy assignment opeartor implementation can cause two kinds of unsafety:
</p>
<ul class="org-ul">
<li>self-assignment unsafe</li>
<li>exception unsafe</li>
</ul>

<p>
Self-assignment should be properly handled.
It can appear often, e.g.
<code>a[i] = a[j];</code> in the case i=j,
<code>*px = *py;</code>.
</p>

<p>
The following code explain the two kinds of unsafe.
</p>
<ul class="org-ul">
<li>self-assignment unsafe:
<code>rhs.pa</code> is already deleted if <code>rhs == this</code></li>
<li>exception unsafe:
if exception happens during new, pa will contains a pointer to a deleted A.</li>
</ul>


<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">A</span> {};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">B</span> {
 <span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">A</span> * <span style="color: #a0522d;">pa</span>;
};
<span style="color: #228b22;">B</span>&amp; <span style="color: #008b8b;">B</span>::<span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">B</span>&amp; <span style="color: #a0522d;">rhs</span>) {
  <span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">this</span> == &amp;rhs) <span style="color: #a020f0;">return</span> * <span style="color: #a020f0;">this</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">get rid of self-assignment unsafe</span>
  <span style="color: #a020f0;">delete</span> pa;
  pa = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">A</span>(* rhs.pa);
  <span style="color: #a020f0;">return</span> * <span style="color: #a020f0;">this</span>;
}
</pre>
</div>

<p>
According to <a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap">https://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap</a>, the copy and swap is:
</p>
<blockquote>
<p>
Create a temporary and swap idiom acquires new resource before it forfeits its current resource.
To acquire the new resource, it uses RAII idiom.
If the acquisition of the new resource is successful, it exchanges the resources using the non-throwing swap idiom.
Finally, the old resource is released as a side effect of using RAII in the first step.
</p>
</blockquote>
<p>
The code follows:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">B</span> {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">use std::swap?</span>
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">swap</span>(<span style="color: #228b22;">B</span>&amp; <span style="color: #a0522d;">rhs</span>) {
    <span style="color: #008b8b;">std</span>::swap(xx,rhs.xx);
  }
};
<span style="color: #b22222;">// </span><span style="color: #b22222;">v1: explicitly create new. BAD</span>
<span style="color: #228b22;">B</span>&amp; <span style="color: #008b8b;">B</span>::<span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">B</span>&amp; <span style="color: #a0522d;">rhs</span>) {
  <span style="color: #228b22;">B</span> <span style="color: #0000ff;">tmp</span>(rhs);
  swap(tmp);
  <span style="color: #a020f0;">return</span> * <span style="color: #a020f0;">this</span>;
}
<span style="color: #b22222;">// </span><span style="color: #b22222;">v2: use pass-by-value as temporary value. GOOD.</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">better optimization</span>
<span style="color: #228b22;">B</span>&amp; <span style="color: #008b8b;">B</span>::<span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span>(<span style="color: #228b22;">B</span> <span style="color: #a0522d;">rhs</span>) {
  swap(rhs);
  <span style="color: #a020f0;">return</span> * <span style="color: #a020f0;">this</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org56fd1df" class="outline-4">
<h4 id="org56fd1df"><span class="section-number-4">3.1.5</span> Move Constructor &amp; Move Assignment Opeartor</h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
Move constructor enables you to implement move semantics, which can significantly improve the performance of your applications.
Move semantics enables you to write code that transfers resources (such as dynamically allocated memory) from one object to another.
Move semantics works because it enables resources to be transferred from temporary objects that cannot be referenced elsewhere in the program.
</p>

<p>
To implement move semantics, you typically provide a move constructor, and optionally a move assignment operator (operator=), to your class.
Copy and assignment operations whose sources are rvalues then automatically take advantage of move semantics.
Reference: <a href="https://msdn.microsoft.com/en-us/library/dd293665.aspx">Move Constructors and Move Assignment Operators</a> from Microsoft.
</p>

<p>
Move Constructor Example:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">Rvalue Reference</span>
<span style="color: #0000ff;">MemoryBlock</span>(<span style="color: #228b22;">MemoryBlock</span>&amp;&amp; <span style="color: #a0522d;">other</span>) : _data(<span style="color: #008b8b;">nullptr</span>) , _length(0) {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">copy</span>
  _data = other._data;
  _length = other._length;
  <span style="color: #b22222;">// </span><span style="color: #b22222;">set source object fields to default, to avoid multiple free</span>
  other._data = <span style="color: #008b8b;">nullptr</span>;
  other._length = 0;
}
</pre>
</div>

<p>
Move Assignment Operator Example:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">MemoryBlock</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span>(<span style="color: #228b22;">MemoryBlock</span>&amp;&amp; <span style="color: #a0522d;">other</span>) {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">avoid self-assignment</span>
  <span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">this</span> != &amp;other) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Free the existing resource.</span>
    <span style="color: #a020f0;">delete</span>[] _data;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Copy the data pointer and its length from the </span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">source object.</span>
    _data = other._data;
    _length = other._length;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Release the data pointer from the source object so that</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">the destructor does not free the memory multiple times.</span>
    other._data = <span style="color: #008b8b;">nullptr</span>;
    other._length = 0;
  }
  <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f68d03" class="outline-4">
<h4 id="org8f68d03"><span class="section-number-4">3.1.6</span> explicit constructor</h4>
<div class="outline-text-4" id="text-3-1-6">
<p>
The explicit prevents the class from being used to perform implicit type conversions,
though they may still be used for explicit type conversions.
Always declare it explicit unless you have a good reason
for allowing a constructor to be used for implicit type conversions.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">A</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">A</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>=0, <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span>=<span style="color: #008b8b;">true</span>);
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">A</span>(<span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>); <span style="color: #b22222;">// </span><span style="color: #b22222;">non-default can also have explicit</span>
};
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">func</span>(<span style="color: #228b22;">A</span> <span style="color: #a0522d;">a</span>);

<span style="color: #228b22;">A</span> <span style="color: #a0522d;">a1</span>;
func(a1); <span style="color: #b22222;">// </span><span style="color: #b22222;">ok</span>
<span style="color: #228b22;">A</span> <span style="color: #a0522d;">a2</span>(20); <span style="color: #b22222;">// </span><span style="color: #b22222;">ok</span>
func(20); <span style="color: #b22222;">// </span><span style="color: #b22222;">error, cannot convert int to A implicitly</span>
func(A(20)); <span style="color: #b22222;">// </span><span style="color: #b22222;">use B constructor to explicit convert</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org522554f" class="outline-4">
<h4 id="org522554f"><span class="section-number-4">3.1.7</span> initialization</h4>
<div class="outline-text-4" id="text-3-1-7">
</div>
<div id="outline-container-org59eeedd" class="outline-5">
<h5 id="org59eeedd"><span class="section-number-5">3.1.7.1</span> Default Constructor</h5>
<div class="outline-text-5" id="text-3-1-7-1">
<p>
One that can be called <i>without any arguments</i> is called <i>default constructor</i>.
Compilers will automatically call default constructors
for data members of user-defined types
when those data members are not on initialization list.
</p>
</div>
</div>
<div id="outline-container-org22763c2" class="outline-5">
<h5 id="org22763c2"><span class="section-number-5">3.1.7.2</span> initialization</h5>
<div class="outline-text-5" id="text-3-1-7-2">
<p>
Data members that are const or references must be initialized; they cant be assigned.
Do <i>NOT</i> call constructors within each other.
If init is too many, move them into a private function,
and call the function in all constructors.
</p>

<p>
The initialization orders are defined by:
Base classes are initialized before derived classes;
within a class, data members are initialized in the order in which they declared,
not the position in initialization list.
</p>

<p>
I did a test for the copy constructor:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;iostream&gt;</span>

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">A</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #0000ff;">A</span>() {}
  ~<span style="color: #0000ff;">A</span>() {}
  <span style="color: #228b22;">int</span> <span style="color: #0000ff;">get</span>() {<span style="color: #a020f0;">return</span> a;}
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">set</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">aa</span>) {
    a = aa;
  }
<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span> = 8;
};

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
  <span style="color: #228b22;">A</span> *<span style="color: #a0522d;">a</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">A</span>();
  a-&gt;set(9);
  <span style="color: #228b22;">A</span> *<span style="color: #a0522d;">b</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">A</span>(*a);
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; a-&gt;get()  &lt;&lt; <span style="color: #8b2252;">"\n"</span>;
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; b-&gt;get() &lt;&lt; <span style="color: #8b2252;">"\n"</span>;
}
</pre>
</div>

<p>
Both the outputs are 9, so the initialization <code>a=8</code> is not called when doing copy construction
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org20b6595" class="outline-3">
<h3 id="org20b6595"><span class="section-number-3">3.2</span> virtual</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org7845783" class="outline-4">
<h4 id="org7845783"><span class="section-number-4">3.2.1</span> Bottom Line</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>polymorphic base classes should declare virtual destructors.
If a class has virtual functions, it should have virtual destructor</li>
<li>Classes should not have virtual destructor if it is not designed to be
<ul class="org-ul">
<li>base class, or</li>
<li>used polymorphically</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3dca51d" class="outline-4">
<h4 id="org3dca51d"><span class="section-number-4">3.2.2</span> Description</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
<code>Factory Function</code>:
a function that returns a base class pointer
to a newly-created derived class object.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">TimeKeeper</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #0000ff;">TimeKeeper</span>();
  <span style="color: #a020f0;">virtual</span> ~<span style="color: #0000ff;">TimeKeeper</span>(); <span style="color: #b22222;">// </span><span style="color: #b22222;">must have the virtual, or disaster</span>
};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">AtomicClock</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">TimeKeeper</span> {};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">WaterClock</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">TimeKeeper</span> {};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">WristWatch</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">TimeKeeper</span> {};

<span style="color: #228b22;">TimeKeeper</span> *<span style="color: #0000ff;">getTimeKeeper</span>(); <span style="color: #b22222;">// </span><span style="color: #b22222;">can return any one</span>

<span style="color: #228b22;">TimeKeeper</span> *<span style="color: #a0522d;">ptk</span> = getTimeKeeper();
<span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>
<span style="color: #a020f0;">delete</span> ptk;
</pre>
</div>

<p>
If no virtual, the <code>delete ptk</code> will call the destructor of TimeKeeper,
so the AtomicClock part of the struct will be never destroyed.
</p>

<p>
But do not declare every destructor virtual:
If a class does not contain virtual functions,
it is not meant to be used as a base class.
DO NOT use virtual destructor for it. Because:
</p>

<ul class="org-ul">
<li>virtual requires the objects carry information that can be used at runtime to determine which virtual function to invoke. It will increase the size.</li>
<li>it is not the same as the counterpart in C, not portable.</li>
</ul>

<p>
Never call virtual functions during construction or destruction.
Because during base construction,
virtual functions never go down into the derived class.
</p>
</div>
</div>

<div id="outline-container-orgf475dc0" class="outline-4">
<h4 id="orgf475dc0"><span class="section-number-4">3.2.3</span> Virtual vs. Non-Virtual</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Without <code>virtual</code> you get <b><b>early binding</b></b>. Which implementation of the method is used gets decided at <b><b>compile time based on the type of the pointer that you call through</b></b>.
</p>

<p>
With <code>virtual</code> you get <b><b>late binding</b></b>. Which implementation of the method is used gets decided at <b><b>run time based on the type of the pointed-to object</b></b> - what it was originally constructed as. This is not necessarily what you'd think based on the type of the pointer that points to that object.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Base</span>
{
<span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">Method1</span> ()  {  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"Base::Method1"</span> &lt;&lt; <span style="color: #008b8b;">std</span>::endl;  }
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">Method2</span> ()  {  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"Base::Method2"</span> &lt;&lt; <span style="color: #008b8b;">std</span>::endl;  }
};

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Derived</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Base</span>
{
<span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">Method1</span> ()  {  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"Derived::Method1"</span> &lt;&lt; <span style="color: #008b8b;">std</span>::endl;  }
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">Method2</span> ()  {  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"Derived::Method2"</span> &lt;&lt; <span style="color: #008b8b;">std</span>::endl;  }
};

<span style="color: #228b22;">Base</span>* <span style="color: #a0522d;">obj</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">Derived</span> ();
<span style="color: #b22222;">//  </span><span style="color: #b22222;">Note - constructed as Derived, but pointer stored as Base*</span>

obj-&gt;Method1 ();  <span style="color: #b22222;">//  </span><span style="color: #b22222;">Prints "Base::Method1"</span>
obj-&gt;Method2 ();  <span style="color: #b22222;">//  </span><span style="color: #b22222;">Prints "Derived::Method2"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4774abb" class="outline-4">
<h4 id="org4774abb"><span class="section-number-4">3.2.4</span> Virtual vs. Pure Virtual</h4>
<div class="outline-text-4" id="text-3-2-4">
<ul class="org-ul">
<li>virtual function <code>can</code> be overriden</li>
<li>the pure virtual <code>must</code> be implemented in non-abstract class</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc7e8a1d" class="outline-3">
<h3 id="orgc7e8a1d"><span class="section-number-3">3.3</span> Inheritance</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org042abf7" class="outline-4">
<h4 id="org042abf7"><span class="section-number-4">3.3.1</span> public inheritance</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
"is-a" relation.
</p>

<p>
Private inheritance means "is-implemented-in-terms-of".
Private inheritance means nothing during software design,
only during software implementation.
Means Derived objects are implemented in terms of Base objects, nothing more.
</p>

<p>
Composition means either "has-a" or "is-implementated-in-terms-of".
</p>
</div>
</div>

<div id="outline-container-org2b148f9" class="outline-4">
<h4 id="org2b148f9"><span class="section-number-4">3.3.2</span> hide method</h4>
<div class="outline-text-4" id="text-3-3-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Base</span> {
<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>;
<span style="color: #a020f0;">public</span>:
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">mf1</span>() = 0;
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">mf1</span>(<span style="color: #228b22;">int</span>);

  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">mf2</span>();

  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">mf3</span>();
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">mf3</span>(<span style="color: #228b22;">double</span>);
};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Derived</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Base</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #b22222;">// </span><span style="color: #b22222;">using Base::mf1; // making all things in Base named mf1 and mf3</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">using Base::mf3; // visible and public in Derived's scope</span>
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">mf2</span>() {  <span style="color: #b22222;">// </span><span style="color: #b22222;">forwarding function</span>
    <span style="color: #008b8b;">Base</span>::mf1();
  }
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">mf1</span>();
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">mf3</span>();
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">mf4</span>();
};
</pre>
</div>

<p>
the <code>mf3</code> in Derived will hide both of the <code>mf3</code> in Base.
The rationale behind this behavior is that
it prevents you from accidentally inheriting overloads from distant base classes
when you create a new derived class in a library or application framework.
</p>
</div>
</div>

<div id="outline-container-org563ebe9" class="outline-4">
<h4 id="org563ebe9"><span class="section-number-4">3.3.3</span> make it visible</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li><code>using</code> declarations</li>
<li>forwarding functions</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org026d544" class="outline-3">
<h3 id="org026d544"><span class="section-number-3">3.4</span> Overload</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Same name but different signature.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">print</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>) {
  cout &lt;&lt; <span style="color: #8b2252;">"Printing int: "</span> &lt;&lt; i &lt;&lt; endl;
}
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">print</span>(<span style="color: #228b22;">double</span>  <span style="color: #a0522d;">f</span>) {
  cout &lt;&lt; <span style="color: #8b2252;">"Printing float: "</span> &lt;&lt; f &lt;&lt; endl;
}
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">print</span>(<span style="color: #228b22;">char</span>* <span style="color: #a0522d;">c</span>) {
  cout &lt;&lt; <span style="color: #8b2252;">"Printing character: "</span> &lt;&lt; c &lt;&lt; endl;
}
</pre>
</div>

<p>
Operator Overload
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">inline</span> <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">==</span>(<span style="color: #228b22;">Date</span> <span style="color: #a0522d;">a</span>, <span style="color: #228b22;">Data</span> <span style="color: #a0522d;">b</span>) {
  <span style="color: #a020f0;">return</span> a.day() == b.day() &amp;&amp; a.month() == b.month() &amp;&amp; a.year() == b.year();
}

<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">!=</span>(<span style="color: #228b22;">Date</span>, <span style="color: #228b22;">Date</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;</span>(<span style="color: #228b22;">Date</span>, <span style="color: #228b22;">Date</span>)
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;</span>(<span style="color: #228b22;">Date</span>, <span style="color: #228b22;">Date</span>)

<span style="color: #228b22;">Date</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">++</span>(<span style="color: #228b22;">Date</span> &amp;<span style="color: #a0522d;">d</span>);
<span style="color: #228b22;">Date</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">--</span>(<span style="color: #228b22;">Date</span> &amp;<span style="color: #a0522d;">d</span>);
<span style="color: #228b22;">Date</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+=</span>(<span style="color: #228b22;">Date</span> &amp;<span style="color: #a0522d;">d</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">n</span>);
<span style="color: #228b22;">Date</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">-=</span>(<span style="color: #228b22;">Date</span> &amp;<span style="color: #a0522d;">d</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">n</span>);

<span style="color: #228b22;">Date</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span>(<span style="color: #228b22;">Date</span> <span style="color: #a0522d;">d</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">n</span>);
<span style="color: #228b22;">Date</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">-</span>(<span style="color: #228b22;">Date</span> <span style="color: #a0522d;">d</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">n</span>);

<span style="color: #228b22;">ostream</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;&lt;</span>(<span style="color: #228b22;">ostream</span>&amp;, <span style="color: #228b22;">Date</span> <span style="color: #a0522d;">d</span>);
<span style="color: #228b22;">istream</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;&gt;</span>(<span style="color: #228b22;">istream</span>&amp;, <span style="color: #228b22;">Date</span> &amp;<span style="color: #a0522d;">d</span>);
</pre>
</div>
</div>
</div>


<div id="outline-container-org9746160" class="outline-3">
<h3 id="org9746160"><span class="section-number-3">3.5</span> Polymorphism</h3>
<div class="outline-text-3" id="text-3-5">
<p>
It is the ability to redefine methods for derived classes.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Polygon</span> {
<span style="color: #a020f0;">protected</span>:
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">width</span>, <span style="color: #a0522d;">height</span>;
<span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">set_values</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">b</span>)
  { width=a; height=b; }
};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Rectangle</span>: <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Polygon</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">int</span> <span style="color: #0000ff;">area</span>()
  { <span style="color: #a020f0;">return</span> width*height; }
};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Triangle</span>: <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Polygon</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">int</span> <span style="color: #0000ff;">area</span>()
  { <span style="color: #a020f0;">return</span> width*height/2; }
};
</pre>
</div>
</div>

<div id="outline-container-orgb524043" class="outline-4">
<h4 id="orgb524043"><span class="section-number-4">3.5.1</span> Static Polymorphism</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
 The <i>Curiously Recurring Template Pattern (CRTP)</i> is an idiom in C++ in which a class X derives from a class template instantiation using X itself as template argument<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.
It is also known as <i>F-bound polymorphism</i>\cite{canning1989f}.
 One of the use case of CRTP is static polymorphism.
 Generally speaking, I have a base class and some derived class,
 and I want to have a ~~static virtual'' function that is implemented differently in different subclasses.
 I think such ~~static virtual function'' does not exist.
 But we can simulate it.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>&gt; 
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Base</span> {
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">interface</span>() {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>
    <span style="color: #a020f0;">static_cast</span>&lt;<span style="color: #228b22;">T</span>*&gt;(<span style="color: #a020f0;">this</span>)-&gt;implementation();
    <span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>
  } 
  <span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">static_func</span>() {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>
    <span style="color: #008b8b;">T</span>::static_sub_func();
    <span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>
  }
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Derived</span> : <span style="color: #228b22;">Base</span>&lt;<span style="color: #228b22;">Derived</span>&gt; {
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">implementation</span>();
  <span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">static_sub_func</span>();
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org82b3499" class="outline-3">
<h3 id="org82b3499"><span class="section-number-3">3.6</span> non-member function</h3>
<div class="outline-text-3" id="text-3-6">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">clearBrowser</span>(<span style="color: #228b22;">WebBrowser</span>&amp; <span style="color: #a0522d;">wb</span>) {
  wb.clearCache();
  wb.clearHistory();
  wb.removeCookies();
}
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">WebBrowser</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">clearCache</span>();
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">clearHistory</span>();
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">removeCookies</span>();
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">clearEverything</span>();
};
</pre>
</div>

<p>
Prefer use the non-member function,
because then less function can have access to private data,
thus better encapsulate.
</p>
</div>

<div id="outline-container-org827ee07" class="outline-4">
<h4 id="org827ee07"><span class="section-number-4">3.6.1</span> A common pattern</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
Putting all convenience functions in multiple header files,
but one namespace.
</p>

<p>
<code>webbrowser.h</code>
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">namespace</span> <span style="color: #008b8b;">WebBrowserStuff</span> {
  <span style="color: #a020f0;">class</span> <span style="color: #228b22;">WebBrowser</span> {...};
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">clearBrowser</span>(<span style="color: #228b22;">WebBrowser</span>&amp; <span style="color: #a0522d;">wb</span>);
  <span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>
}
</pre>
</div>

<p>
<code>webbrowserbookmarks.h</code>
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">namespace</span> <span style="color: #008b8b;">WebBrowserStuff</span> {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">bookmark related functions</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgce2812f" class="outline-3">
<h3 id="orgce2812f"><span class="section-number-3">3.7</span> friendship</h3>
<div class="outline-text-3" id="text-3-7">
</div>
<div id="outline-container-org04980d9" class="outline-4">
<h4 id="org04980d9"><span class="section-number-4">3.7.1</span> Friend function</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
private and protected member cannot be accessed outside the class, except friends.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">A</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #a020f0;">friend</span> <span style="color: #228b22;">A</span> <span style="color: #0000ff;">func</span>(<span style="color: #228b22;">A</span> <span style="color: #a0522d;">a</span>); <span style="color: #b22222;">// </span><span style="color: #b22222;">declare friend</span>
<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">m</span>;
};
<span style="color: #228b22;">A</span> <span style="color: #0000ff;">func</span>(<span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">a</span>) {
  <span style="color: #228b22;">A</span> <span style="color: #a0522d;">res</span>;
  res.m = a.m; <span style="color: #b22222;">// </span><span style="color: #b22222;">access both param and return value</span>
  <span style="color: #a020f0;">return</span> res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org43085a0" class="outline-4">
<h4 id="org43085a0"><span class="section-number-4">3.7.2</span> Friend Class</h4>
<div class="outline-text-4" id="text-3-7-2">
<p>
a class whose member functions can access private and protected member of another class.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Rectangle</span> {
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">width</span>, <span style="color: #a0522d;">height</span>;
<span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">int</span> <span style="color: #0000ff;">area</span> () {}
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">convert</span> (<span style="color: #228b22;">Square</span> <span style="color: #a0522d;">a</span>) {
    width = a.side; <span style="color: #b22222;">// </span><span style="color: #b22222;">access side in Square</span>
    height = a.side;
  }
};

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Square</span> {
  <span style="color: #a020f0;">friend</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Rectangle</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">friend declaration</span>
<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">side</span>;
<span style="color: #a020f0;">public</span>:
  <span style="color: #0000ff;">Square</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span>) : side(a) {}
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org90e0d39" class="outline-3">
<h3 id="org90e0d39"><span class="section-number-3">3.8</span> Nested Class</h3>
<div class="outline-text-3" id="text-3-8">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">class</span> <span style="color: #a0522d;">enclose</span> {
    <span style="color: #228b22;">class</span> <span style="color: #a0522d;">nested1</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">forward declaration</span>
    <span style="color: #228b22;">class</span> <span style="color: #a0522d;">nested2</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">forward declaration</span>
    <span style="color: #228b22;">class</span> <span style="color: #a0522d;">nested1</span> {}; <span style="color: #b22222;">// </span><span style="color: #b22222;">definition of nested class</span>
};
<span style="color: #228b22;">class</span> <span style="color: #a0522d;">enclose</span>::nested2 { }; <span style="color: #b22222;">// </span><span style="color: #b22222;">definition of nested class</span>
</pre>
</div>

<ul class="org-ul">
<li>The nested class can access private and protected member of the enclosing class, but have separate <code>this</code> pointer.</li>
<li>The friend of the nested class cannot access private and protected member of the enclosing class.</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org02705f5" class="outline-2">
<h2 id="org02705f5"><span class="section-number-2">4</span> Concept</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgf74f4f0" class="outline-3">
<h3 id="orgf74f4f0"><span class="section-number-3">4.1</span> reference vs. value</h3>
<div class="outline-text-3" id="text-4-1">
<p>
A good writeup: <a href="http://thbecker.net/articles/rvalue_references/section_01.html">http://thbecker.net/articles/rvalue_references/section_01.html</a>
</p>

<p>
The original definition for C:
</p>
<blockquote>
<p>
An lvalue is an expression e that may appear on the left or on the right hand side of an assignment,
whereas an rvalue is an expression that can only appear on the right hand side of an assignment.
</p>
</blockquote>

<p>
The changed definition for C++:
</p>
<blockquote>
<p>
An lvalue is an expression that refers to a memory location and allows us to take the address of that memory location via the &amp; operator.
An rvalue is an expression that is not an lvalue.
</p>
</blockquote>
</div>

<div id="outline-container-org0b27d92" class="outline-4">
<h4 id="org0b27d92"><span class="section-number-4">4.1.1</span> Pass-by Problems</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
Pass-by-value has two problems.
Apart from copy problem, there's also a slicing problem,
i.e. when a derived class object is passed by value as a base class object,
the base class constructor is called,
thus the part of the subclass outside the base class will be sliced away.
</p>

<p>
Also do <i>NOT</i> just pass by value because the struct seems to be small.
</p>
<ul class="org-ul">
<li>it can be large, by inheritance</li>
<li>the copy constructor may be costly: a object contain little more than a pointer, but the constructor will copy everything they point to.</li>
<li>some compiler treat built-in type and structure differently.
Some will refuse to put a struct that only contains a double into register,
but it will surely put a double into register.</li>
</ul>
<p>
So some situation pass by value is more efficient though:
</p>
<ul class="org-ul">
<li>built-in type(e.g. int)</li>
<li>iterators and function objects in STL, they are designed to pass by value</li>
</ul>

<p>
On the other hand, reference is often implemented as pointer.
However, there're situations where you have no way but to return a value.
Return a stack local variable as a reference does not make sense becasue the variable will not exist outside the function.
When you return a heap variable, be careful. E.g. in a <code>operator*</code> method, return a heap variable is a disaster.
<code>w = x * y * z;</code> the result of <code>x*y</code> will never be free-d.
</p>
</div>
</div>
<div id="outline-container-org89339cc" class="outline-4">
<h4 id="org89339cc"><span class="section-number-4">4.1.2</span> rvalue and lvalue</h4>
<div class="outline-text-4" id="text-4-1-2">
<div class="org-src-container">
<pre class="src src-text">    ______ ______
  /       X      \
 /       / \      \
|   l   | x |  pr  |
 \       \ /      /
  \______ X______/
      gl    r
</pre>
</div>
</div>
<div id="outline-container-org6b535cb" class="outline-5">
<h5 id="org6b535cb"><span class="section-number-5">4.1.2.1</span> lvalue</h5>
<div class="outline-text-5" id="text-4-1-2-1">
<p>
An <i>lvalue</i> is an expression that identifies a non-temporary object or a non-member function.
</p>
<ul class="org-ul">
<li>The name of a variable or function in scope</li>
<li>Function call or overloaded operator expression if the function's or overloaded operator's return type is an lvalue reference</li>
<li>string literal</li>
</ul>
<p>
A <i>glvalue</i> (~~generalized'' lvalue) is an lvalue or an xvalue.
</p>
</div>
</div>
<div id="outline-container-org309bb55" class="outline-5">
<h5 id="org309bb55"><span class="section-number-5">4.1.2.2</span> rvalue</h5>
<div class="outline-text-5" id="text-4-1-2-2">
<p>
An <i>rvalue</i> is an expression that is either a prvalue or an xvalue.
A <i>prvalue</i> (~~pure'' rvalue) is an rvalue that is not an xvalue.
</p>
</div>
<ol class="org-ol">
<li><a id="org74232a0"></a>prvalue<br />
<div class="outline-text-6" id="text-4-1-2-2-1">
<p>
A prvalue ("pure" rvalue) is an expression that identifies a temporary object (or a subobject thereof)
or is a value not associated with any object.
</p>
<ul class="org-ul">
<li>literal(except string literal): 42, true</li>
<li>the result of calling a function whose return type is not a reference is a prvalue.</li>
</ul>
</div>
</li>
<li><a id="org8f391cb"></a>xvalue<br />
<div class="outline-text-6" id="text-4-1-2-2-2">
<p>
An <code>xvalue</code> (an eXpiring value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example).
An xvalue is the result of certain kinds of expressions involving rvalue references.
E.g. the result of calling a function whose return type is an rvalue reference is an xvalue.
</p>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org9110fda" class="outline-3">
<h3 id="org9110fda"><span class="section-number-3">4.2</span> rvalue reference</h3>
<div class="outline-text-3" id="text-4-2">
<p>
C++11 introduce <i>ravlue reference</i> to enable <i>move semantic</i>.
std::vector&lt;T&gt; is essentially a C-style array and the size.
Say a std::vector&lt;T&gt; temporary is created or returned from a function.
To accept the return value, a new vector should be created, and all the internal C-array will be copied.
When using a <i>move constructor</i>,
it takes the rvalue reference of the temporary vector (<code>vector&lt;&gt;&amp;&amp;</code>),
and copy the <i>pointer</i> to the internal C-style array <i>out of</i> the rvalue into the new vector,
than set the pointer inside the temporary vector to NULL.
Since the temporary vector is about to expire, and no one would use it any more,
it is safe.
And since the pointer is NULL, no space will be freed upon deconstructing the temporay vector.
</p>

<p>
Rvalue Reference is important because it supports the implementation of <i>move constructor</i> (enable move semantic) and <i>perfect forwarding</i>.
We discuss perfect forwarding here.
</p>
</div>

<div id="outline-container-org635bac1" class="outline-4">
<h4 id="org635bac1"><span class="section-number-4">4.2.1</span> The move semantic and swap</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">remove_reference</span>&lt;<span style="color: #228b22;">T</span>&gt;::<span style="color: #228b22;">type</span>&amp;&amp; <span style="color: #0000ff;">move</span> (<span style="color: #228b22;">T</span>&amp;&amp; <span style="color: #a0522d;">arg</span>) <span style="color: #a020f0;">noexcept</span>;

<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #228b22;">void</span> <span style="color: #0000ff;">swap</span> (<span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">a</span>, <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">b</span>)
{
  <span style="color: #228b22;">T</span> <span style="color: #0000ff;">c</span>(<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">move</span>(<span style="color: #a0522d;">a</span>)); a=<span style="color: #008b8b;">std</span>::move(b); b=<span style="color: #008b8b;">std</span>::move(c);
}
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span>&gt; <span style="color: #228b22;">void</span> <span style="color: #0000ff;">swap</span> (<span style="color: #228b22;">T</span> &amp;<span style="color: #a0522d;">a</span>[N], <span style="color: #228b22;">T</span> &amp;<span style="color: #a0522d;">b</span>[N])
{
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i&lt;N; ++i) swap (a[i],b[i]);
}
</pre>
</div>

<p>
Example
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">move takes an object, invalidate it, and return the rvalue.</span>
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">bar</span> = <span style="color: #8b2252;">"bar-string"</span>;
myvector.push_back (<span style="color: #008b8b;">std</span>::move(bar));
<span style="color: #b22222;">// </span><span style="color: #b22222;">Now bar is valid but has no valid content, while the vector contains the string.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4c5b6d9" class="outline-4">
<h4 id="org4c5b6d9"><span class="section-number-4">4.2.2</span> Perfect Forwarding</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
Perfect forwarding reduces the need for overloaded functions and helps avoid the forwarding problem.
The forwarding problem can occur when you write a generic function that takes references as its parameters and it passes (or forwards) these parameters to another function.
For example, if the generic function takes a parameter of type const T&amp;, then the called function cannot modify the value of that parameter.
If the generic function takes a parameter of type T&amp;, then the function cannot be called by using an rvalue (such as a temporary object or integer literal).
</p>

<p>
Ordinarily, to solve this problem, you must provide overloaded versions of the generic function that take both T&amp; and const T&amp; for each of its parameters.
As a result, the number of overloaded functions increases exponentially with the number of parameters.
(For instance the following code, to write a generic <code>factory</code> function,
we need to try all combination of <code>const T&amp;</code> and <code>T&amp;</code> for every type pair of <code>W,X,Y,Z</code>).
Rvalue references enable you to write one version of a function that accepts arbitrary arguments
and forwards them to another function as if the other function had been called directly.
</p>

<p>
For example, following code
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">W</span> {
  <span style="color: #0000ff;">W</span>(<span style="color: #228b22;">int</span>&amp;, <span style="color: #228b22;">int</span>&amp;) {}
};
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">X</span> {
  <span style="color: #0000ff;">X</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span>&amp;, <span style="color: #228b22;">int</span>&amp;) {}
};
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Y</span> {
  <span style="color: #0000ff;">Y</span>(<span style="color: #228b22;">int</span>&amp;, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span>&amp;) {}
};
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Z</span> {
  <span style="color: #0000ff;">Z</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span>&amp;, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span>&amp;) {}
};

<span style="color: #b22222;">// </span><span style="color: #b22222;">Version 1</span>
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A1</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A2</span>&gt;
<span style="color: #228b22;">T</span>* <span style="color: #0000ff;">factory</span>(<span style="color: #228b22;">A1</span>&amp; <span style="color: #a0522d;">a1</span>, <span style="color: #228b22;">A2</span>&amp; <span style="color: #a0522d;">a2</span>) {
  <span style="color: #a020f0;">return</span> <span style="color: #a020f0;">new</span> <span style="color: #228b22;">T</span>(a1, a2);
}
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span> = 4, <span style="color: #a0522d;">b</span> = 5;
<span style="color: #228b22;">W</span>* <span style="color: #a0522d;">pw</span> = factory&lt;<span style="color: #228b22;">W</span>&gt;(a, b);
<span style="color: #228b22;">Z</span>* <span style="color: #a0522d;">pz</span> = factory&lt;<span style="color: #228b22;">Z</span>&gt;(2, 2); <span style="color: #b22222;">// </span><span style="color: #b22222;">error</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">Version 2: using R reference</span>
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A1</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A2</span>&gt;
<span style="color: #228b22;">T</span>* <span style="color: #0000ff;">factory</span>(<span style="color: #228b22;">A1</span>&amp;&amp; <span style="color: #a0522d;">a1</span>, <span style="color: #228b22;">A2</span>&amp;&amp; <span style="color: #a0522d;">a2</span>) {
  <span style="color: #a020f0;">return</span> <span style="color: #a020f0;">new</span> <span style="color: #228b22;">T</span>(<span style="color: #008b8b;">std</span>::forward&lt;<span style="color: #228b22;">A1</span>&gt;(a1), <span style="color: #008b8b;">std</span>::forward&lt;<span style="color: #228b22;">A2</span>&gt;(a2));
}
<span style="color: #228b22;">Z</span>* <span style="color: #a0522d;">pz</span> = factory&lt;<span style="color: #228b22;">Z</span>&gt;(2, 2); <span style="color: #b22222;">// </span><span style="color: #b22222;">correct</span>
</pre>
</div>
<p>
std::forward function forwards the parameters of the factory function to the constructor of the template class.
</p>
</div>
</div>

<div id="outline-container-org9937ded" class="outline-4">
<h4 id="org9937ded"><span class="section-number-4">4.2.3</span> Other properties</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li>The compiler treats a named rvalue reference as an lvalue and an unnamed rvalue reference as an rvalue.</li>
<li>You can cast an lvalue to an rvalue reference. <code>static_cast&lt;MemoryBlock&amp;&amp;&gt;(block)</code></li>
</ul>
<p>
For detail, refer to <a href="https://msdn.microsoft.com/en-us/library/dd293668.aspx">Rvalue Reference</a> by Microsoft.
</p>
</div>
</div>
</div>

<div id="outline-container-org74cbe36" class="outline-3">
<h3 id="org74cbe36"><span class="section-number-3">4.3</span> lambda</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Constructs a closure: an unnamed function object capable of capturing variables in scope.
</p>

<p>
reference:
</p>

<ul class="org-ul">
<li><a href="http://en.cppreference.com/w/cpp/language/lambda">http://en.cppreference.com/w/cpp/language/lambda</a></li>
</ul>
</div>

<div id="outline-container-org5472823" class="outline-4">
<h4 id="org5472823"><span class="section-number-4">4.3.1</span> syntax</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>Full declaration:</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">[ capture-list ] ( params ) <span style="color: #a020f0;">mutable</span>(<span style="color: #a0522d;">optional</span>) <span style="color: #228b22;">exception</span> <span style="color: #a0522d;">attribute</span> -&gt; ret { body }
</pre>
</div>

<ul class="org-ul">
<li>Declaration of a const lambda: the objects captured by copy cannot be modified.</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">[ capture-list ] ( params ) -&gt; ret { body }
</pre>
</div>

<p>
for example
</p>

<div class="org-src-container">
<pre class="src src-C++">[]()-&gt;<span style="color: #228b22;">int</span> { <span style="color: #a020f0;">return</span> 2; }
</pre>
</div>

<ul class="org-ul">
<li>Omitted trailing-return-type</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">[ capture-list ] ( params ) { body }
</pre>
</div>

<p>
if the <code>body</code> contains nothing but a single return statement, the return type is that expression's type. Otherwise return type is <code>void</code>.
</p>

<ul class="org-ul">
<li>Omitted parameter list</li>
</ul>

<p>
take no parameters.
</p>

<div class="org-src-container">
<pre class="src src-C++">[ capture-list ] { body }
</pre>
</div>
</div>
</div>

<div id="outline-container-org5a2278b" class="outline-4">
<h4 id="org5a2278b"><span class="section-number-4">4.3.2</span> Explanations</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li><code>mutable</code>: allows body to modify the parameters captured by copy, and to call their non-const member functions</li>
<li><code>exception</code>: provides the exception specification or the noexcept clause for operator() of the closure type</li>
<li><code>attribute</code>: provides the attribute specification for operator() of the closure type</li>
<li><code>capture-list</code>: a comma-separated list of zero or more captures
<ul class="org-ul">
<li><code>[a,&amp;b]</code>: where a is captured by value and b is captured by reference.</li>
<li><code>[this]</code>: captures the this pointer by value</li>
<li><code>[&amp;]</code>: captures all automatic variables odr-used in the body of the lambda by reference</li>
<li><code>[=]</code>: captures all automatic variables odr-used in the body of the lambda by value</li>
<li><code>[]</code>: captures nothing</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgec3b7bf" class="outline-3">
<h3 id="orgec3b7bf"><span class="section-number-3">4.4</span> Smart Pointer</h3>
<div class="outline-text-3" id="text-4-4">
<dl class="org-dl">
<dt><code>unique_ptr</code></dt><dd>cannot be copied</dd>
<dt><code>shared_ptr</code></dt><dd>can be copied. Will destroy when the last reference
destroy.</dd>
<dt><code>weak_ptr</code></dt><dd>reference to an object, but does not increase the
count for it. It must be converted to <code>shared_ptr</code>
before use.</dd>
</dl>

<p>
The <code>weak_ptr</code> can help break the <i>reference-count cycle</i> problem.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">widget</span> {
  <span style="color: #228b22;">shared_ptr</span>&lt;gadget&gt; <span style="color: #a0522d;">g</span>;
};
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">gadget</span> {
  <span style="color: #228b22;">weak_ptr</span>&lt;<span style="color: #228b22;">widget</span>&gt; <span style="color: #a0522d;">w</span>;
};
</pre>
</div>

<p>
If both are <code>shared_ptr</code>, the ownership is not clear, so destructing
them would be a problem.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unique_ptr</span>&lt;Type&gt; <span style="color: #a0522d;">ptr</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">ensure that the pointer is deleted after going out of scope.</span>
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">shared_ptr</span>&lt;Type&gt; <span style="color: #a0522d;">ptr</span>;
</pre>
</div>
</div>
</div>


<div id="outline-container-orgcc178cf" class="outline-3">
<h3 id="orgcc178cf"><span class="section-number-3">4.5</span> Exception Handling</h3>
<div class="outline-text-3" id="text-4-5">
<p>
C++ Exception is handled by try-catch clause.  Catch accept an
argument, a reference to the type of the exception.  It can accept
<code>...</code>, meaning all kinds of exceptions.  The throw expression accepts
one argument. The type of that argument should match the type of the
argument of catch.  If throw is used without argument, it means
Rethrows the currently handled exception.  So, throw can accept an int
value, as long as the corresponding catch accept an int.
</p>

<p>
Catching of exception usually is the reference. The <code>std::exception</code> is
the standard base class for exceptions. The signature is:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">exception</span> {
<span style="color: #a020f0;">public</span>:
  exception () <span style="color: #a020f0;">throw</span>();
  <span style="color: #0000ff;">exception</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">exception</span>&amp;) <span style="color: #a020f0;">throw</span>();
  <span style="color: #228b22;">exception</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">exception</span>&amp;) <span style="color: #a020f0;">throw</span>();
  <span style="color: #a020f0;">virtual</span> ~<span style="color: #228b22;">exception</span>() <span style="color: #a020f0;">throw</span>();
  <span style="color: #a020f0;">virtual</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #0000ff;">what</span>() <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">throw</span>();
}
</pre>
</div>

<p>
The what virtual function should be overwritten and returns a
null-terminated string.
</p>
</div>

<div id="outline-container-org9c8e2ce" class="outline-4">
<h4 id="org9c8e2ce"><span class="section-number-4">4.5.1</span> Exception specification</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
This is deprecated. In the declaration of a function, you can add a
throw keyword and the type of exception in parenthesis. Throw is a
specifier, and is part of the function type.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">double</span> <span style="color: #0000ff;">myfunction</span> (<span style="color: #228b22;">char</span> <span style="color: #a0522d;">param</span>) <span style="color: #a020f0;">throw</span> (<span style="color: #228b22;">int</span>);
</pre>
</div>

<p>
If the function throws exception other than <code>int</code>, the function
<code>std::unexpected</code> is called. Function without throw specifier will never
call <code>std::unexpected</code>, and do the normal exception handling. If here
there's no type in the parenthesis, it means the function should not
throw any exception.
</p>

<p>
<code>noexcept</code> is the current in use one. If no argument provided, it is
same as <code>noexcept(true)</code>. If argument is provided, it is evaluated and
if it evaluates to true, it means this function is not throwing any
exception. Otherwise the function is potentially throwing. <code>throw ()</code> is
same as <code>noexcept(true)</code> but is deprecated.
</p>
</div>
</div>
</div>


<div id="outline-container-org6ca74a5" class="outline-3">
<h3 id="org6ca74a5"><span class="section-number-3">4.6</span> Template</h3>
<div class="outline-text-3" id="text-4-6">
</div>
<div id="outline-container-orge6a877f" class="outline-4">
<h4 id="orge6a877f"><span class="section-number-4">4.6.1</span> Template specialization</h4>
<div class="outline-text-4" id="text-4-6-1">
<p>
Use when you want to define a different implementation for a template
when a specific type is passed as template parameter.
</p>

<p>
The syntax is this: put an empty inside the brackets, and put a <code>&lt;char&gt;</code>
after the class name. When instantiate this class with <code>char</code>, it will
use the specialized one.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">mycontainer</span> { ... };
<span style="color: #a020f0;">template</span> &lt;&gt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">mycontainer</span> &lt;<span style="color: #228b22;">char</span>&gt; { ... };
</pre>
</div>

<p>
So only have the second form is not valid.
</p>
</div>
</div>

<div id="outline-container-org613fde8" class="outline-4">
<h4 id="org613fde8"><span class="section-number-4">4.6.2</span> Non-type parameter</h4>
<div class="outline-text-4" id="text-4-6-2">
<p>
The parameter can not just be a type name, but also a regular type.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">N</span>&gt;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">mysequence</span> {
    <span style="color: #228b22;">T</span> <span style="color: #a0522d;">memblock</span> [N];
  <span style="color: #a020f0;">public</span>:
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">setmember</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>, <span style="color: #228b22;">T</span> <span style="color: #a0522d;">value</span>);
    <span style="color: #228b22;">T</span> <span style="color: #0000ff;">getmember</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>);
};
</pre>
</div>

<p>
It can have default values:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>=<span style="color: #228b22;">char</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">N</span>=10&gt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">mysequence</span> {..};
</pre>
</div>

<p>
Then the following calls are equivalent:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #228b22;">mysequence</span>&lt;&gt; <span style="color: #a0522d;">myseq</span>;
<span style="color: #228b22;">mysequence</span>&lt;<span style="color: #228b22;">char</span>,10&gt; <span style="color: #a0522d;">myseq</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org5acf43f" class="outline-4">
<h4 id="org5acf43f"><span class="section-number-4">4.6.3</span> Template Implementation</h4>
<div class="outline-text-4" id="text-4-6-3">
<p>
See <a href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl">https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl</a>
</p>

<p>
The compiler must see two things at the same time in order to
instantiate a template class. Because the instantiated template class
are generated by the compiler.
</p>
<ul class="org-ul">
<li>all the template implementation</li>
<li>the type used to instantiate the template</li>
</ul>

<p>
For example:
</p>

<p>
<code>foo.h</code>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Foo</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">f</span>();
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">g</span>();
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">h</span>();
};
<span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #a020f0;">inline</span> <span style="color: #228b22;">void</span> <span style="color: #008b8b;">Foo</span>&lt;<span style="color: #228b22;">T</span>&gt;::<span style="color: #0000ff;">f</span>() {}
</pre>
</div>

<p>
<code>foo.cpp</code>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;iostream&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"foo.h"</span>
<span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #228b22;">void</span> <span style="color: #008b8b;">Foo</span>&lt;<span style="color: #228b22;">T</span>&gt;::<span style="color: #0000ff;">g</span>() {
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"Foo&lt;T&gt;::g()\n"</span>;
}
<span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #228b22;">void</span> <span style="color: #008b8b;">Foo</span>&lt;<span style="color: #228b22;">T</span>&gt;::<span style="color: #0000ff;">h</span>() {
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"Foo&lt;T&gt;::h()\n"</span>;
}
</pre>
</div>

<p>
<code>main.cpp</code>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"foo.h"</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
  <span style="color: #228b22;">Foo</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">x</span>;
  x.f();
  x.g();
  x.h();
}
</pre>
</div>

<p>
The link will generate error that cannot find <code>g</code> and <code>h</code>
definition. Of course moving the definition in <code>foo.cpp</code> to <code>foo.h</code>
can solve the problem, but it will make the header file too big.
</p>

<p>
Another way: put <code>template class Foo&lt;int&gt;;</code> at the end of <code>foo.cpp</code>,
thus compiler can see the <code>Foo&lt;int&gt;</code> and implementation at the same
time.
</p>

<p>
You can also have a <code>foo-impl.cpp</code> for adding this, but it should
include <code>foo.cpp</code>
</p>

<p>
<code>foo-impl.cpp</code>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"foo.cpp"</span>
<span style="color: #a020f0;">template</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Foo</span>&lt;<span style="color: #228b22;">int</span>&gt;;
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org0ba11f1" class="outline-2">
<h2 id="org0ba11f1"><span class="section-number-2">5</span> Library</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgaed1c43" class="outline-3">
<h3 id="orgaed1c43"><span class="section-number-3">5.1</span> Stream</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-orgc59ebb0" class="outline-4">
<h4 id="orgc59ebb0"><span class="section-number-4">5.1.1</span> file stream</h4>
<div class="outline-text-4" id="text-5-1-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;fstream&gt;</span>
<span style="color: #228b22;">ofstream</span> <span style="color: #a0522d;">myfile</span>;
myfile.open(<span style="color: #8b2252;">"a.txt"</span>);
<span style="color: #a020f0;">if</span> (myfile.is_open()) {
  myfile &lt;&lt; <span style="color: #8b2252;">"..."</span>;
  myfile.close();
}
<span style="color: #b22222;">// </span><span style="color: #b22222;">after close, it can used to open another file</span>
myfile.open(<span style="color: #8b2252;">"b.txt"</span>);
myfile.close();
</pre>
</div>
</div>

<div id="outline-container-org12eb486" class="outline-5">
<h5 id="org12eb486"><span class="section-number-5">5.1.1.1</span> When to flush</h5>
<div class="outline-text-5" id="text-5-1-1-1">
<ul class="org-ul">
<li><code>file.close()</code></li>
<li>buffer is full</li>
<li><code>flush</code>, <code>endl</code> used as manipulators</li>
<li><code>file.sync()</code></li>
</ul>
</div>
</div>

<div id="outline-container-org16bfc24" class="outline-5">
<h5 id="org16bfc24"><span class="section-number-5">5.1.1.2</span> mode</h5>
<div class="outline-text-5" id="text-5-1-1-2">
<p>
open flag:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">flag</td>
<td class="org-left">desription</td>
</tr>

<tr>
<td class="org-left">:------------</td>
<td class="org-left">:----------------------------------------------------------------------------------</td>
</tr>

<tr>
<td class="org-left">ios::in</td>
<td class="org-left">input</td>
</tr>

<tr>
<td class="org-left">ios::out</td>
<td class="org-left">output</td>
</tr>

<tr>
<td class="org-left">ios::binary</td>
<td class="org-left">binary mode</td>
</tr>

<tr>
<td class="org-left">ios::ate</td>
<td class="org-left">initial position to the end of file</td>
</tr>

<tr>
<td class="org-left">ios::app</td>
<td class="org-left">all <b><b>output</b></b> operations are performed at the end of the file, append</td>
</tr>

<tr>
<td class="org-left">ios::trunc</td>
<td class="org-left">if the file is opened for output and already exists, previous content is replaced</td>
</tr>
</tbody>
</table>

<p>
Default:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">class</td>
<td class="org-left">default mode</td>
<td class="org-left">New flag action</td>
</tr>

<tr>
<td class="org-left">:---------</td>
<td class="org-left">:-------------------</td>
<td class="org-left">:----------------</td>
</tr>

<tr>
<td class="org-left">ofstream</td>
<td class="org-left">ios::out</td>
<td class="org-left">add</td>
</tr>

<tr>
<td class="org-left">ifstream</td>
<td class="org-left">ios::in</td>
<td class="org-left">add</td>
</tr>

<tr>
<td class="org-left">fstream</td>
<td class="org-left">ios::in 1 ios::out</td>
<td class="org-left">overwrite</td>
</tr>
</tbody>
</table>

<p>
binary mode cannot use &gt;&gt;, &lt;&lt;, getline, but use
</p>

<div class="org-src-container">
<pre class="src src-C++">write(memory_block, size);
read(memory_block, size);
</pre>
</div>
</div>
</div>

<div id="outline-container-org464bdd5" class="outline-5">
<h5 id="org464bdd5"><span class="section-number-5">5.1.1.3</span> seek</h5>
<div class="outline-text-5" id="text-5-1-1-3">
<ul class="org-ul">
<li>tellg(): get <span class="underline">get position</span></li>
<li>tellp(): get <span class="underline">put position</span></li>
<li>seekg(position): count from the beginning</li>
<li>seekp(position)</li>
<li>seekg(offset, direction);</li>
<li>seekp(offset, direction);</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">direction</td>
<td class="org-left">description</td>
</tr>

<tr>
<td class="org-left">:----------</td>
<td class="org-left">:------------</td>
</tr>

<tr>
<td class="org-left">ios::beg</td>
<td class="org-left">beginning</td>
</tr>

<tr>
<td class="org-left">ios::cur</td>
<td class="org-left">current</td>
</tr>

<tr>
<td class="org-left">ios::end</td>
<td class="org-left">end</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org047847b" class="outline-4">
<h4 id="org047847b"><span class="section-number-4">5.1.2</span> iostream</h4>
<div class="outline-text-4" id="text-5-1-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;iostream&gt;</span>
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">price</span>;
cin&gt;&gt;price;
</pre>
</div>

<p>
If the input is not integer, the program will <b><b>continue</b></b> without setting price's value.
Then if a is used afterwards, undefined behavior.
</p>

<p>
To add a validation process, we need to use stringstream:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sstream&gt;</span>
<span style="color: #228b22;">string</span> <span style="color: #a0522d;">mystr</span>;
getline(cin, mystr);
<span style="color: #228b22;">stringstream</span> <span style="color: #a0522d;">ss</span> = stringstream(mystr);
<span style="color: #b22222;">// </span><span style="color: #b22222;">validate ss</span>
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">price</span>;
ss &gt;&gt; price;
</pre>
</div>

<p>
<b>Always use getline instead of cin directly</b>
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">while</span>(getline(cin, line)) {;}
<span style="color: #a020f0;">while</span>(getline(fs, line)) {;}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbd16caf" class="outline-3">
<h3 id="orgbd16caf"><span class="section-number-3">5.2</span> String</h3>
<div class="outline-text-3" id="text-5-2">
</div>
<div id="outline-container-org322c3c2" class="outline-4">
<h4 id="org322c3c2"><span class="section-number-4">5.2.1</span> Constructor</h4>
<div class="outline-text-4" id="text-5-2-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">default</span>
<span style="color: #0000ff;">string</span>();
<span style="color: #b22222;">// </span><span style="color: #b22222;">copy</span>
<span style="color: #0000ff;">string</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">substring</span>
<span style="color: #0000ff;">string</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span> = npos);
<span style="color: #b22222;">// </span><span style="color: #b22222;">from c-string</span>
<span style="color: #0000ff;">string</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">from sequence</span>
<span style="color: #0000ff;">string</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">fill</span>
<span style="color: #0000ff;">string</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">range</span>
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIterator</span>&gt;
<span style="color: #0000ff;">string</span>  (<span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">last</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org382d823" class="outline-4">
<h4 id="org382d823"><span class="section-number-4">5.2.2</span> operator=</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">string</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">c-string</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">character</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span> (<span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org195826b" class="outline-4">
<h4 id="org195826b"><span class="section-number-4">5.2.3</span> handy routine</h4>
<div class="outline-text-4" id="text-5-2-3">
</div>
<div id="outline-container-org7d5e182" class="outline-5">
<h5 id="org7d5e182"><span class="section-number-5">5.2.3.1</span> trim a string</h5>
<div class="outline-text-5" id="text-5-2-3-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;algorithm&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;functional&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;cctype&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;locale&gt;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">trim from start</span>
<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">inline</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> &amp;<span style="color: #0000ff;">ltrim</span>(<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> &amp;<span style="color: #a0522d;">s</span>) {
  s.erase(s.begin(), <span style="color: #008b8b;">std</span>::find_if(s.begin(), s.end(), <span style="color: #008b8b;">std</span>::not1(<span style="color: #008b8b;">std</span>::ptr_fun&lt;<span style="color: #228b22;">int</span>, <span style="color: #228b22;">int</span>&gt;(<span style="color: #008b8b;">std</span>::isspace))));
  <span style="color: #a020f0;">return</span> s;
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">trim from end</span>
<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">inline</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> &amp;<span style="color: #0000ff;">rtrim</span>(<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> &amp;<span style="color: #a0522d;">s</span>) {
  s.erase(<span style="color: #008b8b;">std</span>::find_if(s.rbegin(), s.rend(), <span style="color: #008b8b;">std</span>::not1(<span style="color: #008b8b;">std</span>::ptr_fun&lt;<span style="color: #228b22;">int</span>, <span style="color: #228b22;">int</span>&gt;(<span style="color: #008b8b;">std</span>::isspace))).base(), s.end());
  <span style="color: #a020f0;">return</span> s;
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">trim from both ends</span>
<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">inline</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> &amp;<span style="color: #0000ff;">trim</span>(<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> &amp;<span style="color: #a0522d;">s</span>) {
  <span style="color: #a020f0;">return</span> ltrim(rtrim(s));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org34bfe92" class="outline-5">
<h5 id="org34bfe92"><span class="section-number-5">5.2.3.2</span> split a string</h5>
<div class="outline-text-5" id="text-5-2-3-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span>(<span style="color: #8b2252;">"Somewhere down the road"</span>);
<span style="color: #228b22;">istringstream</span> <span style="color: #0000ff;">iss</span>(s);

<span style="color: #a020f0;">do</span>
{
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">sub</span>;
  iss &gt;&gt; sub;
  cout &lt;&lt; <span style="color: #8b2252;">"Substring: "</span> &lt;&lt; sub &lt;&lt; endl;
} <span style="color: #a020f0;">while</span> (iss);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&gt; &amp;<span style="color: #0000ff;">split</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> &amp;<span style="color: #a0522d;">s</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">delim</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&gt; &amp;<span style="color: #a0522d;">elems</span>) {
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">stringstream</span> <span style="color: #0000ff;">ss</span>(s);
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">item</span>;
  <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">std</span>::getline(ss, item, delim)) {
    elems.push_back(item);
  }
  <span style="color: #a020f0;">return</span> elems;
}


<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&gt; <span style="color: #0000ff;">split</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> &amp;<span style="color: #a0522d;">s</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">delim</span>) {
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&gt; <span style="color: #a0522d;">elems</span>;
  split(s, delim, elems);
  <span style="color: #a020f0;">return</span> elems;
}
</pre>
</div>

<p>
More flexible version:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">/**</span>
<span style="color: #b22222;"> * Delim by ANY characters in delim string</span>
<span style="color: #b22222;"> */</span>
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::string&gt;
<span style="color: #008b8b;">utils</span>::<span style="color: #0000ff;">split</span>(<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">delim</span>) {
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">prev</span> = 0, <span style="color: #a0522d;">pos</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&gt; <span style="color: #a0522d;">ret</span>;
  <span style="color: #a020f0;">while</span> ((pos = s.find_first_of(delim, prev)) != <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">string</span>::npos)
    {
      <span style="color: #a020f0;">if</span> (pos &gt; prev)
        ret.push_back(s.substr(prev, pos-prev));
      prev = pos+1;
    }
  <span style="color: #a020f0;">if</span> (prev &lt; s.length()) {
    ret.push_back(s.substr(prev, <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">string</span>::npos));
  }
  <span style="color: #a020f0;">return</span> ret;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9868874" class="outline-5">
<h5 id="org9868874"><span class="section-number-5">5.2.3.3</span> better split string</h5>
<div class="outline-text-5" id="text-5-2-3-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">to std::cout</span>
copy(
  istream_iterator&lt;<span style="color: #228b22;">string</span>&gt;(iss),
  istream_iterator&lt;<span style="color: #228b22;">string</span>&gt;(),
  ostream_iterator&lt;<span style="color: #228b22;">string</span>&gt;(cout, <span style="color: #8b2252;">"\n"</span>)
);
<span style="color: #b22222;">// </span><span style="color: #b22222;">to a vector</span>
<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">string</span>&gt; <span style="color: #a0522d;">tokens</span>;
copy(
  istream_iterator&lt;<span style="color: #228b22;">string</span>&gt;(iss),
  istream_iterator&lt;<span style="color: #228b22;">string</span>&gt;(),
  back_inserter(tokens)
);
<span style="color: #b22222;">// </span><span style="color: #b22222;">construct the vector directly</span>
<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">string</span>&gt; <span style="color: #a0522d;">tokens</span>{
  <span style="color: #228b22;">istream_iterator</span>&lt;<span style="color: #228b22;">string</span>&gt;{iss},
  <span style="color: #228b22;">istream_iterator</span>&lt;<span style="color: #228b22;">string</span>&gt;{}
};
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org9742d23" class="outline-4">
<h4 id="org9742d23"><span class="section-number-4">5.2.4</span> member function</h4>
<div class="outline-text-4" id="text-5-2-4">
</div>
<div id="outline-container-org9487729" class="outline-5">
<h5 id="org9487729"><span class="section-number-5">5.2.4.1</span> iterator</h5>
<div class="outline-text-5" id="text-5-2-4-1">
<ul class="org-ul">
<li>begin()</li>
<li>end()</li>
</ul>
</div>
</div>

<div id="outline-container-org0afacfb" class="outline-5">
<h5 id="org0afacfb"><span class="section-number-5">5.2.4.2</span> capacity</h5>
<div class="outline-text-5" id="text-5-2-4-2">
<ul class="org-ul">
<li>size(): length of string</li>
<li>length(): length of string</li>
<li>empty()</li>
<li>clear()</li>
</ul>
</div>
</div>

<div id="outline-container-org2276023" class="outline-5">
<h5 id="org2276023"><span class="section-number-5">5.2.4.3</span> access</h5>
<div class="outline-text-5" id="text-5-2-4-3">
<ul class="org-ul">
<li>operator[]</li>
<li>at()</li>
<li>back(): A reference to the last character in the string</li>
</ul>
</div>
</div>
<div id="outline-container-org7a87943" class="outline-5">
<h5 id="org7a87943"><span class="section-number-5">5.2.4.4</span> mofifier</h5>
<div class="outline-text-5" id="text-5-2-4-4">
<ul class="org-ul">
<li>operator+=</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">string (1)</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">c-string</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">character</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+=</span> (<span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>);
</pre>
</div>

<ul class="org-ul">
<li>append</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">string</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">append</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">substring</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">append</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">subpos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">sublen</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">c-string</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">append</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">buffer</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">append</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">fill</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">append</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">range</span>
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIterator</span>&gt;
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">append</span> (<span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">last</span>);
</pre>
</div>

<ul class="org-ul">
<li>push<sub>back</sub>(char): <code>void push_back (char c);</code></li>

<li>insert(): before the character indicated by pos (or p)</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">string</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">insert</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">substring</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">insert</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">subpos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">sublen</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">c-string</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">insert</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">buffer</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">insert</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">fill</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">insert</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>);
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">insert</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">p</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">single character</span>
<span style="color: #228b22;">iterator</span> <span style="color: #0000ff;">insert</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">p</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">range</span>
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIterator</span>&gt;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">insert</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">p</span>, <span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">last</span>);
</pre>
</div>

<ul class="org-ul">
<li>erase(): erase part of the string</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">sequence</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">erase</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span> = 0, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span> = npos);
<span style="color: #b22222;">// </span><span style="color: #b22222;">character: Erases the character pointed by p</span>
<span style="color: #228b22;">iterator</span> <span style="color: #0000ff;">erase</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">p</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">range: [first,last)</span>
<span style="color: #228b22;">iterator</span> <span style="color: #0000ff;">erase</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">last</span>);
</pre>
</div>

<ul class="org-ul">
<li>replace()</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">string</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>,  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>,  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>);
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i1</span>, <span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i2</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">substring</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (
  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>,  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>,  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>,
  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">subpos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">sublen</span>
);
<span style="color: #b22222;">// </span><span style="color: #b22222;">c-string</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>,  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>,  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>);
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i1</span>, <span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i2</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">buffer</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>,  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>,  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>);
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i1</span>, <span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i2</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">fill</span>
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>,  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>,  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>);
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i1</span>, <span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i2</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">range</span>
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIterator</span>&gt;
<span style="color: #228b22;">string</span>&amp; <span style="color: #0000ff;">replace</span> (<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i1</span>, <span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">i2</span>,
  <span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">last</span>
);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf932403" class="outline-5">
<h5 id="orgf932403"><span class="section-number-5">5.2.4.5</span> operation</h5>
<div class="outline-text-5" id="text-5-2-4-5">
<ul class="org-ul">
<li>c<sub>str</sub>(): A program <b><b>shall not alter</b></b> any of the characters in this sequence.</li>
<li>copy(): Copies a substring of the current value of the string object</li>
</ul>
<p>
into the array pointed by s.
<b><b>does not append null-terminator</b></b>
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">copy</span> (<span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span> = 0) <span style="color: #a020f0;">const</span>;
</pre>
</div>

<ul class="org-ul">
<li>find(): the first occurrence of the sequence specified after pos</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">string</span>
<span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">find</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span> = 0) <span style="color: #a020f0;">const</span>;
<span style="color: #b22222;">// </span><span style="color: #b22222;">c-string</span>
<span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">find</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span> = 0) <span style="color: #a020f0;">const</span>;
<span style="color: #b22222;">// </span><span style="color: #b22222;">buffer</span>
<span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">find</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>) <span style="color: #a020f0;">const</span>;
<span style="color: #b22222;">// </span><span style="color: #b22222;">character</span>
<span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">find</span> (<span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span> = 0) <span style="color: #a020f0;">const</span>;
</pre>
</div>

<ul class="org-ul">
<li>substr(): Returns a newly constructed string object</li>
</ul>
<p>
with its value initialized to a copy of a substring of this object
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">substr</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span> = 0, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span> = npos) <span style="color: #a020f0;">const</span>;
</pre>
</div>

<ul class="org-ul">
<li>compare()</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">string</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">compare</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>) <span style="color: #a020f0;">const</span>;
<span style="color: #b22222;">// </span><span style="color: #b22222;">substrings</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">compare</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>) <span style="color: #a020f0;">const</span>;
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">compare</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>,
  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">subpos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">sublen</span>
) <span style="color: #a020f0;">const</span>;
<span style="color: #b22222;">// </span><span style="color: #b22222;">c-string</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">compare</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>) <span style="color: #a020f0;">const</span>;
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">compare</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>) <span style="color: #a020f0;">const</span>;
<span style="color: #b22222;">// </span><span style="color: #b22222;">buffer</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">compare</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>) <span style="color: #a020f0;">const</span>;
</pre>
</div>

<p>
return: 0, -, +
</p>

<ul class="org-ul">
<li>npos: max value of size<sub>t</sub></li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">static</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">npos</span> = -1;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2a0b33e" class="outline-4">
<h4 id="org2a0b33e"><span class="section-number-4">5.2.5</span> non-member function</h4>
<div class="outline-text-4" id="text-5-2-5">
</div>
<div id="outline-container-orgb6ef4dc" class="outline-5">
<h5 id="orgb6ef4dc"><span class="section-number-5">5.2.5.1</span> operator +</h5>
<div class="outline-text-5" id="text-5-2-5-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">string</span>
<span style="color: #228b22;">string</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">c-string</span>
<span style="color: #228b22;">string</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">string</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">character</span>
<span style="color: #228b22;">string</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #228b22;">char</span>          <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">string</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span> (<span style="color: #228b22;">char</span>          <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbed2fc2" class="outline-5">
<h5 id="orgbed2fc2"><span class="section-number-5">5.2.5.2</span> rational</h5>
<div class="outline-text-5" id="text-5-2-5-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">==</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">==</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">==</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">!=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">!=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">!=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;</span>  (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;</span>  (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;</span>  (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;</span>  (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;</span>  (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;</span>  (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;=</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*   <span style="color: #a0522d;">rhs</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orge2629e2" class="outline-5">
<h5 id="orge2629e2"><span class="section-number-5">5.2.5.3</span> &gt;&gt;</h5>
<div class="outline-text-5" id="text-5-2-5-3">
<p>
extract string from stream
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">istream</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;&gt;</span> (<span style="color: #228b22;">istream</span>&amp; <span style="color: #a0522d;">is</span>, <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>);
<span style="color: #228b22;">ostream</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;&lt;</span> (<span style="color: #228b22;">ostream</span>&amp; <span style="color: #a0522d;">os</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org9c0c06c" class="outline-5">
<h5 id="org9c0c06c"><span class="section-number-5">5.2.5.4</span> getline</h5>
<div class="outline-text-5" id="text-5-2-5-4">
<p>
get line from stream into string
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">istream</span>&amp; <span style="color: #0000ff;">getline</span> (<span style="color: #228b22;">istream</span>&amp; <span style="color: #a0522d;">is</span>, <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">delim</span>); <span style="color: #b22222;">// </span><span style="color: #b22222;">delim</span>
<span style="color: #228b22;">istream</span>&amp; <span style="color: #0000ff;">getline</span> (<span style="color: #228b22;">istream</span>&amp; <span style="color: #a0522d;">is</span>, <span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>); <span style="color: #b22222;">// </span><span style="color: #b22222;">new line</span>
</pre>
</div>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org321d195" class="outline-2">
<h2 id="org321d195"><span class="section-number-2">6</span> Other</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orga687aef" class="outline-3">
<h3 id="orga687aef"><span class="section-number-3">6.1</span> Tips</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li><code>main~ ~int</code></li>
<li>: <code>-Wall</code></li>
<li><code>cin&gt;&gt;a</code>  <code>EOF</code>  <code>&lt;C-D&gt;</code> </li>
<li><code>./a.out &lt;infile &gt;outfile</code></li>
</ul>
</div>
<div id="outline-container-org72f1c74" class="outline-4">
<h4 id="org72f1c74"><span class="section-number-4">6.1.1</span> function object</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
Objects that act like functions.
Such objects come from classes that overload <code>operator()</code>.
</p>
</div>
</div>

<div id="outline-container-org2cc17e0" class="outline-4">
<h4 id="org2cc17e0"><span class="section-number-4">6.1.2</span> auto</h4>
<div class="outline-text-4" id="text-6-1-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">g</span> = bind(f, a, b, _2, c, _1);
</pre>
</div>
<p>
 <code>g(-1,-2)</code> f <code>_1</code>  <code>-1</code>, <code>_2</code>  <code>-2</code>.
</p>
</div>
</div>

<div id="outline-container-orgd9a76e3" class="outline-4">
<h4 id="orgd9a76e3"><span class="section-number-4">6.1.3</span> at</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
 <code>string</code>, <code>vector</code>, <code>deque</code>, <code>array</code>
</p>

<p>
<code>c.at(n)</code> ~n~ <code>out_of_range</code> 
</p>
</div>
</div>

<div id="outline-container-org1aa77cb" class="outline-4">
<h4 id="org1aa77cb"><span class="section-number-4">6.1.4</span> decltype</h4>
<div class="outline-text-4" id="text-6-1-4">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">A</span> {
  <span style="color: #228b22;">double</span> <span style="color: #a0522d;">x</span>;
};
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>* <span style="color: #a0522d;">a</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">A</span>{0};

<span style="color: #a020f0;">decltype</span>( a-&gt;x ) <span style="color: #a0522d;">x3</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">type of x3 is double (declared type)</span>
<span style="color: #a020f0;">decltype</span>((a-&gt;x)) <span style="color: #a0522d;">x4</span> = x3;  <span style="color: #b22222;">// </span><span style="color: #b22222;">type of x4 is const double&amp; (lvalue expression)</span>

<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">f</span> = [](<span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">b</span>) -&gt; <span style="color: #228b22;">int</span> {
  <span style="color: #a020f0;">return</span> a*b;
};

<span style="color: #a020f0;">decltype</span>(f) <span style="color: #a0522d;">f2</span> = f; <span style="color: #b22222;">// </span><span style="color: #b22222;">the type of a lambda function is unique and unnamed</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org23a6cec" class="outline-4">
<h4 id="org23a6cec"><span class="section-number-4">6.1.5</span> pair</h4>
<div class="outline-text-4" id="text-6-1-5">
<p>
std::make<sub>pair</sub>
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T1</span>,<span style="color: #a020f0;">class</span> <span style="color: #228b22;">T2</span>&gt;
<span style="color: #228b22;">pair</span>&lt;<span style="color: #228b22;">T1</span>,<span style="color: #228b22;">T2</span>&gt; <span style="color: #0000ff;">make_pair</span> (<span style="color: #228b22;">T1</span> <span style="color: #a0522d;">x</span>, <span style="color: #228b22;">T2</span> <span style="color: #a0522d;">y</span>)
{
  <span style="color: #a020f0;">return</span> ( pair&lt;T1,T2&gt;(x,y) );
}
</pre>
</div>

<p>
for example:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #008b8b;">std</span>::make_pair(<span style="color: #8b2252;">"hello"</span>, <span style="color: #8b2252;">"world"</span>);
</pre>
</div>

<p>
equals to:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #008b8b;">std</span>::pair&lt;<span style="color: #228b22;">string</span>, <span style="color: #228b22;">string</span>&gt;(<span style="color: #8b2252;">"hello"</span>, <span style="color: #8b2252;">"world"</span>);
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-orgbdd4b8c" class="outline-3">
<h3 id="orgbdd4b8c"><span class="section-number-3">6.2</span> constant</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Prefer <code>const</code>, <code>enum</code>, and <code>inline</code> to <code>#define</code>.
</p>
</div>

<div id="outline-container-orga4a590d" class="outline-4">
<h4 id="orga4a590d"><span class="section-number-4">6.2.1</span> Rationale</h4>
<div class="outline-text-4" id="text-6-2-1">
<ol class="org-ol">
<li>prefer the compiler to preprocessor,</li>
</ol>
<p>
the define may never be seen by compiler,
thus less meaningful debug information,
less optimization.
</p>
<ol class="org-ol">
<li><code>#define</code> don't respect scope.</li>
</ol>
</div>
</div>

<div id="outline-container-org420afc2" class="outline-4">
<h4 id="org420afc2"><span class="section-number-4">6.2.2</span> How to use</h4>
<div class="outline-text-4" id="text-6-2-2">
</div>
<div id="outline-container-org0cdde5f" class="outline-5">
<h5 id="org0cdde5f"><span class="section-number-5">6.2.2.1</span> const</h5>
<div class="outline-text-5" id="text-6-2-2-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">name</span> = <span style="color: #8b2252;">"Hebi Li"</span>;
<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">name</span>(<span style="color: #8b2252;">"Hebi Li"</span>);
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">A</span> {
<span style="color: #a020f0;">private</span>:
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">num</span> = 5;
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org27d4989"></a>data and pointer const<br />
<div class="outline-text-6" id="text-6-2-2-1-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[] = <span style="color: #8b2252;">"Hebi Li"</span>;
<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">p</span> = name; <span style="color: #b22222;">// </span><span style="color: #b22222;">non-const</span>
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">p</span> = name; <span style="color: #b22222;">// </span><span style="color: #b22222;">const data</span>
<span style="color: #228b22;">char</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">p</span> = name; <span style="color: #b22222;">// </span><span style="color: #b22222;">const pointer</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">data     pointer</span>
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">p</span> = name; <span style="color: #b22222;">// </span><span style="color: #b22222;">double const</span>
</pre>
</div>
</div>
</li>
<li><a id="org927331d"></a>const return value of operator<br />
<div class="outline-text-6" id="text-6-2-2-1-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span> <span style="color: #008b8b;">A</span>::<span style="color: #a020f0;">operator</span><span style="color: #0000ff;">*</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">lhs</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">rhs</span>);
<span style="color: #a020f0;">if</span> (<span style="color: #228b22;">a</span>*<span style="color: #a0522d;">b</span> = c) ... <span style="color: #b22222;">// </span><span style="color: #b22222;">ERROR assign c to a*b</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">char</span>&amp; <span style="color: #008b8b;">B</span>::<span style="color: #a020f0;">operator</span><span style="color: #0000ff;">[]</span>(<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">position</span>);
<span style="color: #228b22;">B</span> <span style="color: #a0522d;">b</span>[];
b[0] = <span style="color: #8b2252;">'x'</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">need &amp; in return value, or this assignment can't work because assign to a char</span>
</pre>
</div>
</div>
</li>
</ol>
</div>


<div id="outline-container-orgbdc9128" class="outline-5">
<h5 id="orgbdc9128"><span class="section-number-5">6.2.2.2</span> enums</h5>
<div class="outline-text-5" id="text-6-2-2-2">
<p>
Some compilers don't support to init value at definition,
because they insist they need to get the when compiling the class.
In this case, use <span class="underline">enum hack</span>:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">A</span> {
<span style="color: #a020f0;">private</span>:
  <span style="color: #a020f0;">enum</span> {<span style="color: #a0522d;">Num</span> = 5}; <span style="color: #b22222;">// </span><span style="color: #b22222;">the enum hack: make Num a symbolic name for 5</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d40cd0" class="outline-5">
<h5 id="org3d40cd0"><span class="section-number-5">6.2.2.3</span> inlines</h5>
<div class="outline-text-5" id="text-6-2-2-3">
<p>
replace
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">CALL_WITH_MAX</span>(<span style="color: #a0522d;">a</span>,<span style="color: #a0522d;">b</span>) f((a) &gt; (b) ? (a) : (b))
</pre>
</div>

<p>
with
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt; <span style="color: #a020f0;">inline</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">callWithMax</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">a</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">b</span>) {
  f(a&gt;b?a:b);
}
</pre>
</div>

<p>
Because you need worry about the parenthesize for define:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span>=5,<span style="color: #a0522d;">b</span>=0;
CALL_WITH_MAX(++a, b); <span style="color: #b22222;">// </span><span style="color: #b22222;">a increased twice</span>
CALL_WITH_MAX(++a, b+10); <span style="color: #b22222;">// </span><span style="color: #b22222;">a increased once</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orge4b35b4" class="outline-3">
<h3 id="orge4b35b4"><span class="section-number-3">6.3</span> undefined behavior</h3>
<div class="outline-text-3" id="text-6-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">int</span> *<span style="color: #a0522d;">p</span> = 0; <span style="color: #b22222;">// </span><span style="color: #b22222;">null pointer</span>
<span style="color: #008b8b;">std</span>::cout &lt;&lt; *p; <span style="color: #b22222;">// </span><span style="color: #b22222;">UNDEFINED dereferencing a null pointer</span>
<span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[] = <span style="color: #8b2252;">"Carla"</span>;
<span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span> = name[10]; <span style="color: #b22222;">// </span><span style="color: #b22222;">UNDEFINED invalid array index</span>
</pre>
</div>

<p>
They most come from pointer and address.
</p>
</div>
</div>


<div id="outline-container-orgad0acac" class="outline-3">
<h3 id="orgad0acac"><span class="section-number-3">6.4</span> Best Practices</h3>
<div class="outline-text-3" id="text-6-4">
</div>
<div id="outline-container-orgc56bcfe" class="outline-4">
<h4 id="orgc56bcfe"><span class="section-number-4">6.4.1</span> compilation dependence</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
The change of a single class can lead to a large amount of file to recompile,
because:
</p>

<ul class="org-ul">
<li>Inheritance</li>
<li>Use another class inside a class</li>
</ul>
</div>

<div id="outline-container-orga046a84" class="outline-5">
<h5 id="orga046a84"><span class="section-number-5">6.4.1.1</span> Forward-declaration doesn't work.</h5>
<div class="outline-text-5" id="text-6-4-1-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>;
  <span style="color: #228b22;">Person</span> <span style="color: #0000ff;">p</span>(params);
}
</pre>
</div>

<p>
Forward-declaration cannot make it because this is a define,
compiler need to know the size.
</p>
</div>
</div>

<div id="outline-container-org73ab5ef" class="outline-5">
<h5 id="org73ab5ef"><span class="section-number-5">6.4.1.2</span> Why Java don't have such problem?</h5>
<div class="outline-text-5" id="text-6-4-1-2">
<p>
Java treat the above code as
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>;
  <span style="color: #228b22;">Person</span> * <span style="color: #a0522d;">p</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org44c0d5c" class="outline-5">
<h5 id="org44c0d5c"><span class="section-number-5">6.4.1.3</span> Solution 1: pimpl(Pointer to implementation)</h5>
<div class="outline-text-5" id="text-6-4-1-3">
<p>
In C++, we can of course play the
"hide the object implementation behind a pointer" game ourself.
</p>

<p>
The key: <span class="underline">replacement of dependencies on definitions with dependencies on declarations.</span>
</p>

<ul class="org-ul">
<li>avoid using objects when object references and pointers will do</li>
<li>depend on class declarations instead of class definitions whenever you can</li>
</ul>

<p>
Note: you never need a class definition to declare a function using that class,
not even if the function passes or returns the class type by value:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Date</span>;
<span style="color: #228b22;">Date</span> <span style="color: #0000ff;">today</span>();
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">clearAppointment</span>(<span style="color: #228b22;">Date</span> <span style="color: #a0522d;">d</span>);
</pre>
</div>

<p>
Because if anybody calls those functions, Date's definition must have been seen prior to the call.
So it is not that nobody calls them, it's that not everybody calls them.
</p>

<ul class="org-ul">
<li>provide separate header flies for declarations and definitions</li>
</ul>

<p>
Classes that employ the pimpl idiom are often called Handle Classes.
</p>
</div>

<ol class="org-ol">
<li><a id="orgb2a85cb"></a>Example:<br />
<div class="outline-text-6" id="text-6-4-1-3-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;memory&gt;</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">PersonImpl</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">forward decl</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Date</span>;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Address</span>;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Person</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #0000ff;">Person</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">name</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Date</span>&amp; <span style="color: #a0522d;">birthday</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Address</span>&amp; <span style="color: #a0522d;">addr</span>);
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">name</span>() <span style="color: #a020f0;">const</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">birthDate</span>() <span style="color: #a020f0;">const</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">address</span>() <span style="color: #a020f0;">const</span>;
<span style="color: #a020f0;">private</span>:
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">shared_ptr</span>&lt;<span style="color: #228b22;">PersonImpl</span>&gt; <span style="color: #a0522d;">pImpl</span>;
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"Person.h"</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">we need include PersonImpl.h in order to call the member function</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">PersonImpl has exactly the same API</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"PersonImpl.h"</span>
<span style="color: #008b8b;">Person</span>::<span style="color: #0000ff;">Person</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">name</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Date</span>&amp; <span style="color: #a0522d;">birthday</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Address</span>&amp; <span style="color: #a0522d;">addr</span>)
: pImpl(<span style="color: #a020f0;">new</span> <span style="color: #228b22;">PersonImpl</span>(name, birthday, addr)) {}

<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #008b8b;">Person</span>::<span style="color: #0000ff;">name</span>() <span style="color: #a020f0;">const</span> {
  <span style="color: #a020f0;">return</span> pImpl-&gt;name();
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org4abe903" class="outline-5">
<h5 id="org4abe903"><span class="section-number-5">6.4.1.4</span> Solution 2: Interface Class</h5>
<div class="outline-text-5" id="text-6-4-1-4">
<p>
The implementation of non-virtual functions should be the same for all classes in a hierarchy,
so it makes sense to implement such functions as part of the Interface class.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Person</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #a020f0;">virtual</span> ~<span style="color: #0000ff;">Person</span>();
  <span style="color: #a020f0;">virtual</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">name</span>() <span style="color: #a020f0;">const</span> = 0;
  <span style="color: #a020f0;">virtual</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">birthDate</span>() <span style="color: #a020f0;">const</span> = 0;
  <span style="color: #a020f0;">virtual</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">address</span>() <span style="color: #a020f0;">const</span> = 0;

  <span style="color: #a020f0;">static</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">shard_ptr</span>&lt;<span style="color: #228b22;">Person</span>&gt;
  <span style="color: #0000ff;">create</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">name</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Date</span>&amp; <span style="color: #a0522d;">birthday</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Address</span>&amp; <span style="color: #a0522d;">addr</span>);
};
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">shared_ptr</span>&lt;<span style="color: #228b22;">Person</span>&gt;
<span style="color: #0000ff;">create</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">name</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Date</span>&amp; <span style="color: #a0522d;">birthday</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Addrss</span>&amp; <span style="color: #a0522d;">addr</span>) {
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::shared_ptr&lt;<span style="color: #228b22;">Person</span>&gt;(<span style="color: #a020f0;">new</span> <span style="color: #228b22;">RealPerson</span>(name, birthday, addr));
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">RealPerson</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Person</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #0000ff;">RealPerson</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">name</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Date</span>&amp; <span style="color: #a0522d;">birthday</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Address</span>&amp; <span style="color: #a0522d;">addr</span>)
  : theName(name), theBirthDate(birthday), theAddress(addr) {}
  <span style="color: #a020f0;">virtual</span> ~<span style="color: #0000ff;">RealPerson</span>() {}

  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">name</span>() <span style="color: #a020f0;">const</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">implement</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">birthDate</span>() <span style="color: #a020f0;">const</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">address</span>() <span style="color: #a020f0;">const</span>;
<span style="color: #a020f0;">private</span>:
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">theName</span>;
  <span style="color: #228b22;">Date</span> <span style="color: #a0522d;">theBirthDate</span>;
  <span style="color: #228b22;">Address</span> <span style="color: #a0522d;">theAddress</span>;
};
</pre>
</div>

<p>
Clients of interface class need not recompile unless the Interface class's interface is modified.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org23c99b4" class="outline-3">
<h3 id="org23c99b4"><span class="section-number-3">6.5</span> coding standards</h3>
<div class="outline-text-3" id="text-6-5">
<p>
ref: <a href="https://isocpp.org/wiki/faq/coding-standards">https://isocpp.org/wiki/faq/coding-standards</a>
</p>
</div>

<div id="outline-container-org19a38df" class="outline-4">
<h4 id="org19a38df"><span class="section-number-4">6.5.1</span> &lt;xxx&gt; and &lt;xxx.h&gt;</h4>
<div class="outline-text-4" id="text-6-5-1">
<p>
C++ standard library is guaranteed to have 18 standard headers from C.
Two type of names: <code>&lt;cxxx&gt;</code> and <code>&lt;xxx.h&gt;</code>
</p>

<ul class="org-ul">
<li><code>&lt;cxxx&gt;</code>: provide in the <code>std</code> namespace only</li>
<li><code>&lt;xxx.h&gt;</code>: make them available in both <code>std</code> and global. <b><b>Deprecated</b></b></li>
</ul>
</div>
</div>

<div id="outline-container-org1da1f64" class="outline-4">
<h4 id="org1da1f64"><span class="section-number-4">6.5.2</span> using</h4>
<div class="outline-text-4" id="text-6-5-2">
<ul class="org-ul">
<li>using-directive: <code>using namespace std;</code>. Do not use.</li>
<li>using-declaration: <code>using std::cout;</code>. Can be used just as a statement, e.g. in a function.</li>
</ul>
</div>
</div>

<div id="outline-container-org8443d30" class="outline-4">
<h4 id="org8443d30"><span class="section-number-4">6.5.3</span> where to declare variables</h4>
<div class="outline-text-4" id="text-6-5-3">
<p>
Declare near the first use.
</p>

<p>
If you don't have enough information to initialize an object until the middle of the code,
create it there.
Don't initialize it to empty and reassign it later,
because performance.
</p>
</div>
</div>

<div id="outline-container-org7397c60" class="outline-4">
<h4 id="org7397c60"><span class="section-number-4">6.5.4</span> some lint-like guidelines</h4>
<div class="outline-text-4" id="text-6-5-4">
<ul class="org-ul">
<li>A class <code>Fred~s assignment operator should return ~*this</code> as a <code>Fred&amp;</code> (allows chaining of assignments)</li>
<li>A class with any virtual functions ought to have a virtual destructor</li>
<li>A class with any of the following generally needs all 5
<ul class="org-ul">
<li>destructor</li>
<li>copy assignment operator</li>
<li>copy constructor</li>
<li>move assignment operator</li>
<li>move constructor</li>
</ul></li>
<li>A class <code>Fred~s copy constructor and assignment operator should have const in the parameter: respectively ~Fred::Fred(const Fred&amp;)</code> and <code>Fred&amp; Fred::operator= (const Fred&amp;)</code></li>
<li>When initializing an objects member objects in the constructor, always use initialization lists rather than assignment. 3x performance.</li>
<li>Assignment operators should make sure that self assignment does nothing, otherwise you may have a disaster</li>
</ul>
</div>
</div>

<div id="outline-container-org54f6da0" class="outline-4">
<h4 id="org54f6da0"><span class="section-number-4">6.5.5</span> some crazy unix abbr</h4>
<div class="outline-text-4" id="text-6-5-5">
<p>
<code>abbr evthng n sght, usng vry shrt idntfr nms</code>
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org5811689" class="outline-2">
<h2 id="org5811689"><span class="section-number-2">7</span> C++ Standards</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org4201916" class="outline-3">
<h3 id="org4201916"><span class="section-number-3">7.1</span> C++11</h3>
<div class="outline-text-3" id="text-7-1">
</div>
<div id="outline-container-org0d83a72" class="outline-4">
<h4 id="org0d83a72"><span class="section-number-4">7.1.1</span> Default and Delete</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
The common idiom of "prohibiting copying" can now be expressed directly:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">X</span> {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>
  <span style="color: #228b22;">X</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">X</span>&amp;) = <span style="color: #a020f0;">delete</span>;        <span style="color: #b22222;">// </span><span style="color: #b22222;">Disallow copying</span>
  <span style="color: #0000ff;">X</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">X</span>&amp;) = <span style="color: #a020f0;">delete</span>;
};
</pre>
</div>

<p>
Conversely, we can also say explicitly that we want to default copy behavior:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Y</span> {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>
  <span style="color: #228b22;">Y</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Y</span>&amp;) = <span style="color: #a020f0;">default</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">default copy semantics</span>
  <span style="color: #0000ff;">Y</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Y</span>&amp;) = <span style="color: #a020f0;">default</span>;
};
</pre>
</div>

<p>
The "default" mechanism can be used for any function that has a default.
The "delete" mechanism can be used for any function.
But, just use them on copy constructor and assignment operator. 
</p>

<p>
Reference: <a href="http://www.stroustrup.com/C++11FAQ.html#default">http://www.stroustrup.com/C++11FAQ.html#default</a>
</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2017-11-20 Mon 10:50</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
