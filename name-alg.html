<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-07-20 Wed 14:12 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Name Algorithm</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style>
a:visited {color: red;}
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Name Algorithm</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline7">1. Aho Corasick</a>
<ul>
<li><a href="#orgheadline5">1.1. Construct Trie</a>
<ul>
<li><a href="#orgheadline1">1.1.1. Node</a></li>
<li><a href="#orgheadline2">1.1.2. Color</a></li>
<li><a href="#orgheadline3">1.1.3. blue arc</a></li>
<li><a href="#orgheadline4">1.1.4. Green Arc</a></li>
</ul>
</li>
<li><a href="#orgheadline6">1.2. Match Process</a></li>
</ul>
</li>
<li><a href="#orgheadline9">2. Barrel shifter</a>
<ul>
<li><a href="#orgheadline8">2.1. shift register</a></li>
</ul>
</li>
<li><a href="#orgheadline10">3. Bloom Filter</a></li>
<li><a href="#orgheadline14">4. Boyer Moore</a>
<ul>
<li><a href="#orgheadline11">4.1. Bad Character Rule</a></li>
<li><a href="#orgheadline12">4.2. Good Suffix Rule</a></li>
<li><a href="#orgheadline13">4.3. Galil Rule</a></li>
</ul>
</li>
<li><a href="#orgheadline15">5. Linear congruential generator</a></li>
<li><a href="#orgheadline17">6. prefix tree</a>
<ul>
<li><a href="#orgheadline16">6.1. Radix Tree</a></li>
</ul>
</li>
<li><a href="#orgheadline18">7. Rabin-Karp Algorithm</a></li>
<li><a href="#orgheadline21">8. Rolling Hash</a>
<ul>
<li><a href="#orgheadline19">8.1. Rabin-Karp rolling hash</a></li>
<li><a href="#orgheadline20">8.2. Cyclic Polynomial (Buzhash)</a></li>
</ul>
</li>
<li><a href="#orgheadline22">9. Tabulation hashing</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">1</span> Aho Corasick</h2>
<div class="outline-text-2" id="text-1">
<p>
It is a multiple string match algorithm. <code>fgrep</code> is based on this.
</p>
</div>


<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">1.1</span> Construct Trie</h3>
<div class="outline-text-3" id="text-1-1">

<div class="figure">
<p><img src="https://farm8.staticflickr.com/7572/16085105388_86fedb2235_o.png" alt="16085105388_86fedb2235_o.png" />
</p>
</div>

<p>
dictionary: <code>{a,ab,bab,bc,bca,c,caa}</code>
</p>
</div>

<div id="outline-container-orgheadline1" class="outline-4">
<h4 id="orgheadline1"><span class="section-number-4">1.1.1</span> Node</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
The data structure has one node for every prefix of every string in the dictionary.
So if (bca) is in the dictionary,
then there will be nodes for (bca), (bc), (b), and ().
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-4">
<h4 id="orgheadline2"><span class="section-number-4">1.1.2</span> Color</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
If a node is in the dictionary then it is blue node.
Otherwise it is a grey node.
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3"><span class="section-number-4">1.1.3</span> blue arc</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
a blue directed "suffix" arc from each node to the node that is the longest possible strict suffix of it in the graph.
For example, for node (caa), its strict suffixes are (aa) and (a) and ().
The longest of these that exists in the graph is (a).
So there is a blue arc from (caa) to (a).
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4"><span class="section-number-4">1.1.4</span> Green Arc</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
There is a green "dictionary suffix" arc from each node to the next node in the dictionary that can be reached by following blue arcs. For example, there is a green arc from (bca) to (a) because (a) is the first node in the dictionary (i.e. a blue node) that is reached when following the blue arcs to (ca) and then on to (a).
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">1.2</span> Match Process</h3>
<div class="outline-text-3" id="text-1-2">
<p>
At each step, the current node is extended by finding its child,
and if that doesn't exist, finding its suffix's child,
and if that doesn't work, finding its suffix's suffix's child,
and so on, finally ending in the root node if nothing's seen before.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9"><span class="section-number-2">2</span> Barrel shifter</h2>
<div class="outline-text-2" id="text-2">
<p>
A barrel shifter is a digital circuit that can shift a data word
by a specified number of bits in one clock cycle.
</p>


<div class="figure">
<p><img src="https://farm8.staticflickr.com/7578/16260221182_53a096f18c_o.png" alt="16260221182_53a096f18c_o.png" />
</p>
</div>

<p>
In the above image, x is input and y is output.
</p>

<p>
For shift 1, all the erjiguan on the green line exist, while others not.
</p>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">2.1</span> shift register</h3>
<div class="outline-text-3" id="text-2-1">

<div class="figure">
<p><img src="https://farm9.staticflickr.com/8671/16074934899_03921f148b_o.png" alt="16074934899_03921f148b_o.png" />
</p>
</div>

<p>
F0、F1、F2、F3是四个边沿触发的D触发器，每个触发器的输出端Q接到右边一个触发器的输入端D。
因为从时钟信号CP的上升沿加到触发器上开始到输出端新状态稳定地建立起来有一段延迟时间，
所以当时钟信号同时加到四个触发器上时，
每个触发器接收的都是左边一个触发器中原来的数据(F0接收的输入数据D1)。
寄存器中的数据依次右移一位。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10"><span class="section-number-2">3</span> Bloom Filter</h2>
<div class="outline-text-2" id="text-3">
<p>
It is used to judge whether an item is in a set or not.
</p>

<p>
If bloom() return false, it is false. But if bloom() return true,
it may not be true.
</p>

<p>
The basic idea is, hash(item), map it in a vector of m size.
The vector is 0 initially.
v[hash(item)] is set to 1.
To reduce fault rate, use k hash functions.
</p>

<p>
To verify, only if all k hash functions has 1 in the vector will it return true.
Otherwise return false.
</p>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">4</span> Boyer Moore</h2>
<div class="outline-text-2" id="text-4">
<p>
It is a string match algorithm.
</p>

<p>
The rule lookup is in a hash table,
which can be formed during proprocessing of pattern.
</p>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">4.1</span> Bad Character Rule</h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">

<pre class="src src-text">- - - - X - - K - - -
A N P A n M A N A M -
- N n A A M A N - - -
- - - N n A A M A N -
</pre>
</div>

<p>
from right end to left.
when a mismatch happens at `n`,
find to left a `n`, then shift it to the position.
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">4.2</span> Good Suffix Rule</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">

<pre class="src src-text">- - - - X - - K - - - - -
M A N P A n a m A N A P -
A n a m P n a m - - - - -
- - - - A n a m P N A M -
</pre>
</div>

<p>
when a mismatch happens,
<code>nam</code> is the longest good suffix.
Find <code>nam</code> to the left,
and shift it to the position.
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">4.3</span> Galil Rule</h3>
<div class="outline-text-3" id="text-4-3">
<p>
As opposed to shifting, the Galil rule deals with speeding up the actual comparisons done at each alignment by skipping sections that are known to match.
Suppose that at an alignment k1,
P is compared with T down to character c of T.
Then if P is shifted to k2 such that its left end is between c and k1,
in the next comparison phase a prefix of P must match the substring T[(k2 - n)..k1].
Thus if the comparisons get down to position k1 of T,
an occurrence of P can be recorded without explicitly comparing past k1.
In addition to increasing the efficiency of Boyer-Moore,
the Galil rule is required for proving linear-time execution in the worst case.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><span class="section-number-2">5</span> Linear congruential generator</h2>
<div class="outline-text-2" id="text-5">
<p>
A linear congruential generator (LCG)
is an algorithm that yields a sequence of pseudo-randomized numbers.
</p>

<p>
pseudorandom number generator algorithms(PRNG).
</p>

<p>
\(X_{n+1} = (aX_n+c) mod m\)
</p>

<p>
X array is the pseudorandom.
</p>

<ul class="org-ul">
<li>\(X_0\): seed</li>
<li><code>m</code>: modulus</li>
<li><code>a</code>: multiplier</li>
<li><code>c</code>: increment</li>
</ul>

<p>
If c = 0,
the generator is often called a multiplicative congruential generator (MCG),
or Lehmer RNG.
If c ≠ 0, the method is called a mixed congruential generator.
</p>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-2">
<h2 id="orgheadline17"><span class="section-number-2">6</span> prefix tree</h2>
<div class="outline-text-2" id="text-6">
<p>
Alias: <code>Trie</code>, <code>Prefix Tree</code>, <code>Radix Tree</code>
</p>

<p>
It is an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings
</p>



<div class="figure">
<p><img src="https://farm8.staticflickr.com/7527/16078670017_18478a43e5_o.png" alt="16078670017_18478a43e5_o.png" />
</p>
</div>
</div>


<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">6.1</span> Radix Tree</h3>
<div class="outline-text-3" id="text-6-1">
<p>
A radix tree (also patricia trie or radix trie or compact prefix tree) is a space-optimized trie data structure where each node with only one child is merged with its parent.
</p>

<p>
Unlike in regular tries, edges can be labeled with sequences of elements as well as single elements.
</p>


<div class="figure">
<p><img src="https://farm8.staticflickr.com/7533/16264560645_3ec5648d69_o.png" alt="16264560645_3ec5648d69_o.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18"><span class="section-number-2">7</span> Rabin-Karp Algorithm</h2>
<div class="outline-text-2" id="text-7">
<p>
It is a string searching algorithm.
</p>

<p>
The Naive Solution for string search:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #6434A3;">int</span> <span style="color: #006699;">func</span>(<span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">s</span>[], <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">n</span>, <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">pattern</span>[], <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">m</span>) {
  <span style="color: #6434A3;">char</span> *<span style="color: #BA36A5;">ps</span>,*<span style="color: #BA36A5;">pp</span>; <span style="color: #8D8D84;">//</span><span style="color: #8D8D84; font-style: italic;">*</span>
  ps=s;
  pp=pattern;
  <span style="color: #0000FF;">for</span> (i=0;i&lt;n-m+1;) {
    <span style="color: #0000FF;">if</span> (*pp==<span style="color: #008000;">'\0'</span>) <span style="color: #0000FF;">return</span> i; <span style="color: #8D8D84;">//</span><span style="color: #8D8D84; font-style: italic;">*</span>
    <span style="color: #0000FF;">if</span> (*ps == *pp) { <span style="color: #8D8D84;">//</span><span style="color: #8D8D84; font-style: italic;">*</span>
      ps++;pp++;
    } <span style="color: #0000FF;">else</span> {
      i++;
      ps=s+i;
      pp=pattern;
    }
  }
}
</pre>
</div>

<p>
The running time is \(O(mn)\).
</p>

<p>
The Rabin-Karp algorithm use hash for pattern match.
First calculate <code>hash(pattern)</code>.
Then for every s[i,i+m-1], calculate the hash.
Then compare them.
</p>

<p>
The key of the algorithm is the hash function.
If the hash function need time m to compute, then it is still \(O(mn)\).
If the collision happens often, then even if hash matches, we still need to verify.
</p>

<p>
Key point is to select a hast function, such that <code>hash(i,i+m-1)</code> can be computed
by <code>hash(i-1,i+m-2)</code>.
</p>

<p>
If add all characters' ASCII together, collision is often.
</p>

<p>
The used hash function is:
select a large prime as base, 101 for example.
Hash value is:
</p>

\begin{equation}
hash("abc") = ASCII('a')*101^2 + ASCII('b')*101^1 + ASCII('c')*101^0
\end{equation}

<p>
Rabin-Karp is not so good for single string match because the worst case is \(O(mn)\),
but it is the algorithm of choice for multiple pattern search.
</p>

<p>
K patterns, in a large string s, find any one of the K patterns.
</p>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-2">
<h2 id="orgheadline21"><span class="section-number-2">8</span> Rolling Hash</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19"><span class="section-number-3">8.1</span> Rabin-Karp rolling hash</h3>
</div>

<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20"><span class="section-number-3">8.2</span> Cyclic Polynomial (Buzhash)</h3>
<div class="outline-text-3" id="text-8-2">
<p>
<code>s(a)</code> means shift a left.
</p>

\begin{equation}
H=s^{k-1}(h(c_1)) \oplus s^{k-2}(h(c_2)) \oplus \ldots \oplus s(h(c_{k-1})) \oplus h(c_k)
\end{equation}

<p>
<code>h</code> is a tabulation hashing.
</p>

<p>
To remove \(c_1\) and add \(c_{k+1}\):
</p>

\begin{equation}
H = s(H) \oplus s^k(h(c_1)) \oplus h(c_{k+1})
\end{equation}
</div>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-2">
<h2 id="orgheadline22"><span class="section-number-2">9</span> Tabulation hashing</h2>
<div class="outline-text-2" id="text-9">
<p>
input key is <code>p</code> bits, output is <code>q</code> bits.
choose a <code>r</code> less then <code>p</code>, and \(t=\lceil p/r \rceil\).
</p>

<p>
view a key as t r-bit numbers. Use a lookup table filled with random values
to compute hash value for each of t numbers. Xor them together.
</p>

<p>
The choice of r should be made in such a way that this table is not too large,
so that it fits into the computer's cache memory.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2016-07-20 Wed 14:12</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
