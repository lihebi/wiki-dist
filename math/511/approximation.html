<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<<<<<<< HEAD
<!-- 2016-02-21 Sun 22:31 -->
=======
<!-- 2016-02-05 Fri 20:37 -->
>>>>>>> 244313a11161f375ada887ed118dedb052a956ef
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>approximation</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">approximation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline2">1. Vertex-cover</a>
<ul>
<li><a href="#orgheadline1">1.1. 证明这是2-ratio approximation solution</a></li>
</ul>
</li>
<li><a href="#orgheadline4">2. Traveling-salesman problem</a>
<ul>
<li><a href="#orgheadline3">2.1. 证明2-approximation</a></li>
</ul>
</li>
<li><a href="#orgheadline7">3. set covering</a>
<ul>
<li><a href="#orgheadline5">3.1. 证明 \(\rho(n)\)</a></li>
<li><a href="#orgheadline6">3.2. 引理</a></li>
</ul>
</li>
<li><a href="#orgheadline8">4. Randomization and Linear Programming</a></li>
<li><a href="#orgheadline10">5. Linear Programming for weighted vertex cover</a>
<ul>
<li><a href="#orgheadline9">5.1. 证明2-ratio</a></li>
</ul>
</li>
<li><a href="#orgheadline14">6. A fully polynomial time approximation scheme for subset sum</a>
<ul>
<li><a href="#orgheadline11">6.1. a fully polynomial time approximation scheme</a></li>
<li><a href="#orgheadline13">6.2. 证明此算法是a fully polynomial time approximation scheme</a>
<ul>
<li><a href="#orgheadline12">6.2.1. 1</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
对于NPC问题，既然我们解决不了，我们可以另辟溪径。有3种方法：
</p>
<ul class="org-ul">
<li>当input size很小时，我们可以解出来</li>
<li>有些special case可以在P内解出来。</li>
<li>可以找一个近似解。near optimal solution</li>
</ul>

<p>
那么，什么是近似解？\(C^*\)
</p>

<p>
an algorithm for a problem has an approximation ratio of \(\rho(n)\) if:
for input size n, 指标C表示该算法的结果，指标$C<sup>*</sup>$表示最佳值，那么我们有
</p>

<p>
\(max(\frac{C}{C^*}, \frac{C^*}{C}) \le \rho(n)\)
</p>

<p>
比如，满足条件的最大size理论是$C<sup>*</sup>$，而我的算法得$C=\frac{C^*}{2}$。那么$&rho;(n)=2$。
</p>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">1</span> Vertex-cover</h2>
<div class="outline-text-2" id="text-1">
<p>
找到一个点的集合，能cover住所有边。要使集合最小。
</p>

<div class="org-src-container">

<pre class="src src-text">C={}, E'=G.E
while E' != {} {
  pick an arbitrary edge (u,v) in E'
  C += {u,v} // add u and v to C
  &#20174;E'&#20013;&#21435;&#25481;&#25152;&#26377;&#21644;u&#25110;v&#26377;&#20851;&#30340;&#36793;
}
return C
</pre>
</div>

<p>
O(V+E)
</p>
</div>

<div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3">1.1</span> 证明这是2-ratio approximation solution</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>可以在P内完成。</li>
<li>对于选择的每条边(u,v)，设此集合为A。</li>
</ol>
<p>
那么A中不可能有同一个点出现两次（因为我们每次都会去掉任何有关的边。）
而optimal value是一个vertex cover，那么它一定可以cover A.
所以有\(|C^*| \ge |A|\).
而我们的$|C|=2|A|$。所以有\(|C|=2|A| \le 2|C^*|\)
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4"><span class="section-number-2">2</span> Traveling-salesman problem</h2>
<div class="outline-text-2" id="text-2">
<p>
现引入一个三角限制：\(c(u,w) \le c(u,v) + c(v,w)\)
</p>

<p>
TSP with triangle constraint: NPC, but has 2-approximation solution
TSP without triangle constraint: NPC, and no approximation unless P=NP
</p>

<div class="org-src-container">

<pre class="src src-plain">从G中随便找个点r
以r做prim算法，找最小生成树
此树的先序遍历序列
按序列顺序相连
</pre>
</div>

<p>
\(O(V^2)\)
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">2.1</span> 证明2-approximation</h3>
<div class="outline-text-3" id="text-2-1">
<p>
$H<sup>*</sup>$为最佳值。此$H<sup>*</sup>$对应的hamilton cycle，减去某一条边，必然得一棵最小生成树。
设T为我们找到的树。显然有\(c(T) < c(H^*)\).
</p>

<p>
定义一个full walk W为，遍历中走过的所有的边。这样每条边走过两次，去时一次，回来时一次。
有\(c(W) = 2c(T)\)
</p>


<div class="figure">
<p><img src="https://farm8.staticflickr.com/7575/15998247402_0675174c32_q.jpg" alt="15998247402_0675174c32_q.jpg" />
</p>
</div>

<p>
图中，full walk是: `abcbdbaea`
H是: `abcdea`
对于full walk中，去掉任何一个节点，相当于第三边直接相连了，会减少cost。
所以有\(c(H)<c(W)=2c(T)<2c(H^*)\)
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">3</span> set covering</h2>
<div class="outline-text-2" id="text-3">
<p>
X是点的集合，F是一组set。从F中选出一些set，可以cover住X中的所有的点。要求选出的最少。
</p>

<p>
GREEDY-SET-COVER
</p>

<div class="org-src-container">

<pre class="src src-text">&#27599;&#27425;&#20174;&#65318;&#20013;&#36873;&#20986;&#36825;&#26679;&#19968;&#20010;set&#65292;&#20854;&#21487;&#20197;&#20351;&#26032;&#22686;&#21487;&#20197;cover&#20303;&#30340;&#28857;&#25968;&#26368;&#22810;&#12290;
</pre>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">3.1</span> 证明 \(\rho(n)\)</h3>
<div class="outline-text-3" id="text-3-1">
\begin{equation}
\rho(n)=H(max{|S|, S \in F})
\end{equation}

<p>
其中\(H(d)=H_d=\sum_{i=1}^d \frac{1}{i}\), 即Harmonic Number.
</p>

<p>
证明：我们根据我们的贪娄算法，对每一个点\(x\in X\) assign一个cost \(C_x\).
每次不是新增cover了n个点吗？那么这几个点平分cost=1。
比如新增两个点，就每个是1/2。这样分完后，我们的结果集\(|\phi|=\sum_{x \in X} c_x\).
而对于optimal $&phi;<sup>*</sup>$，因为它能cover住X，所以有
</p>

\begin{equation}
\sum_{S\in \phi^*} \sum_{x \in S} c_x \ge \sum_{x \in X} c_x = |\phi|
\end{equation}

<p>
我们还会证明\(\sum_{x \in S} c_x \le H(|S|)\).
这样就有\(|\phi| \le \sum_{S\in \phi^*} H(|S|) \le \sum_{S\in \phi^*} H(max{|S|, S \in F}) = |\phi^*| H(...)\)
</p>

<p>
下面来证明\(\sum_{x \in S} c_x \le H(|S|)\)
</p>

<p>
对于任意一个Ｓ，用$u<sub>i</sub>$表示经过选择$S<sub>1</sub>, S<sub>2</sub>, \ldots, S<sub>i</sub>$后，S中还剩下没被cover的数目。
有：$u<sub>0</sub>=|S|$。也必然存在一个k，使得$u<sub>k</sub>=0$但\(u_{k-1} \neq 0\).
k之后的就和S无关了。Ｓ中在$S<sub>i</sub>$时被新cover的有$u<sub>i</sub>-u<sub>i-1</sub>$个。有
</p>

\begin{equation}
\sum_{x \in S} c_x = \sum_1^k (u_{i-1}-u_i) \frac{1}{|S_i-(S_1 \vee S_2 \ldots \vee S_{i-1})|}
\end{equation}

<p>
$S<sub>i</sub>$是增加新cover最多的，所以\(|S_i-(S_1 \vee S_2 \ldots \vee S_{i-1})| \ge |S-(S_1 \vee S_2 \ldots \vee S_{i-1})| = u_{i-1}\)
</p>

\begin{eqnarray}
& & \sum_{x \in S} c_x \le \sum_{i=1}^k (u_{i-1}-u_i) \frac{1}{u_{i-1}} \\ 
& = &  \sum_1^k \sum_{j=u_i+1}^{u_{i-1}} \frac{1}{u_{i-1}} \\
& \le & \sum_1^k \sum_{j=u_i+1}^{u_{i-1}} \frac{1}{j} (because u_{i-1}>j) \\
& = & \sum_1^k(\sum_{j=1}^{u_{i-1}} \frac{1}{j} - \sum_{j=1}^{u_i} \frac{1}{j}) \\
& = & \sum_1^k (H(u_{i-1})-H(u_i)) \\
& = & H(u_0)-H(u_k) = H(u_0)-H(0)=H(u_0)=H(|S|)
\end{eqnarray}
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">3.2</span> 引理</h3>
<div class="outline-text-3" id="text-3-2">
<p>
我们注意到，$&sum;<sub>1</sub><sup>n</sup> \frac{1}{i} &le; ln(n) +1$，有\(\rho(n) = (ln{|X|}+1)\)
</p>

<p>
证明：
</p>
\begin{equation}
\sum_1^n \frac{1}{i} = 1 + \sum_2^n \frac{1}{i} \le 1+ \int_1^n \frac{1}{x} dx = 1+ln(n)
\end{equation}
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><span class="section-number-2">4</span> Randomization and Linear Programming</h2>
<div class="outline-text-2" id="text-4">
<p>
Randomization for MAX-3-CNF satisfiability(n个变量，m个clause)
</p>

<p>
对一个3-CNF部题，我们考虑一个assignment，使为1的clause最多。
</p>

<p>
解：匀假设一个clause
</p>

<ul class="org-ul">
<li>不含$x<sub>i</sub>$和\(\neg x_i\)</li>
<li>至少含1个变量</li>
</ul>

<p>
对每个$x<sub>i</sub>$，其为1的概率为1/2，为0的概率为1/2.
每个clause里所有变量的取值是相互独立的。
所以第i个clause为1的概率\(E(Y_i) = (1-(1/2)^3) = 7/8\)
为1的clause个数 \(E(Y) = m E(Y_i) = 7m/8\).
最佳值的上限是m。所以ratio=8/7.
</p>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10"><span class="section-number-2">5</span> Linear Programming for weighted vertex cover</h2>
<div class="outline-text-2" id="text-5">
<p>
问题：每个点都有一个权值，我们要找一个vertex cover，其权值是所有vertex cover中最小的。
</p>

<p>
解：用w(v)代表v的权值，x(v)=0: 不在C中 =1: 在C中。其中C为vertex cover
</p>

\begin{equation}
minimize \quad \sum_{v\in V} w(v)x(v)
subject to
\qquad x(u) + x(v) \ge 1
\qquad x(v) \in {0,1}
\end{equation}

<p>
把它化为连续问题
</p>

\begin{equation}
minimize \quad \sum_{v\in V} w(v)x(v)
subject to
\qquad x(u) + x(v) \ge 1
\qquad 0 \le x(v) \le 1
\end{equation}


<p>
(1)的解都满足(2)，所以(2)的解是(1)的lower bound.
可以在P内得到(2)的解。
</p>

<p>
然后如果$(\overline{x}(v) &ge; 1/2)$，则包括在C中。
因为$x(u)+x(v) &ge; 1$，则必然有1个是$&ge; 1/2$的。
故满足(1).
</p>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">5.1</span> 证明2-ratio</h3>
<div class="outline-text-3" id="text-5-1">
<p>
设$z<sup>*</sup>$为(2)的解，有\(z^* \le w(C^*)\)
有：
</p>

\begin{equation}
z^* = \sum w(v) \overline{x}(v) \ge \sum_{\overline{x}(v) \ge 1/2} w(v) \frac{1}{2}
= \frac{1}{2} \sum_C w(v) = \frac{1}{2} w(c)
\end{equation}
</div>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">6</span> A fully polynomial time approximation scheme for subset sum</h2>
<div class="outline-text-2" id="text-6">
<p>
Problem: &lt;s,t&gt; 从S中找一个子集，使其sum尽量大，但不大于t。
</p>

<p>
什么是 $(1+&epsilon;)$-approximation fully polynomial time approximation scheme:
running time is P to both \(\frac{1}{\epsilon}\) and n.
</p>

<p>
EXACT-SUBSET-SUM(S,t)
</p>

<div class="org-src-container">

<pre class="src src-text">let L[i] denote x[0]-x[i]&#30340;&#25152;&#26377;sum&#21487;&#33021;&#24615;(&lt;=t&#30340;)&#12290;
&#37027;&#20040;&#26377; L[i] = Merge-List(L[i-1], L[i-1]+x[i])
&#20877;&#21435;&#25481;L[i]&#20013;&#22823;&#20110;t&#30340;&#12290;


L[0] = {0}
for i=1 to n
  L[i] = MergeList(L[i-1], L[i-1]+x[i])
  L[i].remove(x[i]&gt;=t)
return largest in L[n]
</pre>
</div>

<p>
运行时间指数级，因为L[i]可能有2<sup>i个值</sup>。
</p>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">6.1</span> a fully polynomial time approximation scheme</h3>
<div class="outline-text-3" id="text-6-1">
<p>
每次生成L时，对其做一个trim: 对任意一个y，如果L中有一个z使
\(\frac{y}{1+ \delta} \le z \le y\),则将y删去。
</p>

<p>
TRIM(L,delta)
</p>

<div class="org-src-container">

<pre class="src src-plain">L' = {y}
last = y
for i = 2 to m
  if y[i] &gt; last * (1+delta)
    L' += y[i]
    last = y[i]
</pre>
</div>

<p>
APPROX-SUBSET-SUM(S,t,epsilon)
</p>

<div class="org-src-container">

<pre class="src src-text">L[0] = {0}
for i=1 to n
  L[i] = MergeList(L[i-1], L[i-1]+x[i])
  L[i] = TRIM(L[i], epsilon/2n)
  L[i].remove(x[i]&gt;=t)
return largest in L[n]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">6.2</span> 证明此算法是a fully polynomial time approximation scheme</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Denote:
</p>

<ul class="org-ul">
<li>\(z^*\): 我们的值</li>
<li>\(y^*\): 真正的值</li>
<li>\(P_i\): $x<sub>0</sub> ~ x<sub>i</sub>$相加的氖可能性</li>
<li>\(L_i\): 迭代中产生的</li>
</ul>

<p>
需要证明：
</p>

<ol class="org-ol">
<li>是$(1+&epsilon;)$-ratio的</li>
<li>running time is P to both \(\frac{1}{\epsilon}\) and n</li>
</ol>

<p>
证明：
</p>
</div>

<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12"><span class="section-number-4">6.2.1</span> 1</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
显然\(z^* < y^*\).现证明\(\frac{y^*}{z^*} \le 1+\epsilon\).
</p>

<p>
我们之后证明，对任意$y &isin; P<sub>i</sub>$且\(y \le t\),存在\(z \in L_i\) that
\(\frac{y}{(1+\frac{\epsilon}{2n})^i} \le z \le y\) (1)
</p>

<p>
既然对任意y有(1)，则对\(y^* \in P_n\) 也有\(\frac{y^*}{(1+\frac{\epsilon}{2n})^i} \le z \le y\)
</p>

<p>
所以\(y^*/z \le (1+\delta)^n\)
</p>

<p>
又\(\forall z \le z^*\)
所以 \(y^*/z^* \le y^*/z \le (1+\delta)^n = (1+\frac{\epsilon}{2n})^n\)
</p>

<p>
已经有\(y^*/z^* \le (1+\frac{\epsilon}{2n})^n\)
现证明\(\frac{d}{dn} (1+\epsilon/2n)^n >0\),即单增。
</p>

\begin{equation}
f(n)=(1+\frac{a}{n})^n
ln(f(n)) = n ln(1+\frac{a}{n})
\frac{f'(n)}{f(n)} = ln(1+\frac{a}{n}) - \frac{a}{n+a}
\end{equation}

<p>
只需证明\(ln(1+a/n) - \frac{a}{n+a} >0\)
</p>

\begin{equation}
ln(1+\frac{a}{n}) = ln(\frac{n+a}{n}) = ln(x) |_n^{n+a} = \int_n^{n+a} \frac{1}{x}dx
\end{equation}

<p>
由图得\(\int_n^{n+a} \frac{1}{x} dx > \frac{a}{n+a}\)
</p>

<p>
有结论\(lim_{n->\infty} (1+\frac{\epsilon}{2n})^n = e^{\frac{\epsilon}{2}} \quad (3.14)\)
所以
</p>

\begin{equation}
(1+\frac{\epsilon}{2n})^n \le e^{\frac{\epsilon}{2}}
\le 1+\frac{\epsilon}{2} + (\frac{\epsilon}{2})^2 \quad (3.13)
\le 1+\epsilon
\end{equation}

<p>
#### 证明(1)
</p>

<p>
用$&delta;$代替\(\frac{\epsilon}{2n}\)
</p>

<p>
假设对i-1，此式成立，即对$y' &isin; P<sub>i-1</sub>$中&lt;=t的，
存在z使\(\frac{y'}{(1+\frac{\epsilon}{2n})^i} \le z' \le y'\)
</p>

<p>
那么对i，此时的y有两种可能
</p>

<ol class="org-ol">
<li>y是某一个y'</li>
</ol>

<p>
那么对这个y'，在i-1中有一个z'满足上式。在Li中，z'可能没了，但一定有一个$z &isin; L<sub>i</sub>$使
\(z \le z' \le (1+\delta)\)
</p>

<p>
那么我们有, \(y' \ge z' \ge z\)
且\(\frac{y'}{(1+\delta)^i} \le z'/(1+\delta) \le z\)
</p>

<ol class="org-ol">
<li>y是某一个\(y'+x_i\)</li>
</ol>

<p>
那么这个y'对应的z'，在Li中，trim之前一定有\(z'+x_i\)
(它不会被trim掉，因为\(z'\le y'\),而$y'+x<sub>i</sub>$没被trim)
trim之后，也必然有一个$z &isin; L<sub>i</sub>$使
\(z \le z'+x_i \le z(1+\delta)\)
</p>

<p>
那么我们有\(y=y'+x_i \ge z'+x_i \ge z\)
所以
</p>

\begin{equation}
\frac{y}{(1+\delta)^i} = \frac{y'+x_i}{(1+\delta)^i} \le \frac{z'}{1+\delta} + \frac{x_i}{(1+\delta)^i} \le \frac{z'}{1+\delta} + \frac{x_i}{1+\delta} \le z
\end{equation}

<p>
#### 2
因为trim的原因，那么在Li中两个数之间要大于$1+\frac{\epsilon}{2n}$倍。
所以Li中共有$&lfloor; log<sub>1+\frac{\epsilon}{2n}</sub> t &rfloor;+2$个数（加0和1）。
</p>

\begin{equation}
log_{1+\frac{\epsilon}{2n}} t +2 = \frac{ln(t)}{ln(1+\frac{\epsilon}{2n})} +2
\le \frac{2n(1+\frac{\epsilon}{2n})ln(t)}{\epsilon} +2
\le \frac{3nln(t)}{\epsilon}+2
\end{equation}
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<<<<<<< HEAD
<p class="date">Created: 2016-02-21 Sun 22:31</p>
=======
<p class="date">Created: 2016-02-05 Fri 20:37</p>
>>>>>>> 244313a11161f375ada887ed118dedb052a956ef
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
