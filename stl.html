<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-09-06 Wed 22:50 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>STL</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="assets/hebi.css" /><link rel="stylesheet" type="text/css" href="assets/test.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">STL</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6fcb88c">1. Functional</a>
<ul>
<li><a href="#org3b4f82a">1.1. hash</a></li>
</ul>
</li>
<li><a href="#org2b9c9f3">2. Containers</a>
<ul>
<li><a href="#org63b62d9">2.1. Comparison</a>
<ul>
<li><a href="#org35f2cc2">2.1.1. convert set to vector</a></li>
</ul>
</li>
<li><a href="#orgb7110cc">2.2. vector</a></li>
<li><a href="#orgd7bd56f">2.3. set</a>
<ul>
<li><a href="#org2e8bea0">2.3.1. unordered<sub>set</sub></a></li>
</ul>
</li>
<li><a href="#org00873a6">2.4. map</a>
<ul>
<li><a href="#org81f23fd">2.4.1. <code>multimap</code></a></li>
<li><a href="#orgf7056b9">2.4.2. unordered<sub>map</sub></a></li>
</ul>
</li>
<li><a href="#org2ebda7b">2.5. deque</a></li>
<li><a href="#orgded04e5">2.6. pass to legacy API</a>
<ul>
<li><a href="#orgb1512af">2.6.1. vector</a></li>
<li><a href="#org1a5a4d9">2.6.2. String</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9f215e0">3. Algorithms</a>
<ul>
<li><a href="#orgc9ee6a7">3.1. comparison function</a></li>
<li><a href="#org6ac771c">3.2. Algorithm</a>
<ul>
<li><a href="#org1e15a6c">3.2.1. <code>count</code> &amp; <code>count_if</code></a></li>
<li><a href="#orgc437ba9">3.2.2. <code>std::find</code></a></li>
<li><a href="#org85afd1c">3.2.3. <code>std::find_if</code></a></li>
<li><a href="#org3c633d4">3.2.4. for</a></li>
<li><a href="#org5b6cb72">3.2.5. <code>std::for_each</code></a></li>
<li><a href="#org161ef4f">3.2.6. <code>mem_fun</code></a></li>
<li><a href="#org7ec9d2a">3.2.7. <code>std::move</code></a></li>
<li><a href="#org0c05fd2">3.2.8. not1</a></li>
<li><a href="#orge22f6e8">3.2.9. reverse</a></li>
<li><a href="#orgbbcd9fc">3.2.10. sort</a>
<ul>
<li><a href="#orgb997d99">3.2.10.1. <code>partition</code></a></li>
<li><a href="#org4a967d2">3.2.10.2. <code>nth_element</code></a></li>
<li><a href="#org55da623">3.2.10.3. <code>partial_sort</code></a></li>
</ul>
</li>
<li><a href="#orgc5283fb">3.2.11. transform</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org061cdab">4. Idioms</a>
<ul>
<li><a href="#orgeda9520">4.1. erase-remove idiom</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org6fcb88c" class="outline-2">
<h2 id="org6fcb88c"><span class="section-number-2">1</span> Functional</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org3b4f82a" class="outline-3">
<h3 id="org3b4f82a"><span class="section-number-3">1.1</span> hash</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<code>unordered_set</code> require to hash the items, but std::pair does not have a hash to apply.
</p>
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">my_hash</span> {
  <span style="color: #a020f0;">inline</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">()</span> (<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span>&lt;<span style="color: #228b22;">int</span>, <span style="color: #228b22;">int</span>&gt; &amp;<span style="color: #a0522d;">p</span>) <span style="color: #a020f0;">const</span> {
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">hash</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">hasher</span>;
    <span style="color: #a020f0;">return</span> hasher(p.first) ^ hasher(p.second);
  }
};
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unordered_set</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span>&lt;<span style="color: #228b22;">int</span>, <span style="color: #228b22;">int</span>&gt;, <span style="color: #228b22;">my_hash</span>&gt; <span style="color: #a0522d;">s</span>;
</code></pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2b9c9f3" class="outline-2">
<h2 id="org2b9c9f3"><span class="section-number-2">2</span> Containers</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org63b62d9" class="outline-3">
<h3 id="org63b62d9"><span class="section-number-3">2.1</span> Comparison</h3>
<div class="outline-text-3" id="text-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">container</th>
<th scope="col" class="org-left">time complexity</th>
<th scope="col" class="org-left">iterator validity</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>vector</code></td>
<td class="org-left">constant at beginning, linear in middle and end</td>
<td class="org-left">Memory allocate; Insert at beginning and middle</td>
</tr>

<tr>
<td class="org-left"><code>deque</code></td>
<td class="org-left">constant at beginning and end, linear in the middle</td>
<td class="org-left">All insertions; Erase in middle.</td>
</tr>

<tr>
<td class="org-left"><code>set</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">erase invalidates the element removed</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org35f2cc2" class="outline-4">
<h4 id="org35f2cc2"><span class="section-number-4">2.1.1</span> convert set to vector</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
<code>std::copy</code> doesn't add elements to the container into which you are inserting: it can't; it only has an iterator into the container.
Because of this, if you pass an output iterator directly to <code>std::copy</code>, you must make sure it points to a range that is at least large enough to hold the input range.
</p>

<p>
<code>std::back_inserter</code> creates an output iterator that calls push<sub>back</sub> on a container for each element, so each element is inserted into the container.
Alternatively, you could have created a sufficient number of elements in the std::vector to hold the range being copied.
</p>
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">method 1</span>
<span style="color: #008b8b;">std</span>::copy(input.begin(), input.end(), <span style="color: #008b8b;">std</span>::back_inserter(output));
<span style="color: #b22222;">// </span><span style="color: #b22222;">method 2</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">note that std::copy will NOT allocate memory</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">so make sure the vector is large enough before copy</span>
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #0000ff;">output</span>(input.size());
<span style="color: #008b8b;">std</span>::copy(input.begin(), input.end(), output.begin());
<span style="color: #b22222;">// </span><span style="color: #b22222;">method 3</span>
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #0000ff;">output</span>(input.begin(), input.end()); 
</code></pre>
</div>

<p>
reference: <a href="http://stackoverflow.com/questions/5034211/c-copy-set-to-vector">http://stackoverflow.com/questions/5034211/c-copy-set-to-vector</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orgb7110cc" class="outline-3">
<h3 id="orgb7110cc"><span class="section-number-3">2.2</span> vector</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Time complexity: constant time insertion or removal at the end, linear at the beginning or middle.
</p>

<p>
Iterator invalidity: Memory will be allocated automatically, which, when happens, invalidates all iterators.
Reserve() causes a reallocation manually.
inserting or deleting an element in the middle of a vector invalidates all iterators that point to elements <i>following the insertion or deletion point</i>.
</p>

<p>
The initiation of vector can have the following forms:
</p>
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #b22222;">// </span><span style="color: #b22222;">ONLY WITH C++11, compile with flag =-std=c++11=</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">1</span>
<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">v</span> {1,2,3};
<span style="color: #b22222;">// </span><span style="color: #b22222;">2</span>
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">row</span>,<span style="color: #a0522d;">col</span>;
<span style="color: #228b22;">vector</span>&lt; <span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; &gt; <span style="color: #0000ff;">heights</span>(row, vector&lt;<span style="color: #228b22;">int</span>&gt;(<span style="color: #a0522d;">col</span>));
<span style="color: #b22222;">// </span><span style="color: #b22222;">3</span>
<span style="color: #228b22;">char</span> <span style="color: #a0522d;">init</span>[] = <span style="color: #8b2252;">"1111"</span>;
<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">char</span>&gt; <span style="color: #0000ff;">v</span>(init, <span style="color: #228b22;">end</span>(<span style="color: #a0522d;">init</span>)-1); <span style="color: #b22222;">// </span><span style="color: #b22222;">remove '\0'</span>
</code></pre>
</div>

<p>
Reserve() causes a reallocation manually.
The main reason for using reserve() is efficiency: if you know the capacity to which your vector must eventually grow,
then it is usually more efficient to allocate that memory all at once rather than relying on the automatic reallocation scheme.
The other reason for using reserve() is so that you can control the invalidation of iterators
</p>

<p>
Do not use <code>vector&lt;bool&gt;</code>.
It actually not store bool,
but proxy object, as the design to save space.
</p>
</div>
</div>

<div id="outline-container-orgd7bd56f" class="outline-3">
<h3 id="orgd7bd56f"><span class="section-number-3">2.3</span> set</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Set has the important property that inserting a new element into a set does not invalidate iterators that point to existing elements.
Erasing an element from a set also does not invalidate any iterators, except, of course, for iterators that actually point to the element that is being erased.
</p>
</div>

<div id="outline-container-org2e8bea0" class="outline-4">
<h4 id="org2e8bea0"><span class="section-number-4">2.3.1</span> unordered<sub>set</sub></h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>Use hash, Constant complexity.</li>
<li>no specific order guarantee</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org00873a6" class="outline-3">
<h3 id="org00873a6"><span class="section-number-3">2.4</span> map</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The map is usually used as the following example:
</p>
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #228b22;">map</span>&lt;<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">m</span>;
m[2]=3;
m[3]=4;
<span style="color: #a020f0;">for</span>(map&lt;<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>&gt;::<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">it</span>=m.begin;it!=m.end();it++) {
  it-&gt;first;
  it-&gt;second;
}
</code></pre>
</div>

<p>
In a map, when using <code>[]</code> operator, the item will be inserted and init to default value for that type, e.g. 0 for a <code>int</code>.
</p>
</div>

<div id="outline-container-org81f23fd" class="outline-4">
<h4 id="org81f23fd"><span class="section-number-4">2.4.1</span> <code>multimap</code></h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
<code>multimap</code> do not have <code>[]</code> operator!
The following is an example for the usage of <code>multimap</code>:
</p>
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">multimap</span>&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">mymm</span>;

mymm.insert(<span style="color: #008b8b;">std</span>::pair&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt;(<span style="color: #8b2252;">'a'</span>,10));
mymm.insert(<span style="color: #008b8b;">std</span>::pair&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt;(<span style="color: #8b2252;">'b'</span>,20));
mymm.insert(<span style="color: #008b8b;">std</span>::pair&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt;(<span style="color: #8b2252;">'b'</span>,30));
mymm.insert(<span style="color: #008b8b;">std</span>::pair&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt;(<span style="color: #8b2252;">'b'</span>,40));
mymm.insert(<span style="color: #008b8b;">std</span>::make_pair(<span style="color: #8b2252;">'c'</span>,50));
mymm.insert(<span style="color: #008b8b;">std</span>::pair&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt;(<span style="color: #8b2252;">'c'</span>,60));
mymm.insert(<span style="color: #008b8b;">std</span>::pair&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt;(<span style="color: #8b2252;">'d'</span>,60));

<span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"mymm contains:\n"</span>;
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">char</span> <span style="color: #a0522d;">ch</span>=<span style="color: #8b2252;">'a'</span>; ch&lt;=<span style="color: #8b2252;">'d'</span>; ch++)
{
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span> &lt;<span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">multimap</span>&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt;::iterator, <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">multimap</span>&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt;::iterator&gt; <span style="color: #a0522d;">ret</span>;
  ret = mymm.equal_range(ch);
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; ch &lt;&lt; <span style="color: #8b2252;">" =&gt;"</span>;
  <span style="color: #a020f0;">for</span> (<span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">multimap</span>&lt;<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>&gt;::<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">it</span>=ret.first; it!=ret.second; ++it) {
    <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">' '</span> &lt;&lt; it-&gt;second;
  }
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">maybe it is helpful to just document some usage example</span>
<span style="color: #228b22;">multimap</span>&lt;<span style="color: #228b22;">int</span>, <span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">mm</span>;
mm.emplace(3, 8); <span style="color: #b22222;">// </span><span style="color: #b22222;">using std::pair constructor</span>
<span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">elem</span> : mm) {
  mm.first; <span style="color: #b22222;">// </span><span style="color: #b22222;">3</span>
  mm.second; <span style="color: #b22222;">// </span><span style="color: #b22222;">8</span>
}
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">range</span> = mm.equal_range(3);
<span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">it</span>=mm.begin();it!=mm.end();++it) {
  it-&gt;first; <span style="color: #b22222;">// </span><span style="color: #b22222;">3</span>
  it-&gt;second; <span style="color: #b22222;">// </span><span style="color: #b22222;">8</span>
}
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgf7056b9" class="outline-4">
<h4 id="orgf7056b9"><span class="section-number-4">2.4.2</span> unordered<sub>map</sub></h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>Use hash, constant complexity</li>
<li>no specific order guarantee</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org2ebda7b" class="outline-3">
<h3 id="org2ebda7b"><span class="section-number-3">2.5</span> deque</h3>
<div class="outline-text-3" id="text-2-5">
<p>
<code>deque</code> refers to <i>Double Ended Queue</i>.
It differs from <code>vector</code> in the sense that the insertion at the front is constant time.
Like <code>vector</code>, insertion in the end is constant, and insertion in the middle is <code>n</code>.
</p>

<p>
Iterator Validity:
</p>
<ul class="org-ul">
<li>Insert (including push<sub>front</sub> and push<sub>back</sub>) invalidates all iterators that refer to a deque.</li>
<li>Erase in the middle of a deque invalidates all iterators that refer to the deque.</li>
<li>Erase at the beginning or end of a deque (including pop<sub>front</sub> and pop<sub>back</sub>) invalidates an iterator only if it points to the erased element.</li>
</ul>
</div>
</div>

<div id="outline-container-orgded04e5" class="outline-3">
<h3 id="orgded04e5"><span class="section-number-3">2.6</span> pass to legacy API</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-orgb1512af" class="outline-4">
<h4 id="orgb1512af"><span class="section-number-4">2.6.1</span> vector</h4>
<div class="outline-text-4" id="text-2-6-1">
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">func</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span>* <span style="color: #a0522d;">pi</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">num</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">wrong, the size of v may be 0</span>
func(&amp;v[0], v.size());
<span style="color: #a020f0;">if</span> (!v.empty()) {
  func(&amp;v[0], v.size());
}
</code></pre>
</div>

<p>
do not use <code>v.begin()</code> instead of <code>&amp;v[0]</code>, because:
</p>

<ul class="org-ul">
<li>v.begin() is a iterator, not always a pointer</li>
<li><code>&amp;*v.begin()</code> is same as <code>&amp;v[0]</code>, but &#x2026;</li>
</ul>

<p>
Note, the legacy API should not add/remove items,
because no way for the container to know the size.
</p>
</div>
</div>

<div id="outline-container-org1a5a4d9" class="outline-4">
<h4 id="org1a5a4d9"><span class="section-number-4">2.6.2</span> String</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
Only vectors are guarnteed to have the same underlying memory layout as arrays.
String not.
</p>

<ul class="org-ul">
<li>data for strings is not guaranteed to be stored in contiguous memory.</li>
<li>is not guaranteed to be null terminated</li>
</ul>

<p>
so put the data into a <code>vector&lt;char&gt;</code> first, and use vector trick.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org9f215e0" class="outline-2">
<h2 id="org9f215e0"><span class="section-number-2">3</span> Algorithms</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgc9ee6a7" class="outline-3">
<h3 id="orgc9ee6a7"><span class="section-number-3">3.1</span> comparison function</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Always have comparison functions return false for equal values.
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #228b22;">set</span>&lt;<span style="color: #228b22;">int</span>, <span style="color: #228b22;">less_equal</span>&lt;<span style="color: #228b22;">int</span>&gt; &gt; <span style="color: #a0522d;">s</span>;
s.insert(10);
s.insert(10);
</code></pre>
</div>

<p>
check equivalence:
</p>

<div class="org-src-container">
<pre><code class="src src-C++">!(10A&lt;=10B) &amp;&amp; !(10B&lt;=10A);
!<span style="color: #008b8b;">true</span> &amp;&amp; !<span style="color: #008b8b;">true</span>
<span style="color: #008b8b;">false</span>
</code></pre>
</div>

<p>
a easy-to-made error:
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">()</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>* <span style="color: #a0522d;">ps1</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">string</span>* <span style="color: #a0522d;">ps2</span>) onst {
  <span style="color: #a020f0;">return</span> !(* ps1&lt;* ps2); <span style="color: #b22222;">// </span><span style="color: #b22222;">always pay attention to negative</span>
}
</code></pre>
</div>
</div>
</div>




<div id="outline-container-org6ac771c" class="outline-3">
<h3 id="org6ac771c"><span class="section-number-3">3.2</span> Algorithm</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org1e15a6c" class="outline-4">
<h4 id="org1e15a6c"><span class="section-number-4">3.2.1</span> <code>count</code> &amp; <code>count_if</code></h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span> &gt;
<span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">iterator_traits</span>&lt;<span style="color: #228b22;">InputIt</span>&gt;::<span style="color: #228b22;">difference_type</span>
<span style="color: #0000ff;">count</span>(
  <span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">first</span>,
  <span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">last</span>,
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span> &amp;<span style="color: #a0522d;">value</span>
);
<span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">UnaryPredicate</span> &gt;
<span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">iterator_traits</span>&lt;<span style="color: #228b22;">InputIt</span>&gt;::<span style="color: #228b22;">difference_type</span>
<span style="color: #0000ff;">count_if</span>(
  <span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">first</span>,
  <span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">last</span>,
  <span style="color: #228b22;">UnaryPredicate</span> <span style="color: #a0522d;">p</span>
);
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgc437ba9" class="outline-4">
<h4 id="orgc437ba9"><span class="section-number-4">3.2.2</span> <code>std::find</code></h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
Returns an iterator to the first element in the range [first,last) that compares equal to val. If no such element is found, the function returns last.
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIterator</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #228b22;">InputIterator</span> <span style="color: #0000ff;">find</span> (<span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">last</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">val</span>)
{
  <span style="color: #a020f0;">while</span> (first!=last) {
    <span style="color: #a020f0;">if</span> (*first==val) <span style="color: #a020f0;">return</span> first; <span style="color: #b22222;">//</span><span style="color: #b22222;">*</span>
    ++first;
  }
  <span style="color: #a020f0;">return</span> last;
}
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org85afd1c" class="outline-4">
<h4 id="org85afd1c"><span class="section-number-4">3.2.3</span> <code>std::find_if</code></h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Returns an iterator to the first element in the range [first,last) for which pred returns true. If no such element is found, the function returns last.
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIterator</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">UnaryPredicate</span>&gt;
<span style="color: #228b22;">InputIterator</span> <span style="color: #0000ff;">find_if</span> (<span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">InputIterator</span> <span style="color: #a0522d;">last</span>, <span style="color: #228b22;">UnaryPredicate</span> <span style="color: #a0522d;">pred</span>)
{
  <span style="color: #a020f0;">while</span> (first!=last) {
    <span style="color: #a020f0;">if</span> (pred(* first)) <span style="color: #a020f0;">return</span> first;
    ++first;
  }
  <span style="color: #a020f0;">return</span> last;
}
</code></pre>
</div>

<p>
for example
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">is_greater_than</span>
{
<span style="color: #a020f0;">public</span>:
  <span style="color: #0000ff;">is_greater_than</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span> &amp; <span style="color: #a0522d;">n</span>)
  : value(n)
{}

  <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">()</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span> &amp; <span style="color: #a0522d;">element</span>) <span style="color: #a020f0;">const</span>
{
  <span style="color: #a020f0;">return</span> element &gt; value;
}

<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">T</span> <span style="color: #a0522d;">value</span>;
};
</code></pre>
</div>

<p>
use here:
</p>

<div class="org-src-container">
<pre><code class="src src-C++">find_if (values.begin(), values.end(), is_greater_than&lt;<span style="color: #228b22;">int</span>&gt; (5)) != values.end();
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org3c633d4" class="outline-4">
<h4 id="org3c633d4"><span class="section-number-4">3.2.4</span> for</h4>
<div class="outline-text-4" id="text-3-2-4">
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">v</span>;
<span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">i</span> : v) {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">do with i</span>
}
</code></pre>
</div>

<p>
here <code>auto</code> means <code>vector&lt;int&gt;::value_type</code>.
</p>

<p>
is equal-valent to:
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">v</span>;
<span style="color: #a020f0;">for</span> (<span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt;::<span style="color: #228b22;">const_iterator</span> <span style="color: #a0522d;">it</span>=v.begin();it!=v.end();it++) {
  <span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">i</span>=*it; <span style="color: #b22222;">//</span><span style="color: #b22222;">*</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">do with i</span>
}
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org5b6cb72" class="outline-4">
<h4 id="org5b6cb72"><span class="section-number-4">3.2.5</span> <code>std::for_each</code></h4>
<div class="outline-text-4" id="text-3-2-5">
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">myfunction</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>) {  <span style="color: #b22222;">// </span><span style="color: #b22222;">function:</span>
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">' '</span> &lt;&lt; i;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">myclass</span> {           <span style="color: #b22222;">// </span><span style="color: #b22222;">function object type:</span>
  <span style="color: #228b22;">void</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">()</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>) {<span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">' '</span> &lt;&lt; i;}
} <span style="color: #a0522d;">myobject</span>;

<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">myvector</span>;

for_each (myvector.begin(), myvector.end(), myfunction);
for_each (myvector.begin(), myvector.end(), myobject);
for_each (v.begin(),v.end(),[](<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>) { cout&lt;&lt;i; });
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org161ef4f" class="outline-4">
<h4 id="org161ef4f"><span class="section-number-4">3.2.6</span> <code>mem_fun</code></h4>
<div class="outline-text-4" id="text-3-2-6">
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #228b22;">list</span>&lt;<span style="color: #228b22;">Widget</span>*&gt; <span style="color: #a0522d;">lpw</span>;
for_each(
  lpw.begin(),
  lpw.end(),
  <span style="color: #b22222;">// </span><span style="color: #b22222;">because the test is the member function of Widget</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">and we want to call it on all for_each item.</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">If no mem_fun, it can not compile</span>
  mem_fun(&amp;<span style="color: #008b8b;">Widget</span>::test)
);
</code></pre>
</div>

<p>
TODO:
</p>

<ul class="org-ul">
<li>ptr<sub>fun</sub></li>
<li>mem<sub>fun</sub><sub>ref</sub></li>
</ul>
</div>
</div>

<div id="outline-container-org7ec9d2a" class="outline-4">
<h4 id="org7ec9d2a"><span class="section-number-4">3.2.7</span> <code>std::move</code></h4>
<div class="outline-text-4" id="text-3-2-7">
<p>
<code>#include &lt;utility&gt;</code>
</p>

<p>
transfer ownership of the assets and properties of an object directly without having to copy them when the argument is an rvalue.
</p>

<p>
moved-from object is left in a valid but unspecified state
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">foo</span> = <span style="color: #8b2252;">"foo-string"</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">bar</span> = <span style="color: #8b2252;">"bar-string"</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&gt; <span style="color: #a0522d;">myvector</span>;
myvector.push_back (foo);                    <span style="color: #b22222;">// </span><span style="color: #b22222;">copies. foo remain.</span>
myvector.push_back (<span style="color: #008b8b;">std</span>::move(bar));         <span style="color: #b22222;">// </span><span style="color: #b22222;">moves. bar contain unspecified value.</span>
</code></pre>
</div>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>()
{
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">str</span> = <span style="color: #8b2252;">"Hello"</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&gt; <span style="color: #a0522d;">v</span>;

  <span style="color: #b22222;">// </span><span style="color: #b22222;">uses the push_back(const T&amp;) overload, which means</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">we'll incur the cost of copying str</span>
  v.push_back(str);
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"After copy, str is \""</span> &lt;&lt; str &lt;&lt; <span style="color: #8b2252;">"\"\n"</span>;

  <span style="color: #b22222;">// </span><span style="color: #b22222;">uses the rvalue reference push_back(T&amp;&amp;) overload,</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">which means no strings will be copied; instead, the contents</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">of str will be moved into the vector.  This is less</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">expensive, but also means str might now be empty.</span>
  v.push_back(<span style="color: #008b8b;">std</span>::move(str));
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"After move, str is \""</span> &lt;&lt; str &lt;&lt; <span style="color: #8b2252;">"\"\n"</span>;

  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"The contents of the vector are \""</span> &lt;&lt; v[0]
  &lt;&lt; <span style="color: #8b2252;">"\", \""</span> &lt;&lt; v[1] &lt;&lt; <span style="color: #8b2252;">"\"\n"</span>;

  <span style="color: #b22222;">// </span><span style="color: #b22222;">string move assignment operator is often implemented as swap,</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">in this case, the moved-from object is NOT empty</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">str2</span> = <span style="color: #8b2252;">"Good-bye"</span>;
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"Before move from str2, str2 = '"</span> &lt;&lt; str2 &lt;&lt; <span style="color: #8b2252;">"'\n"</span>;
  v[0] = <span style="color: #008b8b;">std</span>::move(str2);
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"After move from str2, str2 = '"</span> &lt;&lt; str2 &lt;&lt; <span style="color: #8b2252;">"'\n"</span>;
}
</code></pre>
</div>

<p>
Possible output:
</p>

<div class="org-src-container">
<pre><code class="src src-text">After copy, str is "Hello"
After move, str is ""
The contents of the vector are "Hello", "Hello"
Before move from str2, str2 = 'Good-bye'
After move from str2, str2 = 'Hello'
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org0c05fd2" class="outline-4">
<h4 id="org0c05fd2"><span class="section-number-4">3.2.8</span> not1</h4>
<div class="outline-text-4" id="text-3-2-8">
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Predicate</span> &gt;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unary_negate</span>&lt;<span style="color: #228b22;">Predicate</span>&gt; <span style="color: #0000ff;">not1</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Predicate</span>&amp; <span style="color: #a0522d;">pred</span>);
<span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Predicate</span> &gt;
<span style="color: #a020f0;">constexpr</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unary_negate</span>&lt;<span style="color: #228b22;">Predicate</span>&gt; <span style="color: #0000ff;">not1</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Predicate</span>&amp; <span style="color: #a0522d;">pred</span>);
</code></pre>
</div>

<p>
not1 is a helper function to create a function object that returns the complement of the unary predicate function passed.
</p>

<p>
example:
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">LessThan7</span> : <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unary_function</span>&lt;<span style="color: #228b22;">int</span>, <span style="color: #228b22;">bool</span>&gt;
{
  <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">()</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>) <span style="color: #a020f0;">const</span> { <span style="color: #a020f0;">return</span> i &lt; 7; }
};
<span style="color: #008b8b;">std</span>::not1(LessThan7());
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">function</span>&lt;<span style="color: #228b22;">int</span>(<span style="color: #228b22;">int</span>)&gt; <span style="color: #a0522d;">less_than_9</span> = [](<span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>){ <span style="color: #a020f0;">return</span> x &lt; 9; };
<span style="color: #008b8b;">std</span>::not1(less_than_9);
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orge22f6e8" class="outline-4">
<h4 id="orge22f6e8"><span class="section-number-4">3.2.9</span> reverse</h4>
<div class="outline-text-4" id="text-3-2-9">
<div class="org-src-container">
<pre><code class="src src-C++">reverse(v.begin(), v.end());
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgbbcd9fc" class="outline-4">
<h4 id="orgbbcd9fc"><span class="section-number-4">3.2.10</span> sort</h4>
<div class="outline-text-4" id="text-3-2-10">
<p>
Do not use <code>qsort</code> for some unknown reason..
</p>

<p>
faster to slower:
</p>

<ol class="org-ol">
<li>partition</li>
<li>stable<sub>partition</sub></li>
<li>nth<sub>element</sub></li>
<li>partial<sub>sort</sub></li>
<li>sort</li>
<li>stable<sub>sort</sub></li>
</ol>

<p>
stable means the order of equal element is guaranteed to maintain.
</p>
</div>

<div id="outline-container-orgb997d99" class="outline-5">
<h5 id="orgb997d99"><span class="section-number-5">3.2.10.1</span> <code>partition</code></h5>
<div class="outline-text-5" id="text-3-2-10-1">
<p>
The returned iterator is middle.
From first to middle, the predicate is true.
From middle to last, the predicate is false.
</p>

<p>
API:
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">BidirIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">UnaryPredicate</span> &gt;
<span style="color: #228b22;">BidirIt</span> <span style="color: #0000ff;">partition</span>(
  <span style="color: #228b22;">BidirIt</span> <span style="color: #a0522d;">first</span>,
  <span style="color: #228b22;">BidirIt</span> <span style="color: #a0522d;">last</span>,
  <span style="color: #228b22;">UnaryPredicate</span> <span style="color: #a0522d;">p</span>
);
<span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">ForwardIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">UnaryPredicate</span> &gt;
<span style="color: #228b22;">ForwardIt</span> <span style="color: #0000ff;">partition</span>(
  <span style="color: #228b22;">ForwardIt</span> <span style="color: #a0522d;">first</span>,
  <span style="color: #228b22;">ForwardIt</span> <span style="color: #a0522d;">last</span>,
  <span style="color: #228b22;">UnaryPredicate</span> <span style="color: #a0522d;">p</span>
);
</code></pre>
</div>
</div>
</div>


<div id="outline-container-org4a967d2" class="outline-5">
<h5 id="org4a967d2"><span class="section-number-5">3.2.10.2</span> <code>nth_element</code></h5>
<div class="outline-text-5" id="text-3-2-10-2">
<p>
The first n elements in the container are best, but not sorted.
</p>

<p>
API:
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">RandomIt</span> &gt;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">nth_element</span>(
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">first</span>,
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">nth</span>,
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">last</span>
);
<span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">RandomIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Compare</span> &gt;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">nth_element</span>(
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">first</span>,
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">nth</span>,
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">last</span>,
  <span style="color: #228b22;">Compare</span> <span style="color: #a0522d;">comp</span>
);
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org55da623" class="outline-5">
<h5 id="org55da623"><span class="section-number-5">3.2.10.3</span> <code>partial_sort</code></h5>
<div class="outline-text-5" id="text-3-2-10-3">
<p>
The first n elements in the container are the best, and in order.
</p>

<p>
API:
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">RandomIt</span> &gt;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">partial_sort</span>(
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">first</span>,
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">middle</span>,
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">last</span>
);
<span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">RandomIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Compare</span> &gt;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">partial_sort</span>(
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">first</span>,
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">middle</span>,
  <span style="color: #228b22;">RandomIt</span> <span style="color: #a0522d;">last</span>,
  <span style="color: #228b22;">Compare</span> <span style="color: #a0522d;">comp</span>
);
</code></pre>
</div>

<p>
example:
</p>

<div class="org-src-container">
<pre><code class="src src-C++">partial_sort(
  v.begin(),
  v.begin()+20,
  v.end(),
  compare
);
</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc5283fb" class="outline-4">
<h4 id="orgc5283fb"><span class="section-number-4">3.2.11</span> transform</h4>
<div class="outline-text-4" id="text-3-2-11">
<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">OutputIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">UnaryOperation</span> &gt;
<span style="color: #228b22;">OutputIt</span> <span style="color: #0000ff;">transform</span>(
  <span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">first1</span>,
  <span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">last1</span>,
  <span style="color: #228b22;">OutputIt</span> <span style="color: #a0522d;">d_first</span>,
  <span style="color: #228b22;">UnaryOperation</span> <span style="color: #a0522d;">unary_op</span>
);
<span style="color: #a020f0;">template</span>&lt; <span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIt1</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIt2</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">OutputIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">BinaryOperation</span> &gt;
<span style="color: #228b22;">OutputIt</span> <span style="color: #0000ff;">transform</span>(
  <span style="color: #228b22;">InputIt1</span> <span style="color: #a0522d;">first1</span>,
  <span style="color: #228b22;">InputIt1</span> <span style="color: #a0522d;">last1</span>,
  <span style="color: #228b22;">InputIt2</span> <span style="color: #a0522d;">first2</span>,
  <span style="color: #228b22;">OutputIt</span> <span style="color: #a0522d;">d_first</span>,
  <span style="color: #228b22;">BinaryOperation</span> <span style="color: #a0522d;">binary_op</span>
);
</code></pre>
</div>

<p>
<code>std::transform</code> applies the given function to a range and stores the result in another range, beginning at d<sub>first</sub>.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org061cdab" class="outline-2">
<h2 id="org061cdab"><span class="section-number-2">4</span> Idioms</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgeda9520" class="outline-3">
<h3 id="orgeda9520"><span class="section-number-3">4.1</span> erase-remove idiom</h3>
<div class="outline-text-3" id="text-4-1">
<p>
To erase certain elements in a container, the <code>remove</code> and <code>remove_if</code> is provided in <code>&lt;algorithm&gt;</code>.
Algorithms operate on a range of elements denoted by two forward iterators, they have no knowledge of the underlying container or collection.
Thus, no elements are actually removed from the container.
Rather, all elements which don't fit the remove criteria are brought together to the front of the range, in the same relative order.
The remaining elements are left in a valid, but unspecified, state.
So, after using <code>remove</code>, the <code>size()</code> of the container is unchanged.
To actually remove those, it should be used together with the <code>erase()</code> member function of the container.
</p>

<p>
When the <code>remove</code> function is done, remove returns an iterator pointing one element past the last unremoved element.
So the erase is used as follows:
</p>

<div class="org-src-container">
<pre><code class="src src-C++">v.erase( <span style="color: #008b8b;">std</span>::remove( v.begin(), v.end(), 5 ), v.end() ); 
</code></pre>
</div>

<p>
However, this is not the case for <code>map</code> and <code>set</code>.
</p>
<blockquote>
<p>
In simple associative containers, where the elements are the keys, the elements are completely immutable;
the nested types iterator and const<sub>iterator</sub> are therefore the same.
</p>
</blockquote>
<p>
That means the <code>iterator</code> and <code>const_iterator</code> are actually the same for <code>set</code> and <code>map</code>.
The <i>erase-remove idiom</i> cannot be used here.
Rather, it should use the following loop:
</p>

<div class="org-src-container">
<pre><code class="src src-C++"><span style="color: #a020f0;">typedef</span> <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">set</span>::<span style="color: #228b22;">iterator</span> <span style="color: #228b22;">set_iter</span>; 
<span style="color: #a020f0;">for</span>( <span style="color: #228b22;">set_iter</span> <span style="color: #a0522d;">it</span> = s.begin(); it != s.end(); <span style="color: #b22222;">/* </span><span style="color: #b22222;">blank */</span> ) {
  <span style="color: #a020f0;">if</span>( some_condition() ) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">s.erase( it++ );       // Note the subtlety here</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">I think this is better, erase return iterator to the next element</span>
    it = s.erase(it);
  }
  <span style="color: #a020f0;">else</span> {
    ++it;
  }
 }
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2017-09-06 Wed 22:50</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
