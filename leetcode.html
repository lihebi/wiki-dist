<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-09-05 Mon 20:26 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style>
a:visited {color: red;}
</style>
<style type="text/css">
 pre.src {background-color: #000000; color: #d3d3d3;}</style>
<style type="text/css">
 pre.src {background-color: #000000; color: #d3d3d3;}</style>
<style type="text/css">
 pre.src {background-color: #000000; color: #d3d3d3;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Leetcode</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. Common Strategy &amp; Algorithms</a></li>
<li><a href="#orgheadline2">2. Some links</a></li>
<li><a href="#orgheadline4">3. General Tips</a>
<ul>
<li><a href="#orgheadline3">3.1. GCD</a></li>
</ul>
</li>
<li><a href="#orgheadline6">4. Data Structures</a>
<ul>
<li><a href="#orgheadline5">4.1. Trie</a></li>
</ul>
</li>
<li><a href="#orgheadline15">5. Famous Problems and Algorithms</a>
<ul>
<li><a href="#orgheadline7">5.1. Maximum subarray problem and Kadane's algorithm</a></li>
<li><a href="#orgheadline8">5.2. longest increasing sub-sequence(LIS)</a></li>
<li><a href="#orgheadline10">5.3. Dynamic Programming</a>
<ul>
<li><a href="#orgheadline9">5.3.1. Apply to LIS</a></li>
</ul>
</li>
<li><a href="#orgheadline14">5.4. Patience sorting</a>
<ul>
<li><a href="#orgheadline11">5.4.1. The sort algorithm</a></li>
<li><a href="#orgheadline12">5.4.2. Apply to LIS problem</a></li>
<li><a href="#orgheadline13">5.4.3. LIS problem another understanding</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline23">6. Problems</a>
<ul>
<li><a href="#orgheadline16">6.1. 363. Max Sum of Rectangle No Larger Than K</a></li>
<li><a href="#orgheadline17">6.2. 65. valid number</a></li>
<li><a href="#orgheadline18">6.3. 44. Wildcard Matching (NEEDS REVISIT!!!)</a></li>
<li><a href="#orgheadline19">6.4. 4. Median of Two Sorted Arrays</a></li>
<li><a href="#orgheadline20">6.5. last remaining (contest 2)</a></li>
<li><a href="#orgheadline21">6.6. longest subsequence with at least k repeat / without any repeat</a></li>
<li><a href="#orgheadline22">6.7. 79. Word Search I &amp; 212. Word Search II</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> Common Strategy &amp; Algorithms</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Divide and conquer</li>
<li>DP</li>
<li>binary search</li>
<li>recursive</li>
<li>finding rules using examples</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> Some links</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li><a href="dp.html">DP</a></li>
<li><a href="http://stanford.edu/class/cs97si/">http://stanford.edu/class/cs97si/</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4"><span class="section-number-2">3</span> General Tips</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #919191;">#include</span> <span style="color: #61CE3C;">&lt;climits&gt;</span>
<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">res</span> = INT_MIN;
<span style="color: #4c83ff;">if</span> (tmp &gt; res) res = tmp;
</pre>
</div>


<ul class="org-ul">
<li>lower<sub>bound</sub>: larger or greater than</li>
<li>upper<sub>bound</sub>: strictly larger than</li>
</ul>

<p>
To get a smaller iterator, use <code>upper_bound</code> and decrease it (after check if it is begin)
</p>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #4c83ff;">auto</span> <span style="color: #afd8af;">pre_it</span> = m_data.upper_bound(val);
<span style="color: #4c83ff;">auto</span> <span style="color: #afd8af;">next_it</span> = pre_it;
<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">pre_low</span>, <span style="color: #ff69b4;">pre_high</span>;
<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">next_low</span>, <span style="color: #ff69b4;">next_high</span>;
<span style="color: #4c83ff;">if</span> (pre_it == m_data.end()) {
  next_low = INT_MAX;
  next_high = INT_MAX;
 } <span style="color: #4c83ff;">else</span> {
  next_low = next_it-&gt;first;
  next_high = next_it-&gt;second;
 }
<span style="color: #4c83ff;">if</span> (pre_it == m_data.begin()) {
  pre_low = INT_MIN;
  pre_high = INT_MIN;
 } <span style="color: #4c83ff;">else</span> {
  pre_it--;
  pre_low = pre_it-&gt;first;
  pre_high = pre_it-&gt;second;
 }
</pre>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">3.1</span> GCD</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>swap</li>
<li>make sure x,y are POSITIVE</li>
<li>When divide it, make sure it is not 0!</li>
</ul>
<div class="org-src-container">

<pre class="src src-C++"><span style="color: #afd8af;">int</span> <span style="color: #ff1493;">GCD</span>(<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">x</span>, <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">y</span>) {
  <span style="color: #4c83ff;">if</span> (x &gt; y) <span style="color: #96CBFE;">std</span>::swap(x,y);
  <span style="color: #4c83ff;">if</span> (x == 0) <span style="color: #4c83ff;">return</span> y;
  <span style="color: #4c83ff;">return</span> GCD(y%x, x);
}

<span style="color: #afd8af;">int</span> <span style="color: #ff1493;">gcd</span>(<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">a</span>, <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">b</span>) {
  <span style="color: #4c83ff;">while</span> (b) {
    <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">r</span> = a%b;
    a = b;
    b = r;
  }
  <span style="color: #4c83ff;">return</span> a;
}
</pre>
</div>

<p>
Be careful, <code>a%b</code> follows the sign of a:
</p>
<ul class="org-ul">
<li>5 % 3 == 2</li>
<li>-5 % 3 == -2</li>
<li>5 % -3: ERROR!</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><span class="section-number-2">4</span> Data Structures</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">4.1</span> Trie</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Prefix tree.
</p>
</div>
</div>
</div>



<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><span class="section-number-2">5</span> Famous Problems and Algorithms</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">5.1</span> Maximum subarray problem and Kadane's algorithm</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Problem: finding the contiguous subarray within a one-dimensional array of numbers which has the largest sum
</p>

<p>
Kadane's algorithm:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #4c83ff;">def</span> <span style="color: #ff1493;">max_subarray</span>(A):
    <span style="color: #ff69b4;">max_ending_here</span> = <span style="color: #ff69b4;">max_so_far</span> = 0
    <span style="color: #4c83ff;">for</span> x <span style="color: #4c83ff;">in</span> A:
        <span style="color: #ff69b4;">max_ending_here</span> = <span style="color: #4c83ff;">max</span>(0, max_ending_here + x)
        <span style="color: #ff69b4;">max_so_far</span> = <span style="color: #4c83ff;">max</span>(max_so_far, max_ending_here)
    <span style="color: #4c83ff;">return</span> max_so_far
</pre>
</div>

<p>
or if 0 is not a predefined return value:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #4c83ff;">def</span> <span style="color: #ff1493;">max_subarray</span>(A):
    <span style="color: #ff69b4;">max_ending_here</span> = <span style="color: #ff69b4;">max_so_far</span> = A[0]
    <span style="color: #4c83ff;">for</span> x <span style="color: #4c83ff;">in</span> A[1:]:
        <span style="color: #ff69b4;">max_ending_here</span> = <span style="color: #4c83ff;">max</span>(x, max_ending_here + x)
        <span style="color: #ff69b4;">max_so_far</span> = <span style="color: #4c83ff;">max</span>(max_so_far, max_ending_here)
    <span style="color: #4c83ff;">return</span> max_so_far
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">5.2</span> longest increasing sub-sequence(LIS)</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Find the longest increasing sub-sequence.
<code>O(n^2)</code>
</p>
<div class="org-src-container">

<pre class="src src-C++"><span style="color: #afd8af;">int</span> <span style="color: #ff1493;">sol_nn</span>(<span style="color: #afd8af;">vector</span>&lt;<span style="color: #afd8af;">int</span>&gt; &amp;<span style="color: #ff69b4;">nums</span>) {
  <span style="color: #4c83ff;">if</span> (nums.size() == 0) <span style="color: #4c83ff;">return</span> 0;
  <span style="color: #4c83ff;">if</span> (nums.size() == 1) <span style="color: #4c83ff;">return</span> 1;
  <span style="color: #afd8af;">vector</span>&lt;<span style="color: #afd8af;">int</span>&gt; <span style="color: #ff69b4;">dp</span>(nums.size(), 1);
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">size</span> = nums.size();
  <span style="color: #4c83ff;">for</span> (<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">i</span>=1;i&lt;size;i++) {
    <span style="color: #4c83ff;">for</span> (<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">j</span>=0;j&lt;i;j++) {
      <span style="color: #4c83ff;">if</span> (nums[i] &gt; nums[j]) {
        dp[i] = <span style="color: #96CBFE;">std</span>::max(dp[i], dp[j] + 1);
      }
    }
  }
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">ret</span> = 1;
  <span style="color: #4c83ff;">for</span> (<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">i</span>=0;i&lt;size;i++) {
    ret = <span style="color: #96CBFE;">std</span>::max(ret, dp[i]);
  }
  <span style="color: #4c83ff;">return</span> ret;
}
</pre>
</div>

<p>
<code>O(nlog(n))</code>
</p>
<div class="org-src-container">

<pre class="src src-C++"><span style="color: #afd8af;">int</span> <span style="color: #ff1493;">sol_nlogn</span>(<span style="color: #afd8af;">vector</span>&lt;<span style="color: #afd8af;">int</span>&gt; &amp;<span style="color: #ff69b4;">nums</span>) {
  <span style="color: #4c83ff;">if</span> (nums.empty()) <span style="color: #4c83ff;">return</span> 0;
  <span style="color: #afd8af;">vector</span>&lt;<span style="color: #afd8af;">int</span>&gt; <span style="color: #ff69b4;">list</span>;
  <span style="color: #4c83ff;">for</span> (<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">num</span> : nums) {
    <span style="color: #4c83ff;">auto</span> <span style="color: #afd8af;">it</span> = lower_bound(list.begin(), list.end(), num);
    <span style="color: #4c83ff;">if</span> (it == list.end()) {
      list.push_back(num);
    } <span style="color: #4c83ff;">else</span> {
      *it = num;
    }
  }
  <span style="color: #4c83ff;">return</span> list.size();
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">5.3</span> Dynamic Programming</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Solving a complex problem by breaking it down into a collection of simpler subproblems,
solving each of those subproblems just once, and storing their solutions
</p>
<ul class="org-ul">
<li>ideally, using a memory-based data structure.</li>
</ul>

<p>
There're generally just two ways for DP:
</p>
<ul class="org-ul">
<li>bottom up: solve sub problem, and represent bigger problem</li>
<li>top down: represent bigger problem by sub problems</li>
</ul>
</div>

<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9"><span class="section-number-4">5.3.1</span> Apply to LIS</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
The length of the LIS ending in the current element is the length of the LIS ending in the smaller one + 1.
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">5.4</span> Patience sorting</h3>
<div class="outline-text-3" id="text-5-4">
</div><div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11"><span class="section-number-4">5.4.1</span> The sort algorithm</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
The algorithm derives from  patience card game.
</p>

<p>
This game begins with a shuffled deck of cards. These cards are dealt one by one into a sequence of piles on the table, according to the following rules.
</p>
<ul class="org-ul">
<li>Initially, there are no piles. The first card dealt forms a new pile consisting of the single card.</li>
<li>Each subsequent card is placed on the leftmost existing pile whose top card has a value greater than or equal the new card's value, or to the right of all of the existing piles, thus forming a new pile.</li>
<li>When there are no more cards remaining to deal, the game ends.</li>
</ul>

<p>
clearly the complexity is <code>O(nlogn)</code>.
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12"><span class="section-number-4">5.4.2</span> Apply to LIS problem</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
First, execute the sorting algorithm as described above.
The number of piles is the length of a longest subsequence.
Whenever a card is placed on top of a pile,
put a back-pointer to the top card in the previous pile (that, by assumption, has a lower value than the new card has).
In the end, follow the back-pointers from the top card in the last pile to recover a decreasing subsequence of the longest length;
its reverse is an answer to the longest increasing subsequence algorithm.
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-4">
<h4 id="orgheadline13"><span class="section-number-4">5.4.3</span> LIS problem another understanding</h4>
<div class="outline-text-4" id="text-5-4-3">
<p>
Keep a set of active lists for the longest.
Actually use the reversed pile of Patience sorting.
Whenever add a number to a pile, remove all other piles with the same length.
This should save a lot of computing!
</p>

<p>
e.g. 58364129
</p>
<pre class="example">
58 ---
36 ---
4 ---
129
</pre>

<p>
<b>end element of smaller list is smaller than end elements of larger lists.</b>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-2">
<h2 id="orgheadline23"><span class="section-number-2">6</span> Problems</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">6.1</span> 363. Max Sum of Rectangle No Larger Than K</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>If we want to switch row and column of a matrix if col is larger than row, simply
<ol class="org-ol">
<li>use a boolean flag</li>
<li>swap the row and column size variable.</li>
<li>when accessing data, swap the row and column, e.g. <code>data[col][row]</code> instead of <code>data[row][col]</code></li>
</ol></li>
<li><code>std::swap</code>, <code>std::max</code></li>
<li>In this problem, the reused computation is not whole, but partial: only column (or row) part computation is reused.
Thus the problem matters for each one is larger.</li>
<li>A very interesting point is, the <code>temp[]</code> vector keep tracking the sum of current row, while <code>sum</code> keeps the sum of rows.</li>
<li><code>sums</code> keep the sums of the rows, and use lower<sub>bound</sub> feature of std::set for <code>sums.lower_bound(sum - k)</code></li>
</ul>


<div class="org-src-container">

<pre class="src src-C++"><span style="color: #afd8af;">int</span> <span style="color: #ff1493;">maxSumSubmatrix</span>(<span style="color: #afd8af;">vector</span>&lt;<span style="color: #afd8af;">vector</span>&lt;<span style="color: #afd8af;">int</span>&gt; &gt;&amp; <span style="color: #ff69b4;">matrix</span>, <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">k</span>) {
  <span style="color: #4c83ff;">if</span> (matrix.size() == 0) <span style="color: #4c83ff;">return</span> 0;
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">row</span> = matrix.size();
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">col</span> = matrix[0].size();
  <span style="color: #afd8af;">bool</span> <span style="color: #ff69b4;">row_large</span> = <span style="color: #96CBFE;">true</span>;
  <span style="color: #4c83ff;">if</span> (row &gt; col) {
    row_large = <span style="color: #96CBFE;">true</span>;
  } <span style="color: #4c83ff;">else</span> {
    row_large = <span style="color: #96CBFE;">false</span>;
    <span style="color: #96CBFE;">std</span>::swap(row, col);
  }
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">ret</span> = INT_MIN;

  <span style="color: #4c83ff;">for</span> (<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">c</span>=0;c&lt;col;c++) {
    <span style="color: #afd8af;">vector</span>&lt;<span style="color: #afd8af;">int</span>&gt; <span style="color: #ff69b4;">temp</span>(row, 0);
    <span style="color: #8B8989; font-style: italic;">// </span><span style="color: #8B8989; font-style: italic;">sums.insert(0);</span>
    <span style="color: #4c83ff;">for</span> (<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">i</span>=c;i&gt;=0;i--) {
      <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">sum</span> = 0;
      <span style="color: #afd8af;">set</span>&lt;<span style="color: #afd8af;">int</span>&gt; <span style="color: #ff69b4;">sums</span>;
      sums.insert(0);
      <span style="color: #4c83ff;">for</span> (<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">r</span>=0;r&lt;row;r++) {
        temp[r] += row_large ? matrix[r][i] : matrix[i][r];
        sum += temp[r];
        <span style="color: #4c83ff;">auto</span> <span style="color: #afd8af;">it</span> = sums.lower_bound(sum - k);
        <span style="color: #4c83ff;">if</span> (it != sums.end()) {
          <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">res</span> = sum - *it;
          ret = <span style="color: #96CBFE;">std</span>::max(ret, res);
        }
        sums.insert(sum);
      }
    }
  }
  <span style="color: #4c83ff;">return</span> ret;
}
</pre>
</div>
</div>
</div>



<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">6.2</span> 65. valid number</h3>
<div class="outline-text-3" id="text-6-2">
<pre class="example">
EXPECT_TRUE(s.isNumber("+.8"));
EXPECT_TRUE(s.isNumber(".1"));
EXPECT_TRUE(s.isNumber("-5.3"));

EXPECT_FALSE(s.isNumber(". 1"));
EXPECT_FALSE(s.isNumber("4e+"));
EXPECT_FALSE(s.isNumber("6e6.5"));
</pre>
</div>
</div>


<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18"><span class="section-number-3">6.3</span> 44. Wildcard Matching (NEEDS REVISIT!!!)</h3>
<div class="outline-text-3" id="text-6-3">
<p>
The recursive one is too cost:
</p>
<div class="org-src-container">

<pre class="src src-C++"><span style="color: #afd8af;">bool</span> <span style="color: #ff1493;">isMatch</span>(<span style="color: #afd8af;">string</span> <span style="color: #ff69b4;">s</span>, <span style="color: #afd8af;">string</span> <span style="color: #ff69b4;">p</span>) {
  <span style="color: #96CBFE;">std</span>::<span style="color: #afd8af;">string</span> <span style="color: #ff69b4;">pattern</span> = p;
  <span style="color: #96CBFE;">std</span>::<span style="color: #afd8af;">string</span> <span style="color: #ff69b4;">str</span> = s;
  <span style="color: #4c83ff;">if</span> (p.empty()) {
    <span style="color: #4c83ff;">if</span> (s.empty()) <span style="color: #4c83ff;">return</span> <span style="color: #96CBFE;">true</span>;
    <span style="color: #4c83ff;">else</span> <span style="color: #4c83ff;">return</span> <span style="color: #96CBFE;">false</span>;
  } <span style="color: #4c83ff;">else</span> {
    <span style="color: #afd8af;">char</span> <span style="color: #ff69b4;">c</span> = *p.begin();
    p = p.substr(1);
    <span style="color: #4c83ff;">if</span> (c == <span style="color: #61CE3C;">'?'</span>) {
      <span style="color: #4c83ff;">if</span> (s.empty()) <span style="color: #4c83ff;">return</span> <span style="color: #96CBFE;">false</span>;
      s = s.substr(1);
      <span style="color: #4c83ff;">return</span> isMatch(s, p);
    } <span style="color: #4c83ff;">else</span> <span style="color: #4c83ff;">if</span> (c == <span style="color: #61CE3C;">'*'</span>) {
      <span style="color: #4c83ff;">for</span> (<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">i</span>=0;i&lt;=(<span style="color: #afd8af;">int</span>)s.size();i++) {
        <span style="color: #4c83ff;">if</span> (isMatch(s.substr(i), p)) {
          <span style="color: #4c83ff;">return</span> <span style="color: #96CBFE;">true</span>;
        }
      }
      <span style="color: #4c83ff;">return</span> <span style="color: #96CBFE;">false</span>;
    } <span style="color: #4c83ff;">else</span> {
      <span style="color: #4c83ff;">if</span> (s.empty()) <span style="color: #4c83ff;">return</span> <span style="color: #96CBFE;">false</span>;
      <span style="color: #4c83ff;">if</span> (s[0] != c) {
        <span style="color: #4c83ff;">return</span> <span style="color: #96CBFE;">false</span>;
      }
      s = s.substr(1);
      <span style="color: #4c83ff;">return</span> isMatch(s, p);
    }
  }
}
</pre>
</div>

<p>
This one does not have that problem, and is linear.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #afd8af;">bool</span> <span style="color: #ff1493;">isMatch</span>(<span style="color: #4c83ff;">const</span> <span style="color: #afd8af;">char</span> *<span style="color: #ff69b4;">s</span>, <span style="color: #4c83ff;">const</span> <span style="color: #afd8af;">char</span> *<span style="color: #ff69b4;">p</span>) {
  <span style="color: #4c83ff;">const</span> <span style="color: #afd8af;">char</span>* <span style="color: #ff69b4;">star</span>=<span style="color: #96CBFE;">NULL</span>;
  <span style="color: #4c83ff;">const</span> <span style="color: #afd8af;">char</span>* <span style="color: #ff69b4;">ss</span>=s; 
  <span style="color: #4c83ff;">while</span> (*s){
    <span style="color: #4c83ff;">if</span> ((*p==<span style="color: #61CE3C;">'?'</span>)||(*p==*s)){s++;p++;<span style="color: #4c83ff;">continue</span>;}
    <span style="color: #4c83ff;">if</span> (*p==<span style="color: #61CE3C;">'*'</span>){star=p++; ss=s;<span style="color: #4c83ff;">continue</span>;}
    <span style="color: #4c83ff;">if</span> (star){ p = star+1; s=++ss;<span style="color: #4c83ff;">continue</span>;}
    <span style="color: #4c83ff;">return</span> <span style="color: #96CBFE;">false</span>;
  }
  <span style="color: #4c83ff;">while</span> (*p==<span style="color: #61CE3C;">'*'</span>){p++;}
  <span style="color: #4c83ff;">return</span> !*p;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19"><span class="section-number-3">6.4</span> 4. Median of Two Sorted Arrays</h3>
<div class="outline-text-3" id="text-6-4">
<p>
If want a log complexity, set up <code>(min, max)</code> and keep update them.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #afd8af;">double</span> <span style="color: #ff1493;">findMedianSortedArrays</span>(<span style="color: #afd8af;">vector</span>&lt;<span style="color: #afd8af;">int</span>&gt;&amp; <span style="color: #ff69b4;">nums1</span>, <span style="color: #afd8af;">vector</span>&lt;<span style="color: #afd8af;">int</span>&gt;&amp; <span style="color: #ff69b4;">nums2</span>) {
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">m</span> = nums1.size(), <span style="color: #ff69b4;">n</span> = nums2.size();
  <span style="color: #4c83ff;">if</span> (m &gt; n) <span style="color: #4c83ff;">return</span> findMedianSortedArrays(nums2, nums1);
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">i</span>, <span style="color: #ff69b4;">j</span>, <span style="color: #ff69b4;">imin</span> = 0, <span style="color: #ff69b4;">imax</span> = m, <span style="color: #ff69b4;">half</span> = (m + n + 1) / 2;
  <span style="color: #4c83ff;">while</span> (imin &lt;= imax) {
    i = (imin + imax) / 2;
    j = half - i;
    <span style="color: #4c83ff;">if</span> (i &gt; 0 &amp;&amp; j &lt; n &amp;&amp; nums1[i - 1] &gt; nums2[j]) imax = i - 1;
    <span style="color: #4c83ff;">else</span> <span style="color: #4c83ff;">if</span> (j &gt; 0 &amp;&amp; i &lt; m &amp;&amp; nums2[j - 1] &gt; nums1[i]) imin = i + 1;
    <span style="color: #4c83ff;">else</span> <span style="color: #4c83ff;">break</span>;
  }
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">num1</span>;
  <span style="color: #4c83ff;">if</span> (i == 0) num1 = nums2[j - 1];
  <span style="color: #4c83ff;">else</span> <span style="color: #4c83ff;">if</span> (j == 0) num1 = nums1[i - 1]; 
  <span style="color: #4c83ff;">else</span> num1 = <span style="color: #96CBFE;">std</span>::max(nums1[i - 1], nums2[j - 1]);

  <span style="color: #4c83ff;">if</span> ((m + n) &amp; 1) <span style="color: #4c83ff;">return</span> num1;

  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">num2</span>;
  <span style="color: #4c83ff;">if</span> (i == m) num2 = nums2[j];
  <span style="color: #4c83ff;">else</span> <span style="color: #4c83ff;">if</span> (j == n) num2 = nums1[i];
  <span style="color: #4c83ff;">else</span> num2 = <span style="color: #96CBFE;">std</span>::min(nums1[i], nums2[j]);

  <span style="color: #4c83ff;">return</span> (num1 + num2) / 2.0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20"><span class="section-number-3">6.5</span> last remaining (contest 2)</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>Move head, record step</li>
<li>according to left and remaining, decide how to update</li>
</ul>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #afd8af;">int</span> <span style="color: #ff1493;">lastRemaining</span>(<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">n</span>) {
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">head</span> = 1;
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">step</span> = 1;
  <span style="color: #afd8af;">bool</span> <span style="color: #ff69b4;">left</span> = <span style="color: #96CBFE;">true</span>;
  <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">remaining</span> = n;
  <span style="color: #4c83ff;">while</span> (remaining &gt; 1) {
    <span style="color: #4c83ff;">if</span> (left) {
      left = <span style="color: #96CBFE;">false</span>;
      head = head + step;
      step &lt;&lt;=1;
      remaining &gt;&gt;= 1;
    } <span style="color: #4c83ff;">else</span> {
      left = <span style="color: #96CBFE;">true</span>;
      <span style="color: #4c83ff;">if</span> (remaining % 2 == 1) {
        head += step;
      }
      step &lt;&lt;= 1;
      remaining &gt;&gt;= 1;
    }
  }
  <span style="color: #4c83ff;">return</span> head;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21"><span class="section-number-3">6.6</span> longest subsequence with at least k repeat / without any repeat</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Given a string s, find the longest subsequence that
</p>
<ol class="org-ol">
<li>have at least k repeat for each characters</li>
<li>have no repeat for each word</li>
</ol>

<p>
These are two problems.
For the first one, count and split the ones that don't have k repeatition.
Note:
</p>
<ol class="org-ol">
<li>use recur(s,k,min,max) format instead of creating substring! Otherwise time limit execeed.</li>
</ol>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #4c83ff;">class</span> <span style="color: #afd8af;">Solution</span> {
<span style="color: #4c83ff;">public</span>:
  <span style="color: #afd8af;">int</span> <span style="color: #ff1493;">longestSubstring</span>(<span style="color: #afd8af;">string</span> <span style="color: #ff69b4;">s</span>, <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">k</span>) {
    <span style="color: #8B8989; font-style: italic;">// </span><span style="color: #8B8989; font-style: italic;">calculate the frequency of each character</span>
    <span style="color: #8B8989; font-style: italic;">// </span><span style="color: #8B8989; font-style: italic;">if all &gt; k, good</span>
    <span style="color: #8B8989; font-style: italic;">// </span><span style="color: #8B8989; font-style: italic;">otherwise, split the string by all that is less than k</span>
    <span style="color: #4c83ff;">return</span> recur(s, k, 0, s.size());
  }

  <span style="color: #afd8af;">int</span> <span style="color: #ff1493;">recur</span>(<span style="color: #afd8af;">string</span> &amp;<span style="color: #ff69b4;">s</span>, <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">k</span>, <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">min</span>, <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">max</span>) {
    <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">ret</span> = 0;
    <span style="color: #afd8af;">map</span>&lt;<span style="color: #afd8af;">char</span>, <span style="color: #afd8af;">int</span>&gt; <span style="color: #ff69b4;">m</span>;
    <span style="color: #4c83ff;">for</span> (<span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">i</span>=min;i&lt;max;i++) {
      m[s[i]]++;
    }
    <span style="color: #afd8af;">string</span> <span style="color: #ff69b4;">split</span>;
    <span style="color: #4c83ff;">for</span> (<span style="color: #4c83ff;">auto</span> <span style="color: #afd8af;">mi</span> : m) {
      <span style="color: #4c83ff;">if</span> (mi.second &lt; k) {
        split += mi.first;
      }
    }
    <span style="color: #4c83ff;">if</span> (split.empty()) <span style="color: #4c83ff;">return</span> max - min;
    <span style="color: #8B8989; font-style: italic;">// </span><span style="color: #8B8989; font-style: italic;">do split</span>
    <span style="color: #afd8af;">size_t</span> <span style="color: #ff69b4;">idx</span> = min;
    <span style="color: #afd8af;">size_t</span> <span style="color: #ff69b4;">last_idx</span> = min;
    idx = s.find_first_of(split, last_idx);
    <span style="color: #4c83ff;">while</span> (idx != <span style="color: #96CBFE;">string</span>::npos &amp;&amp; idx &lt; max) {
      <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">tmp</span> = recur(s, k, last_idx, idx);
      ret = <span style="color: #96CBFE;">std</span>::<span style="color: #ff69b4;">max</span>(ret, tmp);
      last_idx = idx+1;
      idx = s.find_first_of(split, last_idx);
    }
    <span style="color: #afd8af;">string</span> <span style="color: #ff69b4;">sub</span> = s.substr(last_idx);
    <span style="color: #afd8af;">int</span> <span style="color: #ff69b4;">tmp</span> = recur(s, k, last_idx, <span style="color: #afd8af;">max</span>);
    ret = <span style="color: #96CBFE;">std</span>::<span style="color: #ff69b4;">max</span>(ret, tmp);
    <span style="color: #4c83ff;">return</span> ret;
  }
};
</pre>
</div>

<p>
The second problem is an DP problem.
The trick is, every time, record the visited list, using a <i>map</i>:
map to the index of that visit.
Do not need to update everything before.
If we found a character visited before that index, simply update that only.
</p>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22"><span class="section-number-3">6.7</span> 79. Word Search I &amp; 212. Word Search II</h3>
<div class="outline-text-3" id="text-6-7">
<p>
Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring.
The same letter cell may not be used more than once.
</p>

<p>
No magic here, try to start from each cell.
Recur the four directions, so that the back-tracing is automatic by recurrence.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2016-09-05 Mon 20:26</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
