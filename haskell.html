<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-12-22 Fri 17:19 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Haskell</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="assets/hebi.css" /><link rel="stylesheet" type="text/css" href="assets/test.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Haskell</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org52255ef">1. Reference</a>
<ul>
<li><a href="#org95880fd">1.1. <span class="todo TODO">TODO</span> Happy parser</a></li>
<li><a href="#orge1846d3">1.2. <span class="todo TODO">TODO</span> Parsec Parser</a></li>
</ul>
</li>
<li><a href="#org733691a">2. Concept</a>
<ul>
<li><a href="#orga95e68a">2.1. strictness</a></li>
</ul>
</li>
<li><a href="#org78d00b6">3. Lexical</a>
<ul>
<li><a href="#orgba3494f">3.1. Names</a></li>
<li><a href="#org26495da">3.2. Comment</a></li>
<li><a href="#org00f3b93">3.3. layout</a></li>
</ul>
</li>
<li><a href="#orgee4e42d">4. Expression</a></li>
<li><a href="#orgdf8dd65">5. Tmp</a>
<ul>
<li><a href="#org3f5c9e2">5.1. Syntactic Sugar</a></li>
<li><a href="#org2f46502">5.2. Notations</a></li>
</ul>
</li>
<li><a href="#org19e6c26">6. Monad</a>
<ul>
<li><a href="#org7259989">6.1. Three Components of monad</a></li>
<li><a href="#orga8fcaf0">6.2. Type constructor</a></li>
<li><a href="#org578d690">6.3. Using class</a></li>
<li><a href="#orgd280916">6.4. the monad laws</a></li>
<li><a href="#org1edbc61">6.5. A different expression of Monad Laws</a></li>
<li><a href="#org76b59fb">6.6. One Way Monad</a></li>
</ul>
</li>
<li><a href="#org145ce0f">7. <span class="todo TODO">TODO</span> IO</a></li>
<li><a href="#orge5d2d3b">8. Type</a></li>
<li><a href="#orgd205ab5">9. <span class="todo TODO">TODO</span> Type classes</a></li>
<li><a href="#org4087fa6">10. <span class="todo TODO">TODO</span> Pattern Matching</a></li>
<li><a href="#org1d8ffcb">11. <span class="todo TODO">TODO</span> Cabal</a></li>
<li><a href="#org7855c38">12. <span class="todo TODO">TODO</span> Learn Haskell</a>
<ul>
<li><a href="#org9a5fbe3">12.1. <span class="todo TODO">TODO</span> Typeclasses of Haskell comparing to C++</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org52255ef" class="outline-2">
<h2 id="org52255ef"><span class="section-number-2">1</span> Reference</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li class="on"><code>[X]</code> Haskell wiki: <a href="https://wiki.haskell.org">https://wiki.haskell.org</a></li>
<li class="on"><code>[X]</code> Haskell wiki book: <a href="https://en.wikibooks.org/wiki/Haskell">https://en.wikibooks.org/wiki/Haskell</a></li>
<li>Write yourself a scheme: <a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours</a></li>
<li class="on"><code>[X]</code> The tutorial: <a href="https://www.haskell.org/tutorial/index.html">https://www.haskell.org/tutorial/index.html</a></li>
<li>language specification: <a href="https://wiki.haskell.org/Language_and_library_specification">https://wiki.haskell.org/Language_and_library_specification</a></li>
<li>GHC: <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/">https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/</a></li>
</ul>
</div>

<div id="outline-container-org95880fd" class="outline-3">
<h3 id="org95880fd"><span class="section-number-3">1.1</span> <span class="todo TODO">TODO</span> Happy parser</h3>
</div>
<div id="outline-container-orge1846d3" class="outline-3">
<h3 id="orge1846d3"><span class="section-number-3">1.2</span> <span class="todo TODO">TODO</span> Parsec Parser</h3>
</div>
</div>

<div id="outline-container-org733691a" class="outline-2">
<h2 id="org733691a"><span class="section-number-2">2</span> Concept</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orga95e68a" class="outline-3">
<h3 id="orga95e68a"><span class="section-number-3">2.1</span> strictness</h3>
<div class="outline-text-3" id="text-2-1">
<p>
In a strict language, the arguments to a function are always evaluated
before it is invoked.  In a non-strict language, the arguments are not
evaluated until their values are <b>actually</b> required.  As a result, if
during the evaluation of the arguments, run-time error occurs, the
strict language will crash, but the non-strict program might finish
peacefully.
</p>

<p>
Scheme is strict, while Haskell is non-strict.
</p>
</div>
</div>
</div>

<div id="outline-container-org78d00b6" class="outline-2">
<h2 id="org78d00b6"><span class="section-number-2">3</span> Lexical</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgba3494f" class="outline-3">
<h3 id="orgba3494f"><span class="section-number-3">3.1</span> Names</h3>
<div class="outline-text-3" id="text-3-1">
<p>
There are six kinds of names:
</p>
<ul class="org-ul">
<li>(value) variables</li>
<li>(value) constructors</li>
<li>type variables</li>
<li>type constructors</li>
<li>type classes</li>
<li>module names</li>
</ul>

<p>
There are two constraints on naming:
</p>
<ul class="org-ul">
<li>lower-case vs upper-case
<ul class="org-ul">
<li>variables and type variables must begin with <b>lowercase</b> letter or
underscore</li>
<li>other 4 kinds of names must begin with <b>uppercase</b> letter</li>
</ul></li>
<li>in the same scope, <b>type constructor and type class</b> must not be the
same</li>
</ul>
</div>
</div>
<div id="outline-container-org26495da" class="outline-3">
<h3 id="org26495da"><span class="section-number-3">3.2</span> Comment</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Pretty flexible, but just use
</p>
<ul class="org-ul">
<li><code>--</code> for line comment</li>
<li><code>{- XXX -}</code> for block comment</li>
</ul>
</div>
</div>
<div id="outline-container-org00f3b93" class="outline-3">
<h3 id="org00f3b93"><span class="section-number-3">3.3</span> layout</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Haskell support two style of programming, possibly mixed: using
explicit braces and semicolons, or use indention. The rule is pretty
straight forward.
</p>

<p>
The layout rule takes effect whenever <b>the open brace is omitted</b>
after keywords <b><code>where</code></b>, <b><code>let</code></b>, <b><code>do</code></b>, <b><code>of</code></b>. If it is not
omitted, nothing happens, the indention will not matter at all. The
indention of the next lexeme is remembered, and <b>the omitted open
brace is inserted</b>. In the subsequent lines:
</p>
<ul class="org-ul">
<li>if the indention is larger, nothing inserted, i.e. it is same as
writing on the previous line</li>
<li>if the indention is the same, a semicolon is inserted</li>
<li>if the indention is smaller, a close brace is inserted, and the
layout rule ends</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgee4e42d" class="outline-2">
<h2 id="orgee4e42d"><span class="section-number-2">4</span> Expression</h2>
<div class="outline-text-2" id="text-4">
<p>
conditional
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">if</span> e1 <span style="color: #a020f0;">then</span> e2 <span style="color: #a020f0;">else</span> e3
<span style="color: #a020f0;">case</span> e1 <span style="color: #a020f0;">of</span> { <span style="color: #228b22;">True</span> <span style="color: #a0522d;">-&gt;</span> e2; <span style="color: #228b22;">False</span> <span style="color: #a0522d;">-&gt;</span> e3}
</pre>
</div>

<p>
List
</p>
<div class="org-src-container">
<pre class="src src-haskell">[e1,e2,<span style="color: #a0522d;">...</span>,ek]
e1<span style="color: #0000ff;">:</span>(e2<span style="color: #228b22;">:</span>(<span style="color: #a0522d;">...</span>(ek<span style="color: #228b22;">:[]</span>)))
</pre>
</div>

<p>
Tuple
</p>
<div class="org-src-container">
<pre class="src src-haskell">(e1,<span style="color: #a0522d;">...</span>,ek)
</pre>
</div>

<p>
enumerations (note the <code>..</code> is an operator)
</p>
<div class="org-src-container">
<pre class="src src-haskell">[e1<span style="color: #a0522d;">..</span>]
[e1,e2<span style="color: #a0522d;">..</span>]
[e1<span style="color: #a0522d;">..</span>e3]
[e1,e2<span style="color: #a0522d;">..</span>e3]
</pre>
</div>

<p>
list comprehension: Each of q<sub>i</sub> is a qualifier, can have three
forms. These qualifiers are <b>nested</b>. The first is pattern matching
that matches <code>pat</code> against a <b>list expression</b> (thus called
<i>generator</i>), the second create local bindings, the third a boolean
guard. Pattern matching creates lambda bound, while let creates
lexical bounds.
</p>

<div class="org-src-container">
<pre class="src src-haskell">[e <span style="color: #a0522d;">|</span> q1,<span style="color: #a0522d;">...</span>,qn]
</pre>
</div>

<pre class="example">
pat &lt;- exp
let decls
exp
</pre>

<p>
Let expression introduces a nested, lexically-scoped
mutually-recursive (letrec) list of <i>declarations</i>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">let</span> {d1;<span style="color: #a0522d;">...</span>;dn} <span style="color: #a020f0;">in</span> e
</pre>
</div>

<p>
case expression matches <code>e</code> against a list of patches. But if a
pattern matched, the body is not a single expression, but seems to be
another round of matching. Each match is a list of guard expression
separated by vertical bar (note <b>the first vertical bar is
mandatory</b>). Each guard expression is a list of actual guards. Only if
all the actual guards succeed, the guard expression succeeds. The
corresponding expression is the result. Seems that the top-level
patterns and the match guards have the same semantic, i.e. if one
fail, try the next one.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">case</span> e <span style="color: #a020f0;">of</span> {p1 match1; <span style="color: #a0522d;">...</span> ; pn matchn}
<span style="color: #0000ff;">match</span> <span style="color: #0000ff;">::=</span> <span style="color: #a0522d;">|</span> gs1 <span style="color: #a0522d;">-&gt;</span> e1 <span style="color: #a0522d;">|</span> gs2 <span style="color: #a0522d;">-&gt;</span> e2 <span style="color: #a0522d;">|</span> <span style="color: #a0522d;">...</span>
<span style="color: #0000ff;">gs</span> <span style="color: #0000ff;">::=</span> guard1, guard2, <span style="color: #a0522d;">...</span>
<span style="color: #0000ff;">guard</span> <span style="color: #0000ff;">::=</span> p <span style="color: #a0522d;">&lt;-</span> e
<span style="color: #0000ff;">guard</span> <span style="color: #0000ff;">::=</span> <span style="color: #a020f0;">let</span> decls
<span style="color: #0000ff;">guard</span> <span style="color: #0000ff;">::=</span> boolean guard
</pre>
</div>

<p>
do expression seems to be exclusively used in monad.
</p>

<p>
Expression type-signature is a notation for human only. The compiler
does not need to know it, because it infers the type signature. Of
course the compiler will complain if they do not match. Thus, the
expression with type-signature simply evaluates to the expression.
</p>

<p>
The declared type may be more specific than the principal type derived
from exp, but <b>it is an error that the declared type is more
general</b>. But, it seems that, if we declare a more general type
signature <b>before</b> the use of the type (thus before the inference), it
is OK.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">exp</span> <span style="color: #a0522d;">::</span> [context <span style="color: #a0522d;">=&gt;</span>] <span style="color: #a020f0;">type</span>
</pre>
</div>

<p>
Pattern matching match pattern against values, and construct bounds.
</p>

<ol class="org-ol">
<li>matching <code>var</code> against a value <code>v</code> always succeed, and bounds <code>var</code> to <code>v</code></li>
<li>matching <code>~apat</code> against a value <code>v</code> always succeed. This is called
a irrefutable pattern, means I force it to match, don't give me
error. The error will occur when the matched bindings are
evaluated.</li>
<li>wildcard pattern <code>_</code> against any value always succeed</li>
<li>matching <code>con pat</code> where <code>con</code> is a type constructor (defined by
<code>newtype</code>), the value must also be <code>con v</code> to succeed</li>
<li>matching <code>con pat1 ... patn</code> where <code>con</code> is a data constructor
(defined by <code>data</code>), the value must also be <code>con v1 ... vn</code> with
the same constructor to succeed. The variables are bound.</li>
<li class="off"><code>[&#xa0;]</code> fields</li>
<li>matching numeric, character, or string literal will only succeed if
the value is that literal.</li>
<li>match <code>var@apat</code> will basically match <code>apat</code> against <code>v</code>, but
introduce additional bound <code>var</code> for the whole <code>v</code>.</li>
</ol>
</div>
</div>

<div id="outline-container-orgdf8dd65" class="outline-2">
<h2 id="orgdf8dd65"><span class="section-number-2">5</span> Tmp</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org3f5c9e2" class="outline-3">
<h3 id="org3f5c9e2"><span class="section-number-3">5.1</span> Syntactic Sugar</h3>
<div class="outline-text-3" id="text-5-1">
<pre class="example">
x `elem` xs = elem x xs
`elem` xs = flip elem xs
[1,2,3] = (1:2:3:[])
do x &lt;- f; g x = f &gt;&gt;= (\x -&gt; g x)
</pre>
</div>
</div>

<div id="outline-container-org2f46502" class="outline-3">
<h3 id="org2f46502"><span class="section-number-3">5.2</span> Notations</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Functions are defined by equations (<code>=</code>). E.g.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">inc</span> n <span style="color: #a0522d;">=</span> n <span style="color: #a0522d;">+</span> 1
</pre>
</div>

<p>
This is a <i>declaration</i>.
</p>
</div>
</div>
</div>

<div id="outline-container-org19e6c26" class="outline-2">
<h2 id="org19e6c26"><span class="section-number-2">6</span> Monad</h2>
<div class="outline-text-2" id="text-6">
<p>
A monad is a way to structure computations in terms of values and
sequences of computations using those values.
</p>

<blockquote>
<p>
It is useful to think of a monad as a strategy for combining
computations into more complex computations.
</p>
</blockquote>
</div>

<div id="outline-container-org7259989" class="outline-3">
<h3 id="org7259989"><span class="section-number-3">6.1</span> Three Components of monad</h3>
<div class="outline-text-3" id="text-6-1">
<p>
A monad is <b>a type constructor</b>, a function called <b><code>return</code></b>, and a
combinator function called <b>bind</b> or <code>&gt;&gt;=</code>. These three elements work
together to encapsulate a strategy for combining computations to
produce more complex computations.
</p>

<p>
the monad <b>type constructor</b> defines a type of computation, the
<b>return function</b> creates primitive values of that computation type
and <b><code>&gt;&gt;=</code></b> combines computations of that type together to make more
complex computations of that type.
</p>
</div>
</div>

<div id="outline-container-orga8fcaf0" class="outline-3">
<h3 id="orga8fcaf0"><span class="section-number-3">6.2</span> Type constructor</h3>
<div class="outline-text-3" id="text-6-2">
<p>
A type constructor is a parameterized type definition used with
polymorphic types.
</p>
</div>
</div>

<div id="outline-container-org578d690" class="outline-3">
<h3 id="org578d690"><span class="section-number-3">6.3</span> Using class</h3>
<div class="outline-text-3" id="text-6-3">
<p>
To define a monad, you basically need the three components. You can do
it from scratch, but a better idea is through the use of class
<code>Monad</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Monad</span> m <span style="color: #a020f0;">where</span>
    (<span style="color: #a0522d;">&gt;&gt;=</span>)  <span style="color: #a0522d;">::</span> m a <span style="color: #a0522d;">-&gt;</span> (a <span style="color: #a0522d;">-&gt;</span> m b) <span style="color: #a0522d;">-&gt;</span> m b
    return <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> m a
</pre>
</div>

<p>
There's a <i>do notation</i> that can be used with a monad. It is a
syntactic sugar that "provides a simple, imperative-style notation for
describing computations with monads"
</p>

<p>
Apart from these two operations, the <code>Monad</code> class also has two more
operations: <code>fail</code> and <code>&gt;&gt;</code>. They are optional. Use <code>fail</code> if you want
to have different behavior for failure. The <code>&gt;&gt;</code> function is a
convenience operator that "used to bind a monadic computation that
does not require input from the previous computation in the sequence."
It is defined in terms of &gt;&gt;=:
</p>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #0000ff;">&gt;&gt;</span>) <span style="color: #a0522d;">::</span> m a <span style="color: #a0522d;">-&gt;</span> m b <span style="color: #a0522d;">-&gt;</span> m b
m <span style="color: #0000ff;">&gt;&gt;</span> k <span style="color: #a0522d;">=</span> m <span style="color: #a0522d;">&gt;&gt;=</span> (<span style="color: #a0522d;">\</span><span style="color: #a020f0;">_</span> <span style="color: #a0522d;">-&gt;</span> k)
</pre>
</div>

<p>
So the full version should be
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Monad</span> m <span style="color: #a020f0;">where</span>
  (<span style="color: #a0522d;">&gt;&gt;=</span>)  <span style="color: #a0522d;">::</span> m a <span style="color: #a0522d;">-&gt;</span> (  a <span style="color: #a0522d;">-&gt;</span> m b) <span style="color: #a0522d;">-&gt;</span> m b
  (<span style="color: #a0522d;">&gt;&gt;</span>)   <span style="color: #a0522d;">::</span> m a <span style="color: #a0522d;">-&gt;</span>  m b         <span style="color: #a0522d;">-&gt;</span> m b
  return <span style="color: #a0522d;">::</span>   a                 <span style="color: #a0522d;">-&gt;</span> m a
  fail   <span style="color: #a0522d;">::</span> <span style="color: #228b22;">String</span> <span style="color: #a0522d;">-&gt;</span> m a
</pre>
</div>
</div>
</div>



<div id="outline-container-orgd280916" class="outline-3">
<h3 id="orgd280916"><span class="section-number-3">6.4</span> the monad laws</h3>
<div class="outline-text-3" id="text-6-4">
<p>
All instances of Monad should obey the following equations, called
<i>Monad Laws</i>:
</p>

<pre class="example">
return a &gt;&gt;= k                  =  k a
m        &gt;&gt;= return             =  m
m        &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)  =  (m &gt;&gt;= k) &gt;&gt;= h
</pre>

<ol class="org-ol">
<li>return is a <b>left-identity</b> with respect to &gt;&gt;=</li>
<li>return is a <b>right-identity</b> with respect to &gt;&gt;=</li>
<li>a kind of <b>associativity</b> law for &gt;&gt;=</li>
</ol>

<p>
Any type constructor with return and bind operators that satisfy the
three monad laws is a monad.
</p>

<p>
The compiler, however, does not check these laws.
</p>
</div>
</div>

<div id="outline-container-org1edbc61" class="outline-3">
<h3 id="org1edbc61"><span class="section-number-3">6.5</span> A different expression of Monad Laws</h3>
<div class="outline-text-3" id="text-6-5">
<ol class="org-ol">
<li>create a description of a computation that will produce
(a.k.a. "return") a given Haskell value, and</li>
<li>combine (a.k.a. "bind") a computation description with a reaction
to it
<ul class="org-ul">
<li>a pure Haskell function that is set to receive a
computation-produced value (when and if that happens) and return
another computation description, using or dependent on that value
if need be</li>
<li>creating a description of a combined computation that will feed
the original computation's output through the reaction while
automatically taking care of the particulars of the computational
process itself.</li>
</ul></li>
</ol>
</div>
</div>


<div id="outline-container-org76b59fb" class="outline-3">
<h3 id="org76b59fb"><span class="section-number-3">6.6</span> One Way Monad</h3>
<div class="outline-text-3" id="text-6-6">
<p>
The IO monad is a familiar example of a one-way monad in
Haskell. Because you can't escape from the IO monad, it is impossible
to write a function that does a computation in the IO monad but whose
result type does not include the IO type constructor. This means that
any function whose result type does not contain the IO type
constructor is guaranteed not to use the IO monad. Other monads, such
as List and Maybe, do allow values out of the monad. So it is possible
to write functions which use these monads internally but return
non-monadic values.
</p>

<p>
The wonderful feature of a one-way monad is that it can support
side-effects in its monadic operations but prevent them from
destroying the functional properties of the non-monadic portions of
the program.
</p>
</div>
</div>
</div>

<div id="outline-container-org145ce0f" class="outline-2">
<h2 id="org145ce0f"><span class="section-number-2">7</span> <span class="todo TODO">TODO</span> IO</h2>
</div>


<div id="outline-container-orge5d2d3b" class="outline-2">
<h2 id="orge5d2d3b"><span class="section-number-2">8</span> Type</h2>
<div class="outline-text-2" id="text-8">
<p>
<i>polymorphic types</i>: <code>(forall a)[a]</code> denotes the family of types, for
each type a, the type "list of a". Identifiers such as a above are
called <i>type variables</i>, and are uncapitalized to distinguish them
from specific types such as <code>Int</code>.
</p>

<p>
User can define type by using <code>data</code> declaration. e.g.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Bool</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">True</span>
</pre>
</div>

<p>
The defined type Bool has exactly two <b>values</b>: True and False. <code>Bool</code>
is a <i>type constructor</i>, <code>True</code> and <code>False</code> are <i>data constructors</i>,
or just <i>constructors</i> for short.
</p>

<p>
This is called <i>parametric polymorphism</i>, useful to define families of
types by universally quantifying them.
</p>
</div>
</div>

<div id="outline-container-orgd205ab5" class="outline-2">
<h2 id="orgd205ab5"><span class="section-number-2">9</span> <span class="todo TODO">TODO</span> Type classes</h2>
<div class="outline-text-2" id="text-9">
<p>
This is <i>ad hoc polymorphism</i>. Compared to <i>parametric polymorphism</i>,
it quantifies over some smaller set of types, e.g. those that can be
compared for equality.
</p>

<p>
It seems that type classes are defining some constrained set of types
for some type, e.g. a subset of Integers.
</p>

<p>
Take an example:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Eq</span> a <span style="color: #a020f0;">where</span> 
  (<span style="color: #a0522d;">==</span>)                  <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
</pre>
</div>

<p>
This reads: "a type a is an instance of the class Eq if there is an
(overloaded) operation ==, of the appropriate type, defined on it."
</p>

<p>
The defined type class <code>Eq</code> is not a type, but rather expresses a
constraint on a type. The constraint is called a <i>context</i>. The
context is placed at the front of type expressions. This creates the
following effect:
</p>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #0000ff;">==</span>)                    <span style="color: #a0522d;">::</span> (<span style="color: #228b22;">Eq</span> a) <span style="color: #a0522d;">=&gt;</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
</pre>
</div>

<p>
Which reads: "For every type <code>a</code> that is <b>an instance of</b> the class
Eq, == has type a-&gt;a-&gt;Bool".
</p>

<p>
Haskell also support class inheritance:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span>  (<span style="color: #228b22;">Eq</span> a) <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">Ord</span> a  <span style="color: #a020f0;">where</span>
  (<span style="color: #a0522d;">&lt;</span>), (<span style="color: #a0522d;">&lt;=</span>), (<span style="color: #a0522d;">&gt;=</span>), (<span style="color: #a0522d;">&gt;</span>)  <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
  max, min              <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> a
</pre>
</div>

<p>
We defined class <code>Ord</code> which inherits all of the operations of <code>Eq</code>,
but it has some more. Similarly, we say <code>Eq</code> is <i>superclass</i> of <code>Ord</code>,
and <code>Ord</code> is <i>subclass</i> of <code>Eq</code>.
</p>

<p>
Haskell also supports multiple inheritance.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> (<span style="color: #228b22;">Eq</span> a, <span style="color: #228b22;">Show</span> a) <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">C</span> a <span style="color: #a020f0;">where</span> <span style="color: #a0522d;">...</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4087fa6" class="outline-2">
<h2 id="org4087fa6"><span class="section-number-2">10</span> <span class="todo TODO">TODO</span> Pattern Matching</h2>
</div>


<div id="outline-container-org1d8ffcb" class="outline-2">
<h2 id="org1d8ffcb"><span class="section-number-2">11</span> <span class="todo TODO">TODO</span> Cabal</h2>
<div class="outline-text-2" id="text-11">
<p>
<a href="https://www.haskell.org/cabal/">https://www.haskell.org/cabal/</a>
</p>

<p>
Package management.
</p>
</div>
</div>



<div id="outline-container-org7855c38" class="outline-2">
<h2 id="org7855c38"><span class="section-number-2">12</span> <span class="todo TODO">TODO</span> Learn Haskell</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-org9a5fbe3" class="outline-3">
<h3 id="org9a5fbe3"><span class="section-number-3">12.1</span> <span class="todo TODO">TODO</span> Typeclasses of Haskell comparing to C++</h3>
<div class="outline-text-3" id="text-12-1">
<p>
<a href="http://www.michaelburge.us/2017/10/15/haskell-typeclasses-vs-cpp-classes.html">http://www.michaelburge.us/2017/10/15/haskell-typeclasses-vs-cpp-classes.html</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2017-12-22 Fri 17:19</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
