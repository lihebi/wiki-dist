<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-12-26 Tue 17:43 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Haskell</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hebi Li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="assets/hebi.css" /><link rel="stylesheet" type="text/css" href="assets/test.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Haskell</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org733691a">1. Concept</a>
<ul>
<li><a href="#orga95e68a">1.1. strictness</a></li>
</ul>
</li>
<li><a href="#org78d00b6">2. Lexical</a>
<ul>
<li><a href="#orgba3494f">2.1. Names</a></li>
<li><a href="#org26495da">2.2. Comment</a></li>
<li><a href="#org00f3b93">2.3. layout</a></li>
</ul>
</li>
<li><a href="#orgee4e42d">3. Expression</a></li>
<li><a href="#org85598ad">4. Declaration</a>
<ul>
<li><a href="#org6ed5149">4.1. Data Types (<code>type</code>, <code>newtype</code>, <code>data</code>)</a></li>
<li><a href="#org7e18e67">4.2. Type Classes (<code>class</code>, <code>instance</code>, <code>default</code>)</a></li>
<li><a href="#org31c4e29">4.3. nested declarations</a></li>
</ul>
</li>
<li><a href="#orga318661">5. Predefined classes</a></li>
<li><a href="#org19e6c26">6. Monad</a>
<ul>
<li><a href="#org7259989">6.1. Three Components of monad</a></li>
<li><a href="#orga8fcaf0">6.2. Type constructor</a></li>
<li><a href="#org578d690">6.3. Using class</a></li>
<li><a href="#orgd280916">6.4. the monad laws</a></li>
<li><a href="#org1edbc61">6.5. A different expression of Monad Laws</a></li>
<li><a href="#org76b59fb">6.6. One Way Monad</a></li>
</ul>
</li>
<li><a href="#org52255ef">7. Reference</a>
<ul>
<li><a href="#orga32c53e">7.1. Parsers</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org733691a" class="outline-2">
<h2 id="org733691a"><span class="section-number-2">1</span> Concept</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orga95e68a" class="outline-3">
<h3 id="orga95e68a"><span class="section-number-3">1.1</span> strictness</h3>
<div class="outline-text-3" id="text-1-1">
<p>
In a strict language, the arguments to a function are always evaluated
before it is invoked.  In a non-strict language, the arguments are not
evaluated until their values are <b>actually</b> required.  As a result, if
during the evaluation of the arguments, run-time error occurs, the
strict language will crash, but the non-strict program might finish
peacefully.
</p>

<p>
Scheme is strict, while Haskell is non-strict.
</p>
</div>
</div>
</div>

<div id="outline-container-org78d00b6" class="outline-2">
<h2 id="org78d00b6"><span class="section-number-2">2</span> Lexical</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgba3494f" class="outline-3">
<h3 id="orgba3494f"><span class="section-number-3">2.1</span> Names</h3>
<div class="outline-text-3" id="text-2-1">
<p>
There are six kinds of names:
</p>
<ul class="org-ul">
<li>(value) variables</li>
<li>(value) constructors</li>
<li>type variables</li>
<li>type constructors</li>
<li>type classes</li>
<li>module names</li>
</ul>

<p>
There are two constraints on naming:
</p>
<ul class="org-ul">
<li>lower-case vs upper-case
<ul class="org-ul">
<li>variables and type variables must begin with <b>lowercase</b> letter or
underscore</li>
<li>other 4 kinds of names must begin with <b>uppercase</b> letter</li>
</ul></li>
<li>in the same scope, <b>type constructor and type class</b> must not be the
same</li>
</ul>
</div>
</div>
<div id="outline-container-org26495da" class="outline-3">
<h3 id="org26495da"><span class="section-number-3">2.2</span> Comment</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Pretty flexible, but just use
</p>
<ul class="org-ul">
<li><code>--</code> for line comment</li>
<li><code>{- XXX -}</code> for block comment</li>
</ul>
</div>
</div>
<div id="outline-container-org00f3b93" class="outline-3">
<h3 id="org00f3b93"><span class="section-number-3">2.3</span> layout</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Haskell support two style of programming, possibly mixed: using
explicit braces and semicolons, or use indention. The rule is pretty
straight forward.
</p>

<p>
The layout rule takes effect whenever <b>the open brace is omitted</b>
after keywords <b><code>where</code></b>, <b><code>let</code></b>, <b><code>do</code></b>, <b><code>of</code></b>. If it is not
omitted, nothing happens, the indention will not matter at all. The
indention of the next lexeme is remembered, and <b>the omitted open
brace is inserted</b>. In the subsequent lines:
</p>
<ul class="org-ul">
<li>if the indention is larger, nothing inserted, i.e. it is same as
writing on the previous line</li>
<li>if the indention is the same, a semicolon is inserted</li>
<li>if the indention is smaller, a close brace is inserted, and the
layout rule ends</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgee4e42d" class="outline-2">
<h2 id="orgee4e42d"><span class="section-number-2">3</span> Expression</h2>
<div class="outline-text-2" id="text-3">
<p>
conditional
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">if</span> e1 <span style="color: #a020f0;">then</span> e2 <span style="color: #a020f0;">else</span> e3
<span style="color: #a020f0;">case</span> e1 <span style="color: #a020f0;">of</span> { <span style="color: #228b22;">True</span> <span style="color: #a0522d;">-&gt;</span> e2; <span style="color: #228b22;">False</span> <span style="color: #a0522d;">-&gt;</span> e3}
</pre>
</div>

<p>
List
</p>
<div class="org-src-container">
<pre class="src src-haskell">[e1,e2,<span style="color: #a0522d;">...</span>,ek]
e1<span style="color: #0000ff;">:</span>(e2<span style="color: #228b22;">:</span>(<span style="color: #a0522d;">...</span>(ek<span style="color: #228b22;">:[]</span>)))
</pre>
</div>

<p>
Tuple
</p>
<div class="org-src-container">
<pre class="src src-haskell">(e1,<span style="color: #a0522d;">...</span>,ek)
</pre>
</div>

<p>
enumerations (note the <code>..</code> is an operator)
</p>
<div class="org-src-container">
<pre class="src src-haskell">[e1<span style="color: #a0522d;">..</span>]
[e1,e2<span style="color: #a0522d;">..</span>]
[e1<span style="color: #a0522d;">..</span>e3]
[e1,e2<span style="color: #a0522d;">..</span>e3]
</pre>
</div>

<p>
list comprehension: Each of q<sub>i</sub> is a qualifier, can have three
forms. These qualifiers are <b>nested</b>. The first is pattern matching
that matches <code>pat</code> against a <b>list expression</b> (thus called
<i>generator</i>), the second create local bindings, the third a boolean
guard. Pattern matching creates lambda bound, while let creates
lexical bounds.
</p>

<div class="org-src-container">
<pre class="src src-haskell">[e <span style="color: #a0522d;">|</span> q1,<span style="color: #a0522d;">...</span>,qn]
</pre>
</div>

<pre class="example">
pat &lt;- exp
let decls
exp
</pre>

<p>
Let expression introduces a nested, lexically-scoped
mutually-recursive (letrec) list of <i>declarations</i>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">let</span> {d1;<span style="color: #a0522d;">...</span>;dn} <span style="color: #a020f0;">in</span> e
</pre>
</div>

<p>
case expression matches <code>e</code> against a list of patches. But if a
pattern matched, the body is not a single expression, but seems to be
another round of matching. Each match is a list of guard expression
separated by vertical bar (note <b>the first vertical bar is
mandatory</b>). Each guard expression is a list of actual guards. Only if
all the actual guards succeed, the guard expression succeeds. The
corresponding expression is the result. Seems that the top-level
patterns and the match guards have the same semantic, i.e. if one
fail, try the next one.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">case</span> e <span style="color: #a020f0;">of</span> {p1 match1; <span style="color: #a0522d;">...</span> ; pn matchn}
<span style="color: #0000ff;">match</span> <span style="color: #0000ff;">::=</span> <span style="color: #a0522d;">|</span> gs1 <span style="color: #a0522d;">-&gt;</span> e1 <span style="color: #a0522d;">|</span> gs2 <span style="color: #a0522d;">-&gt;</span> e2 <span style="color: #a0522d;">|</span> <span style="color: #a0522d;">...</span>
<span style="color: #0000ff;">gs</span> <span style="color: #0000ff;">::=</span> guard1, guard2, <span style="color: #a0522d;">...</span>
<span style="color: #0000ff;">guard</span> <span style="color: #0000ff;">::=</span> p <span style="color: #a0522d;">&lt;-</span> e
<span style="color: #0000ff;">guard</span> <span style="color: #0000ff;">::=</span> <span style="color: #a020f0;">let</span> decls
<span style="color: #0000ff;">guard</span> <span style="color: #0000ff;">::=</span> boolean guard
</pre>
</div>

<p>
do expression seems to be exclusively used in monad. It is a syntax
sugar of <i>bind</i> operation.
</p>
<pre class="example">
do x &lt;- f; g x = f &gt;&gt;= (\x -&gt; g x)
</pre>

<p>
Expression type-signature is a notation for human only. The compiler
does not need to know it, because it infers the type signature. Of
course the compiler will complain if they do not match. Thus, the
expression with type-signature simply evaluates to the expression.
</p>

<p>
The declared type may be more specific than the principal type derived
from exp, but <b>it is an error that the declared type is more
general</b>. But, it seems that, if we declare a more general type
signature <b>before</b> the use of the type (thus before the inference), it
is OK.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">exp</span> <span style="color: #a0522d;">::</span> [context <span style="color: #a0522d;">=&gt;</span>] <span style="color: #a020f0;">type</span>
</pre>
</div>

<p>
Pattern matching match pattern against values, and construct bounds.
</p>

<ol class="org-ol">
<li>matching <code>var</code> against a value <code>v</code> always succeed, and bounds <code>var</code> to <code>v</code></li>
<li>matching <code>~apat</code> against a value <code>v</code> always succeed. This is called
a irrefutable pattern, means I force it to match, don't give me
error. The error will occur when the matched bindings are
evaluated.</li>
<li>wildcard pattern <code>_</code> against any value always succeed</li>
<li>matching <code>con pat</code> where <code>con</code> is a type constructor (defined by
<code>newtype</code>), the value must also be <code>con v</code> to succeed</li>
<li>matching <code>con pat1 ... patn</code> where <code>con</code> is a data constructor
(defined by <code>data</code>), the value must also be <code>con v1 ... vn</code> with
the same constructor to succeed. The variables are bound.</li>
<li class="off"><code>[&#xa0;]</code> fields</li>
<li>matching numeric, character, or string literal will only succeed if
the value is that literal.</li>
<li>match <code>var@apat</code> will basically match <code>apat</code> against <code>v</code>, but
introduce additional bound <code>var</code> for the whole <code>v</code>.</li>
</ol>

<blockquote>
<p>
Pattern matching is a way of destructuring an algebraic data type,
selecting a code clause based on its constructor and then binding the
components to variables.
</p>
</blockquote>
</div>
</div>


<div id="outline-container-org85598ad" class="outline-2">
<h2 id="org85598ad"><span class="section-number-2">4</span> Declaration</h2>
<div class="outline-text-2" id="text-4">
<p>
Actually there are two categories of declarations: type and
binding. So first we need to figure out what is type in Haskell.
</p>

<p>
There are two <i>kinds</i> of types, namely <code>*</code> and <code>*-&gt;*</code>. In Haskell, a
type variable is assumed to be universally qualified, i.e. \(a
\rightarrow a\) means \(\forall a . a \rightarrow a\).
</p>

<p>
Type context indicates the membership of a type variable to some type
classes. The context is often written as <code>cx =&gt; t</code>.
</p>

<p>
The type that best describe an expression is its <i>principal type</i>.
</p>
</div>


<div id="outline-container-org6ed5149" class="outline-3">
<h3 id="org6ed5149"><span class="section-number-3">4.1</span> Data Types (<code>type</code>, <code>newtype</code>, <code>data</code>)</h3>
<div class="outline-text-3" id="text-4-1">
<p>
This is called <i>polymorphic types</i>: <code>(forall a)[a]</code> denotes the family
of types, for each type a, the type "list of a". Identifiers such as a
above are called <i>type variables</i>, and are uncapitalized to
distinguish them from specific types such as <code>Int</code>.  This is called
<i>parametric polymorphism</i>, useful to define families of types by
universally quantifying them.
</p>

<p>
<code>data</code> declares an algebraic datatype.  The following declares a new
<i>type constructor</i> T, with zero or more <i>data constructors</i> (or just
<i>constructor</i>) K1 to Kn.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> cx <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">T</span> u1 <span style="color: #a0522d;">...</span> uk <span style="color: #a0522d;">=</span> <span style="color: #228b22;">K1</span> t <span style="color: #a0522d;">...</span> t <span style="color: #a0522d;">|</span> <span style="color: #a0522d;">...</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Kn</span> t <span style="color: #a0522d;">...</span> t
</pre>
</div>

<p>
<code>type</code> introduces a new type that is equivalent to the old one. This
is called <i>Type Synonym</i>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">T</span> u1 <span style="color: #a0522d;">...</span> uk <span style="color: #a0522d;">=</span> t
</pre>
</div>

<p>
<code>newtype</code> introduces a new type whose representation is the same as
old one. This seems very similar to type synonyms. But this is called
<i>renaming</i>. It is introduced by the form
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">newtype</span> cx <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">T</span> u1 <span style="color: #a0522d;">...</span> uk <span style="color: #a0522d;">=</span> <span style="color: #228b22;">N</span> t
</pre>
</div>

<p>
The difference:
</p>
<ul class="org-ul">
<li><code>newtype</code> <b>creates a distinct type</b> that must be explicitly coerced
to or from the original type</li>
<li><code>newtype</code> can be used to define recursive types.</li>
<li>New instance can be defined for a <code>newtype</code>, but may not be defined
for a type synonym.</li>
</ul>
</div>
</div>

<div id="outline-container-org7e18e67" class="outline-3">
<h3 id="org7e18e67"><span class="section-number-3">4.2</span> Type Classes (<code>class</code>, <code>instance</code>, <code>default</code>)</h3>
<div class="outline-text-3" id="text-4-2">
<p>
This is <i>ad hoc polymorphism</i>. Compared to <i>parametric polymorphism</i>,
it quantifies over some smaller set of types, e.g. those that can be
compared for equality.  It seems that type classes are defining some
constrained set of types for some type, e.g. a subset of Integers.  It
defines not a type, but rather expresses a constraint on a type. The
constraint is called a <i>context</i>. The context is placed at the front
of type expressions.
</p>

<p>
The <code>class</code> declares a new <i>type class</i> (or just <i>class</i>). It will
together define a set of methods that all instance of this class must
support. You have two ways to define the instance relationship:
through an explicit <code>instance</code> declaration, or use <code>deriving</code> to embed
it into the <code>class</code> declaration.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> cx <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">C</span> u <span style="color: #a020f0;">where</span>
  op <span style="color: #a0522d;">::</span> cx <span style="color: #a0522d;">=&gt;</span> t <span style="color: #b22222;">-- </span><span style="color: #b22222;">cdecl 1</span>
  <span style="color: #a020f0;">infixr</span> 7 'op' <span style="color: #b22222;">-- </span><span style="color: #b22222;">cdecl 2</span>
  op <span style="color: #a0522d;">=</span> <span style="color: #a0522d;">...</span> <span style="color: #b22222;">-- </span><span style="color: #b22222;">cdecl 3</span>
</pre>
</div>

<p>
This introduces a class named C, with super class from <code>cx</code>. As shown
in the example, there are three kinds of decls. First is a method
declaration. This only declares the type signature of the method.
</p>

<p>
Second is a <i>fixity declaration</i>. It has the following grammar, with
integer be 0 to 9, where 9 is the highest precedence. I'm not sure why
op needs to be quoted (or is it a quote?) though.
</p>

<p>
The third declaration is a default class method for any of the method
declared.
</p>

<p>
Finally, a <code>instance</code> introduce an instance T of a class C. T is a
type constructor, and cannot be a type synonym. This is called a <i>C-T
instance declaration</i>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">instance</span> cx <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">C</span> (<span style="color: #228b22;">T</span> u1 <span style="color: #a0522d;">...</span> uk) <span style="color: #a020f0;">where</span> {d}
</pre>
</div>

<p>
Since <code>instance</code> only declares the relationship, the type T still
needs to be defined. It is also possible to declare the instance
relationship together with the declaration of type. Specifically
<code>newtype</code> and <code>data</code> can have an optional <code>deriving</code> sub-form for
that. Omitting it is equivalent to writing an empty deriving instance
<code>deriving ()</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #0000ff;">...</span> <span style="color: #a020f0;">deriving</span> <span style="color: #228b22;">C</span>
<span style="color: #a020f0;">newtype</span> <span style="color: #0000ff;">...</span> <span style="color: #a020f0;">deriving</span> <span style="color: #228b22;">C</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org31c4e29" class="outline-3">
<h3 id="org31c4e29"><span class="section-number-3">4.3</span> nested declarations</h3>
<div class="outline-text-3" id="text-4-3">
<p>
This type of declaration denotes those that can be nested inside <code>let</code>
or <code>where</code>.
</p>

<p>
First is type signature declaration
</p>
<div class="org-src-container">
<pre class="src src-haskell">var1, <span style="color: #a0522d;">...</span>, varn <span style="color: #a0522d;">::</span> cx <span style="color: #a0522d;">=&gt;</span> t
</pre>
</div>

<p>
Then the fixity declaration
</p>
<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #a020f0;">infixl</span> <span style="color: #a0522d;">|</span> <span style="color: #a020f0;">infixr</span> <span style="color: #a0522d;">|</span> <span style="color: #a020f0;">infix</span>) [integer] ops
</pre>
</div>

<p>
Function binding is a list of bindings. They are used to match
different patterns of parameters.  Each match is very similar to the
match in <code>case</code> expression, but instead use <code>=</code> instead of <code>-&gt;</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">foo</span> p1 <span style="color: #a0522d;">...</span> pn match
<span style="color: #0000ff;">foo</span> p1 <span style="color: #a0522d;">...</span> pn match
<span style="color: #a0522d;">...</span>
<span style="color: #0000ff;">match</span> <span style="color: #0000ff;">::=</span> <span style="color: #a0522d;">|</span> gs1 <span style="color: #a0522d;">=</span> e1 <span style="color: #a0522d;">|</span> gs2 <span style="color: #a0522d;">=</span> e2 <span style="color: #a0522d;">|</span> <span style="color: #a0522d;">...</span>
<span style="color: #0000ff;">gs</span> <span style="color: #0000ff;">::=</span> guard1, guard2, <span style="color: #a0522d;">...</span>
<span style="color: #0000ff;">guard</span> <span style="color: #0000ff;">::=</span> p <span style="color: #a0522d;">&lt;-</span> e
<span style="color: #0000ff;">guard</span> <span style="color: #0000ff;">::=</span> <span style="color: #a020f0;">let</span> decls
<span style="color: #0000ff;">guard</span> <span style="color: #0000ff;">::=</span> boolean guard
</pre>
</div>

<p>
Basically, it is semantically equivalent to this case statement:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">x</span> <span style="color: #a0522d;">=</span> <span style="color: #a0522d;">\</span>x1, <span style="color: #a0522d;">...</span>, xk <span style="color: #a0522d;">-&gt;</span> <span style="color: #a020f0;">case</span> (x1, <span style="color: #a0522d;">...</span>, xk) <span style="color: #a020f0;">of</span>
    p1 <span style="color: #a0522d;">...</span> pn match
    p1 <span style="color: #a0522d;">...</span> pn match
</pre>
</div>

<p>
Finally, we have pattern binding decl. The form can be:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">simple form</span>
<span style="color: #0000ff;">p</span> <span style="color: #a0522d;">=</span> e
<span style="color: #b22222;">-- </span><span style="color: #b22222;">general form</span>
<span style="color: #0000ff;">p</span> <span style="color: #0000ff;">|</span> gs1 <span style="color: #a0522d;">=</span> e1
  <span style="color: #a0522d;">|</span> gs2 <span style="color: #a0522d;">=</span> e2
  <span style="color: #a0522d;">...</span>
</pre>
</div>

<p>
This is semantically equivalent to
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">p</span> <span style="color: #a0522d;">=</span> <span style="color: #a020f0;">let</span> decls <span style="color: #a020f0;">in</span>
    <span style="color: #a020f0;">case</span> <span style="color: #228b22;">()</span> <span style="color: #a020f0;">of</span>
      <span style="color: #228b22;">()</span> <span style="color: #a0522d;">|</span> gs1 <span style="color: #a0522d;">-&gt;</span> e1
      <span style="color: #228b22;">()</span> <span style="color: #a0522d;">|</span> gs2 <span style="color: #a0522d;">-&gt;</span> e2
      <span style="color: #a0522d;">...</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orga318661" class="outline-2">
<h2 id="orga318661"><span class="section-number-2">5</span> Predefined classes</h2>
<div class="outline-text-2" id="text-5">
<p>
Here just literally copy the definition of those types.
</p>

<p>
Basic types
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">bool</span>
<span style="color: #a020f0;">data</span>  <span style="color: #228b22;">Bool</span>  <span style="color: #a0522d;">=</span>  <span style="color: #228b22;">False</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">True</span> <span style="color: #a020f0;">deriving</span>
                             (<span style="color: #228b22;">Read</span>, <span style="color: #228b22;">Show</span>, <span style="color: #228b22;">Eq</span>, <span style="color: #228b22;">Ord</span>, <span style="color: #228b22;">Enum</span>, <span style="color: #228b22;">Bounded</span>)
<span style="color: #b22222;">-- </span><span style="color: #b22222;">string</span>
<span style="color: #a020f0;">type</span>  <span style="color: #228b22;">String</span>  <span style="color: #a0522d;">=</span>  [<span style="color: #228b22;">Char</span>]
<span style="color: #b22222;">-- </span><span style="color: #b22222;">list</span>
<span style="color: #a020f0;">data</span>  [a]  <span style="color: #a0522d;">=</span>  <span style="color: #228b22;">[]</span> <span style="color: #a0522d;">|</span> a <span style="color: #228b22;">:</span> [a]  <span style="color: #a020f0;">deriving</span> (<span style="color: #228b22;">Eq</span>, <span style="color: #228b22;">Ord</span>)
<span style="color: #b22222;">-- </span><span style="color: #b22222;">unit</span>
<span style="color: #a020f0;">data</span>  <span style="color: #228b22;">()</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">()</span> <span style="color: #a020f0;">deriving</span> (<span style="color: #228b22;">Eq</span>, <span style="color: #228b22;">Ord</span>, <span style="color: #228b22;">Bounded</span>, <span style="color: #228b22;">Enum</span>, <span style="color: #228b22;">Read</span>, <span style="color: #228b22;">Show</span>)
<span style="color: #a020f0;">data</span>  <span style="color: #228b22;">Maybe</span> a     <span style="color: #a0522d;">=</span>  <span style="color: #228b22;">Nothing</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Just</span> a  <span style="color: #a020f0;">deriving</span> (<span style="color: #228b22;">Eq</span>, <span style="color: #228b22;">Ord</span>, <span style="color: #228b22;">Read</span>, <span style="color: #228b22;">Show</span>)
<span style="color: #a020f0;">data</span>  <span style="color: #228b22;">Either</span> a b  <span style="color: #a0522d;">=</span>  <span style="color: #228b22;">Left</span> a <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Right</span> b  <span style="color: #a020f0;">deriving</span> (<span style="color: #228b22;">Eq</span>, <span style="color: #228b22;">Ord</span>, <span style="color: #228b22;">Read</span>, <span style="color: #228b22;">Show</span>)
<span style="color: #a020f0;">data</span>  <span style="color: #228b22;">Ordering</span>    <span style="color: #a0522d;">=</span>  <span style="color: #228b22;">LT</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">EQ</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">GT</span> <span style="color: #a020f0;">deriving</span>
                                  (<span style="color: #228b22;">Eq</span>, <span style="color: #228b22;">Ord</span>, <span style="color: #228b22;">Bounded</span>, <span style="color: #228b22;">Enum</span>, <span style="color: #228b22;">Read</span>, <span style="color: #228b22;">Show</span>)
<span style="color: #a020f0;">class</span>  <span style="color: #228b22;">Bounded</span> a  <span style="color: #a020f0;">where</span>
    minBound, maxBound <span style="color: #a0522d;">::</span> a
</pre>
</div>

<p>
Eq is pretty canonical
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span>  <span style="color: #228b22;">Eq</span> a  <span style="color: #a020f0;">where</span>
      (<span style="color: #a0522d;">==</span>), (<span style="color: #a0522d;">/=</span>)  <span style="color: #a0522d;">::</span>  a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
      x <span style="color: #a0522d;">/=</span> y  <span style="color: #a0522d;">=</span> not (x <span style="color: #a0522d;">==</span> y)
      x <span style="color: #a0522d;">==</span> y  <span style="color: #a0522d;">=</span> not (x <span style="color: #a0522d;">/=</span> y)
<span style="color: #a020f0;">class</span>  (<span style="color: #228b22;">Eq</span> a) <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">Ord</span> a  <span style="color: #a020f0;">where</span>
   compare              <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Ordering</span>
   (<span style="color: #a0522d;">&lt;</span>), (<span style="color: #a0522d;">&lt;=</span>), (<span style="color: #a0522d;">&gt;=</span>), (<span style="color: #a0522d;">&gt;</span>) <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
   max, min             <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> a

   compare x y <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">==</span> y    <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EQ</span>
               <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">&lt;=</span> y    <span style="color: #a0522d;">=</span> <span style="color: #228b22;">LT</span>
               <span style="color: #a0522d;">|</span> otherwise <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GT</span>

   x <span style="color: #a0522d;">&lt;=</span> y  <span style="color: #a0522d;">=</span> compare x y <span style="color: #a0522d;">/=</span> <span style="color: #228b22;">GT</span>
   x <span style="color: #a0522d;">&lt;</span>  y  <span style="color: #a0522d;">=</span> compare x y <span style="color: #a0522d;">==</span> <span style="color: #228b22;">LT</span>
   x <span style="color: #a0522d;">&gt;=</span> y  <span style="color: #a0522d;">=</span> compare x y <span style="color: #a0522d;">/=</span> <span style="color: #228b22;">LT</span>
   x <span style="color: #a0522d;">&gt;</span>  y  <span style="color: #a0522d;">=</span> compare x y <span style="color: #a0522d;">==</span> <span style="color: #228b22;">GT</span>

   <span style="color: #b22222;">-- </span><span style="color: #b22222;">Note that (min x y, max x y) = (x,y) or (y,x)</span>
   max x y <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">&lt;=</span> y    <span style="color: #a0522d;">=</span>  y
           <span style="color: #a0522d;">|</span> otherwise <span style="color: #a0522d;">=</span>  x
   min x y <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">&lt;=</span> y    <span style="color: #a0522d;">=</span>  x
           <span style="color: #a0522d;">|</span> otherwise <span style="color: #a0522d;">=</span>  y
</pre>
</div>

<p>
Read and Show
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span>  <span style="color: #228b22;">ReadS</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">String</span> <span style="color: #a0522d;">-&gt;</span> [(a,<span style="color: #228b22;">String</span>)]
<span style="color: #a020f0;">type</span>  <span style="color: #228b22;">ShowS</span>   <span style="color: #a0522d;">=</span> <span style="color: #228b22;">String</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">String</span>

<span style="color: #a020f0;">class</span>  <span style="color: #228b22;">Read</span> a  <span style="color: #a020f0;">where</span>
    readsPrec <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">ReadS</span> a
    readList  <span style="color: #a0522d;">::</span> <span style="color: #228b22;">ReadS</span> [a]
    <span style="color: #b22222;">-- </span><span style="color: #b22222;">... default decl for readList given in Prelude</span>

<span style="color: #a020f0;">class</span>  <span style="color: #228b22;">Show</span> a  <span style="color: #a020f0;">where</span>
    showsPrec <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">ShowS</span>
    show      <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">String</span>
    showList  <span style="color: #a0522d;">::</span> [a] <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">ShowS</span>

    showsPrec <span style="color: #a020f0;">_</span> x s   <span style="color: #a0522d;">=</span> show x <span style="color: #a0522d;">++</span> s
    show x            <span style="color: #a0522d;">=</span> showsPrec 0 x <span style="color: #8b2252;">""</span>
    <span style="color: #b22222;">-- </span><span style="color: #b22222;">... default decl for showList given in Prelude</span>
</pre>
</div>

<p>
Enumerator is a classical example of laziness
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span>  <span style="color: #228b22;">Enum</span> a  <span style="color: #a020f0;">where</span>
    succ, pred     <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a
    toEnum         <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> a
    fromEnum       <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
    enumFrom       <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> [a]            <span style="color: #b22222;">-- </span><span style="color: #b22222;">[n..]</span>
    enumFromThen   <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> [a]       <span style="color: #b22222;">-- </span><span style="color: #b22222;">[n,n'..]</span>
    enumFromTo     <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> [a]       <span style="color: #b22222;">-- </span><span style="color: #b22222;">[n..m]</span>
    enumFromThenTo <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> [a]  <span style="color: #b22222;">-- </span><span style="color: #b22222;">[n,n'..m]</span>
</pre>
</div>

<p>
Of course we have the Monad:
</p>
<pre class="example">
class  Functor f  where
    fmap    :: (a -&gt; b) -&gt; f a -&gt; f b
class  Monad m  where
    (&gt;&gt;=)   :: m a -&gt; (a -&gt; m b) -&gt; m b
    (&gt;&gt;)    :: m a -&gt; m b -&gt; m b
    return  :: a -&gt; m a
    fail    :: String -&gt; m a

    m &gt;&gt; k  =  m &gt;&gt;= \_ -&gt; k
    fail s  = error s
</pre>
</div>
</div>

<div id="outline-container-org19e6c26" class="outline-2">
<h2 id="org19e6c26"><span class="section-number-2">6</span> Monad</h2>
<div class="outline-text-2" id="text-6">
<p>
A monad is a way to structure computations in terms of values and
sequences of computations using those values.
</p>

<blockquote>
<p>
It is useful to think of a monad as a strategy for combining
computations into more complex computations.
</p>
</blockquote>

<blockquote>
<p>
In general, use &gt;&gt; if the actions don't return a value, &gt;&gt;= if you'll
be immediately passing that value into the next action, and
do-notation otherwise.
</p>
</blockquote>
</div>


<div id="outline-container-org7259989" class="outline-3">
<h3 id="org7259989"><span class="section-number-3">6.1</span> Three Components of monad</h3>
<div class="outline-text-3" id="text-6-1">
<p>
A monad is <b>a type constructor</b>, a function called <b><code>return</code></b>, and a
combinator function called <b>bind</b> or <code>&gt;&gt;=</code>. These three elements work
together to encapsulate a strategy for combining computations to
produce more complex computations.
</p>

<p>
the monad <b>type constructor</b> defines a type of computation, the
<b>return function</b> creates primitive values of that computation type
and <b><code>&gt;&gt;=</code></b> combines computations of that type together to make more
complex computations of that type.
</p>
</div>
</div>

<div id="outline-container-orga8fcaf0" class="outline-3">
<h3 id="orga8fcaf0"><span class="section-number-3">6.2</span> Type constructor</h3>
<div class="outline-text-3" id="text-6-2">
<p>
A type constructor is a parameterized type definition used with
polymorphic types.
</p>
</div>
</div>

<div id="outline-container-org578d690" class="outline-3">
<h3 id="org578d690"><span class="section-number-3">6.3</span> Using class</h3>
<div class="outline-text-3" id="text-6-3">
<p>
To define a monad, you basically need the three components. You can do
it from scratch, but a better idea is through the use of class
<code>Monad</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Monad</span> m <span style="color: #a020f0;">where</span>
    (<span style="color: #a0522d;">&gt;&gt;=</span>)  <span style="color: #a0522d;">::</span> m a <span style="color: #a0522d;">-&gt;</span> (a <span style="color: #a0522d;">-&gt;</span> m b) <span style="color: #a0522d;">-&gt;</span> m b
    return <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> m a
</pre>
</div>

<p>
There's a <i>do notation</i> that can be used with a monad. It is a
syntactic sugar that "provides a simple, imperative-style notation for
describing computations with monads"
</p>

<p>
Apart from these two operations, the <code>Monad</code> class also has two more
operations: <code>fail</code> and <code>&gt;&gt;</code>. They are optional. Use <code>fail</code> if you want
to have different behavior for failure. The <code>&gt;&gt;</code> function is a
convenience operator that "used to bind a monadic computation that
does not require input from the previous computation in the sequence."
It is defined in terms of &gt;&gt;=:
</p>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #0000ff;">&gt;&gt;</span>) <span style="color: #a0522d;">::</span> m a <span style="color: #a0522d;">-&gt;</span> m b <span style="color: #a0522d;">-&gt;</span> m b
m <span style="color: #0000ff;">&gt;&gt;</span> k <span style="color: #a0522d;">=</span> m <span style="color: #a0522d;">&gt;&gt;=</span> (<span style="color: #a0522d;">\</span><span style="color: #a020f0;">_</span> <span style="color: #a0522d;">-&gt;</span> k)
</pre>
</div>

<p>
So the full version should be
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Monad</span> m <span style="color: #a020f0;">where</span>
  (<span style="color: #a0522d;">&gt;&gt;=</span>)  <span style="color: #a0522d;">::</span> m a <span style="color: #a0522d;">-&gt;</span> (  a <span style="color: #a0522d;">-&gt;</span> m b) <span style="color: #a0522d;">-&gt;</span> m b
  (<span style="color: #a0522d;">&gt;&gt;</span>)   <span style="color: #a0522d;">::</span> m a <span style="color: #a0522d;">-&gt;</span>  m b         <span style="color: #a0522d;">-&gt;</span> m b
  return <span style="color: #a0522d;">::</span>   a                 <span style="color: #a0522d;">-&gt;</span> m a
  fail   <span style="color: #a0522d;">::</span> <span style="color: #228b22;">String</span> <span style="color: #a0522d;">-&gt;</span> m a
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd280916" class="outline-3">
<h3 id="orgd280916"><span class="section-number-3">6.4</span> the monad laws</h3>
<div class="outline-text-3" id="text-6-4">
<p>
All instances of Monad should obey the following equations, called
<i>Monad Laws</i>:
</p>

<pre class="example">
return a &gt;&gt;= k                  =  k a
m        &gt;&gt;= return             =  m
m        &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)  =  (m &gt;&gt;= k) &gt;&gt;= h
</pre>

<ol class="org-ol">
<li>return is a <b>left-identity</b> with respect to &gt;&gt;=</li>
<li>return is a <b>right-identity</b> with respect to &gt;&gt;=</li>
<li>a kind of <b>associativity</b> law for &gt;&gt;=</li>
</ol>

<p>
Any type constructor with return and bind operators that satisfy the
three monad laws is a monad.
</p>

<p>
The compiler, however, does not check these laws.
</p>
</div>
</div>

<div id="outline-container-org1edbc61" class="outline-3">
<h3 id="org1edbc61"><span class="section-number-3">6.5</span> A different expression of Monad Laws</h3>
<div class="outline-text-3" id="text-6-5">
<ol class="org-ol">
<li>create a description of a computation that will produce
(a.k.a. "return") a given Haskell value, and</li>
<li>combine (a.k.a. "bind") a computation description with a reaction
to it
<ul class="org-ul">
<li>a pure Haskell function that is set to receive a
computation-produced value (when and if that happens) and return
another computation description, using or dependent on that value
if need be</li>
<li>creating a description of a combined computation that will feed
the original computation's output through the reaction while
automatically taking care of the particulars of the computational
process itself.</li>
</ul></li>
</ol>
</div>
</div>


<div id="outline-container-org76b59fb" class="outline-3">
<h3 id="org76b59fb"><span class="section-number-3">6.6</span> One Way Monad</h3>
<div class="outline-text-3" id="text-6-6">
<p>
The IO monad is a familiar example of a one-way monad in
Haskell. Because you can't escape from the IO monad, it is impossible
to write a function that does a computation in the IO monad but whose
result type does not include the IO type constructor. This means that
any function whose result type does not contain the IO type
constructor is guaranteed not to use the IO monad. Other monads, such
as List and Maybe, do allow values out of the monad. So it is possible
to write functions which use these monads internally but return
non-monadic values.
</p>

<p>
The wonderful feature of a one-way monad is that it can support
side-effects in its monadic operations but prevent them from
destroying the functional properties of the non-monadic portions of
the program.
</p>
</div>
</div>
</div>

<div id="outline-container-org52255ef" class="outline-2">
<h2 id="org52255ef"><span class="section-number-2">7</span> Reference</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li class="on"><code>[X]</code> Haskell wiki: <a href="https://wiki.haskell.org">https://wiki.haskell.org</a></li>
<li class="on"><code>[X]</code> Haskell wiki book: <a href="https://en.wikibooks.org/wiki/Haskell">https://en.wikibooks.org/wiki/Haskell</a></li>
<li class="on"><code>[X]</code> Write yourself a scheme: <a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours</a></li>
<li class="on"><code>[X]</code> The tutorial: <a href="https://www.haskell.org/tutorial/index.html">https://www.haskell.org/tutorial/index.html</a></li>
<li class="on"><code>[X]</code> language specification: <a href="https://wiki.haskell.org/Language_and_library_specification">https://wiki.haskell.org/Language_and_library_specification</a></li>
<li class="on"><code>[X]</code> GHC: <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/">https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/</a></li>
<li class="on"><code>[X]</code> Cabal: package management <a href="https://www.haskell.org/cabal/">https://www.haskell.org/cabal/</a></li>
</ul>
</div>

<div id="outline-container-orga32c53e" class="outline-3">
<h3 id="orga32c53e"><span class="section-number-3">7.1</span> Parsers</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li class="on"><code>[X]</code> Parsec Parser: <a href="https://hackage.haskell.org/package/parsec">https://hackage.haskell.org/package/parsec</a>
<ul class="org-ul">
<li class="on"><code>[X]</code> megaparsec: This is a fork of parsec <a href="https://hackage.haskell.org/package/megaparsec">https://hackage.haskell.org/package/megaparsec</a></li>
</ul></li>
<li class="on"><code>[X]</code> Happy parser: <a href="https://www.haskell.org/happy/">https://www.haskell.org/happy/</a></li>
<li class="on"><code>[X]</code> Alex: <a href="https://www.haskell.org/alex/">https://www.haskell.org/alex/</a></li>
<li class="on"><code>[X]</code> Earley: believe it or not, this is a new one. <a href="https://hackage.haskell.org/package/Earley">https://hackage.haskell.org/package/Earley</a></li>
<li>attoparsec: another combinator, but seems not feature
rich. <a href="https://github.com/bos/attoparsec">https://github.com/bos/attoparsec</a></li>
<li>trifecta: this is yet another combinator. But seems to be out of
date and buggy? <a href="https://github.com/ekmett/trifecta/">https://github.com/ekmett/trifecta/</a></li>
<li>parsers: also combinator. <a href="https://hackage.haskell.org/package/parsers">https://hackage.haskell.org/package/parsers</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hebi Li</p>
<p class="date">Created: 2017-12-26 Tue 17:43</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
